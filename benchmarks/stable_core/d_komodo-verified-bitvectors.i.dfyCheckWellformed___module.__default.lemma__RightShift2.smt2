(set-option :print-success false)
(set-info :smt-lib-version 2.0)
(set-option :AUTO_CONFIG false)
(set-option :pp.bv_literals false)
(set-option :MODEL.V2 true)
(set-option :NNF.SK_HACK true)
(set-option :smt.MBQI false)
(set-option :smt.QI.EAGER_THRESHOLD 100)
(set-option :TYPE_CHECK true)
(set-option :smt.BV.REFLECT true)
(set-info :category "industrial")
(declare-sort |T@U| 0)
(declare-sort |T@T| 0)
(declare-fun real_pow (Real Real) Real)
(declare-fun UOrdering2 (|T@U| |T@U|) Bool)
(declare-fun UOrdering3 (|T@T| |T@U| |T@U|) Bool)
(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun Ctor (T@T) Int)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun boolType () T@T)
(declare-fun int_2_U (Int) T@U)
(declare-fun U_2_int (T@U) Int)
(declare-fun type (T@U) T@T)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun TyType () T@T)
(declare-fun TBool () T@U)
(declare-fun TChar () T@U)
(declare-fun TInt () T@U)
(declare-fun TReal () T@U)
(declare-fun TyTagType () T@T)
(declare-fun TagBool () T@U)
(declare-fun TagChar () T@U)
(declare-fun TagInt () T@U)
(declare-fun TagReal () T@U)
(declare-fun TagSet () T@U)
(declare-fun TagISet () T@U)
(declare-fun TagMultiSet () T@U)
(declare-fun TagSeq () T@U)
(declare-fun TagMap () T@U)
(declare-fun TagIMap () T@U)
(declare-fun TagClass () T@U)
(declare-fun ClassNameType () T@T)
(declare-fun NoTraitAtAll () T@U)
(declare-fun class._System.int () T@U)
(declare-fun class._System.bool () T@U)
(declare-fun class._System.set () T@U)
(declare-fun class._System.seq () T@U)
(declare-fun class._System.multiset () T@U)
(declare-fun FieldType (T@T) T@T)
(declare-fun FieldTypeInv0 (T@T) T@T)
(declare-fun alloc () T@U)
(declare-fun Tagclass._System.nat () T@U)
(declare-fun class._System.object () T@U)
(declare-fun Tagclass._System.object () T@U)
(declare-fun class._System.array () T@U)
(declare-fun Tagclass._System.array () T@U)
(declare-fun Tagclass._System.___hFunc0 () T@U)
(declare-fun Tagclass._System.___hFunc1 () T@U)
(declare-fun Tagclass._System.___hFunc2 () T@U)
(declare-fun class._System.__tuple_h2 () T@U)
(declare-fun DtCtorIdType () T@T)
(declare-fun |##_System._tuple#2._#Make2| () T@U)
(declare-fun Tagclass._System.__tuple_h2 () T@U)
(declare-fun class._module.__default () T@U)
(declare-fun Tagclass._module.__default () T@U)
(declare-fun Tagclass._module.word () T@U)
(declare-fun Tagclass._module.shift__amount () T@U)
(declare-fun Tagclass._module.addr () T@U)
(declare-fun $$Language$Dafny () Bool)
(declare-fun TSet (T@U) T@U)
(declare-fun Inv0_TSet (T@U) T@U)
(declare-fun TISet (T@U) T@U)
(declare-fun Inv0_TISet (T@U) T@U)
(declare-fun TSeq (T@U) T@U)
(declare-fun Inv0_TSeq (T@U) T@U)
(declare-fun TMultiSet (T@U) T@U)
(declare-fun Inv0_TMultiSet (T@U) T@U)
(declare-fun TMap (T@U T@U) T@U)
(declare-fun Inv0_TMap (T@U) T@U)
(declare-fun Inv1_TMap (T@U) T@U)
(declare-fun TIMap (T@U T@U) T@U)
(declare-fun Inv0_TIMap (T@U) T@U)
(declare-fun Inv1_TIMap (T@U) T@U)
(declare-fun Tag (T@U) T@U)
(declare-fun LitInt (Int) Int)
(declare-fun BoxType () T@T)
(declare-fun $Box (T@U) T@U)
(declare-fun Lit (T@U) T@U)
(declare-fun LitReal (Real) Real)
(declare-fun charType () T@T)
(declare-fun |char#FromInt| (Int) T@U)
(declare-fun |char#ToInt| (T@U) Int)
(declare-fun $Unbox (T@T T@U) T@U)
(declare-fun $IsBox (T@U T@U) Bool)
(declare-fun $Is (T@U T@U) Bool)
(declare-fun MapType0Type (T@T T@T) T@T)
(declare-fun MapType0TypeInv0 (T@T) T@T)
(declare-fun MapType0TypeInv1 (T@T) T@T)
(declare-fun MapType0Select (T@U T@U) T@U)
(declare-fun MapType0Store (T@U T@U T@U) T@U)
(declare-fun SeqType (T@T) T@T)
(declare-fun SeqTypeInv0 (T@T) T@T)
(declare-fun MapType (T@T T@T) T@T)
(declare-fun MapTypeInv0 (T@T) T@T)
(declare-fun MapTypeInv1 (T@T) T@T)
(declare-fun IMapType (T@T T@T) T@T)
(declare-fun IMapTypeInv0 (T@T) T@T)
(declare-fun IMapTypeInv1 (T@T) T@T)
(declare-fun MapType1Type (T@T) T@T)
(declare-fun MapType1TypeInv0 (T@T) T@T)
(declare-fun MapType1Select (T@U T@U T@U) T@U)
(declare-fun MapType1Store (T@U T@U T@U T@U) T@U)
(declare-fun refType () T@T)
(declare-fun $IsAllocBox (T@U T@U T@U) Bool)
(declare-fun $IsAlloc (T@U T@U T@U) Bool)
(declare-fun $IsGoodMultiSet (T@U) Bool)
(declare-fun |Seq#Index| (T@U Int) T@U)
(declare-fun |Seq#Length| (T@U) Int)
(declare-fun |Map#Elements| (T@U) T@U)
(declare-fun |Map#Domain| (T@U) T@U)
(declare-fun |IMap#Elements| (T@U) T@U)
(declare-fun |IMap#Domain| (T@U) T@U)
(declare-fun TypeTuple (T@U T@U) T@U)
(declare-fun TypeTupleCar (T@U) T@U)
(declare-fun TypeTupleCdr (T@U) T@U)
(declare-fun SetRef_to_SetBox (T@U) T@U)
(declare-fun Tclass._System.object () T@U)
(declare-fun DatatypeTypeType () T@T)
(declare-fun BoxRank (T@U) Int)
(declare-fun DtRank (T@U) Int)
(declare-fun LayerTypeType () T@T)
(declare-fun AtLayer (T@U T@U) T@U)
(declare-fun $LS (T@U) T@U)
(declare-fun IndexField (Int) T@U)
(declare-fun FDim (T@U) Int)
(declare-fun IndexField_Inverse (T@U) Int)
(declare-fun MultiIndexField (T@U Int) T@U)
(declare-fun MultiIndexField_Inverse0 (T@U) T@U)
(declare-fun MultiIndexField_Inverse1 (T@U) Int)
(declare-fun NameFamilyType () T@T)
(declare-fun FieldOfDecl (T@T T@U T@U) T@U)
(declare-fun DeclType (T@U) T@U)
(declare-fun DeclName (T@U) T@U)
(declare-fun $HeapSucc (T@U T@U) Bool)
(declare-fun $IsGhostField (T@U) Bool)
(declare-fun _System.array.Length (T@U) Int)
(declare-fun q@Int (Real) Int)
(declare-fun q@Real (Int) Real)
(declare-fun $IsGoodHeap (T@U) Bool)
(declare-fun $HeapSuccGhost (T@U T@U) Bool)
(declare-fun |Set#Card| (T@U) Int)
(declare-fun |Set#Empty| (T@T) T@U)
(declare-fun |Set#Singleton| (T@U) T@U)
(declare-fun |Set#UnionOne| (T@U T@U) T@U)
(declare-fun |Set#Union| (T@U T@U) T@U)
(declare-fun |Set#Difference| (T@U T@U) T@U)
(declare-fun |Set#Disjoint| (T@U T@U) Bool)
(declare-fun |Set#Intersection| (T@U T@U) T@U)
(declare-fun |Set#Subset| (T@U T@U) Bool)
(declare-fun |Set#Equal| (T@U T@U) Bool)
(declare-fun |ISet#Empty| (T@T) T@U)
(declare-fun |ISet#UnionOne| (T@U T@U) T@U)
(declare-fun |ISet#Union| (T@U T@U) T@U)
(declare-fun |ISet#Difference| (T@U T@U) T@U)
(declare-fun |ISet#Disjoint| (T@U T@U) Bool)
(declare-fun |ISet#Intersection| (T@U T@U) T@U)
(declare-fun |ISet#Subset| (T@U T@U) Bool)
(declare-fun |ISet#Equal| (T@U T@U) Bool)
(declare-fun |Math#min| (Int Int) Int)
(declare-fun |Math#clip| (Int) Int)
(declare-fun |MultiSet#Card| (T@U) Int)
(declare-fun |MultiSet#Empty| (T@T) T@U)
(declare-fun |MultiSet#Singleton| (T@U) T@U)
(declare-fun |MultiSet#UnionOne| (T@U T@U) T@U)
(declare-fun |MultiSet#Union| (T@U T@U) T@U)
(declare-fun |MultiSet#Intersection| (T@U T@U) T@U)
(declare-fun |MultiSet#Difference| (T@U T@U) T@U)
(declare-fun |MultiSet#Subset| (T@U T@U) Bool)
(declare-fun |MultiSet#Equal| (T@U T@U) Bool)
(declare-fun |MultiSet#Disjoint| (T@U T@U) Bool)
(declare-fun |MultiSet#FromSet| (T@U) T@U)
(declare-fun |MultiSet#FromSeq| (T@U) T@U)
(declare-fun |Seq#Build| (T@U T@U) T@U)
(declare-fun |Seq#Empty| (T@T) T@U)
(declare-fun |Seq#Append| (T@U T@U) T@U)
(declare-fun |Seq#Update| (T@U Int T@U) T@U)
(declare-fun |Seq#Singleton| (T@U) T@U)
(declare-fun |Seq#Build_inv0| (T@U) T@U)
(declare-fun |Seq#Build_inv1| (T@U) T@U)
(declare-fun |Seq#Contains| (T@U T@U) Bool)
(declare-fun |Seq#Take| (T@U Int) T@U)
(declare-fun |Seq#Drop| (T@U Int) T@U)
(declare-fun |Seq#Equal| (T@U T@U) Bool)
(declare-fun |Seq#SameUntil| (T@U T@U Int) Bool)
(declare-fun |Seq#FromArray| (T@U T@U) T@U)
(declare-fun |Seq#Rank| (T@U) Int)
(declare-fun |Map#Card| (T@U) Int)
(declare-fun |Map#Values| (T@U) T@U)
(declare-fun |Map#Items| (T@U) T@U)
(declare-fun _System.__tuple_h2._0 (T@U) T@U)
(declare-fun _System.__tuple_h2._1 (T@U) T@U)
(declare-fun |Map#Empty| (T@T T@T) T@U)
(declare-fun |Map#Glue| (T@U T@U T@U) T@U)
(declare-fun |Map#Build| (T@U T@U T@U) T@U)
(declare-fun |Map#Equal| (T@U T@U) Bool)
(declare-fun |Map#Disjoint| (T@U T@U) Bool)
(declare-fun |IMap#Values| (T@U) T@U)
(declare-fun |IMap#Items| (T@U) T@U)
(declare-fun |IMap#Empty| (T@T T@T) T@U)
(declare-fun |IMap#Glue| (T@U T@U T@U) T@U)
(declare-fun |IMap#Build| (T@U T@U T@U) T@U)
(declare-fun |IMap#Equal| (T@U T@U) Bool)
(declare-fun INTERNAL_add_boogie (Int Int) Int)
(declare-fun INTERNAL_sub_boogie (Int Int) Int)
(declare-fun INTERNAL_mul_boogie (Int Int) Int)
(declare-fun INTERNAL_div_boogie (Int Int) Int)
(declare-fun INTERNAL_mod_boogie (Int Int) Int)
(declare-fun INTERNAL_lt_boogie (Int Int) Bool)
(declare-fun INTERNAL_le_boogie (Int Int) Bool)
(declare-fun INTERNAL_gt_boogie (Int Int) Bool)
(declare-fun INTERNAL_ge_boogie (Int Int) Bool)
(declare-fun nat_from_bv32 ((_ BitVec 32)) Int)
(declare-fun Tclass._System.nat () T@U)
(declare-fun null () T@U)
(declare-fun Tclass._System.array (T@U) T@U)
(declare-fun Tclass._System.array_0 (T@U) T@U)
(declare-fun dtype (T@U) T@U)
(declare-fun Tclass._System.___hFunc0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc0_0 (T@U) T@U)
(declare-fun HandleTypeType () T@T)
(declare-fun Apply0 (T@U T@U T@U) T@U)
(declare-fun Handle0 (T@U T@U T@U) T@U)
(declare-fun Requires0 (T@U T@U T@U) Bool)
(declare-fun Reads0 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1 (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1_1 (T@U) T@U)
(declare-fun MapType2Type (T@T T@T T@T) T@T)
(declare-fun MapType2TypeInv0 (T@T) T@T)
(declare-fun MapType2TypeInv1 (T@T) T@T)
(declare-fun MapType2TypeInv2 (T@T) T@T)
(declare-fun MapType2Select (T@U T@U T@U) T@U)
(declare-fun MapType2Store (T@U T@U T@U T@U) T@U)
(declare-fun Apply1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Handle1 (T@U T@U T@U) T@U)
(declare-fun Requires1 (T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc2 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc2_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2_2 (T@U) T@U)
(declare-fun MapType3Type (T@T T@T T@T T@T) T@T)
(declare-fun MapType3TypeInv0 (T@T) T@T)
(declare-fun MapType3TypeInv1 (T@T) T@T)
(declare-fun MapType3TypeInv2 (T@T) T@T)
(declare-fun MapType3TypeInv3 (T@T) T@T)
(declare-fun MapType3Select (T@U T@U T@U T@U) T@U)
(declare-fun MapType3Store (T@U T@U T@U T@U T@U) T@U)
(declare-fun Apply2 (T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Handle2 (T@U T@U T@U) T@U)
(declare-fun Requires2 (T@U T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads2 (T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun |#_System._tuple#2._#Make2| (T@U T@U) T@U)
(declare-fun DatatypeCtorId (T@U) T@U)
(declare-fun _System.__tuple_h2.___hMake2_q (T@U) Bool)
(declare-fun Tclass._System.__tuple_h2 (T@U T@U) T@U)
(declare-fun Tclass._System.__tuple_h2_0 (T@U) T@U)
(declare-fun Tclass._System.__tuple_h2_1 (T@U) T@U)
(declare-fun |$IsA#_System.__tuple_h2| (T@U) Bool)
(declare-fun Tclass._module.__default () T@U)
(declare-fun Tclass._module.word () T@U)
(declare-fun _module.__default.WordAsBits (T@U Int) (_ BitVec 32))
(declare-fun AsFuelBottom (T@U) T@U)
(declare-fun $LZ () T@U)
(declare-fun bv32_2_U ((_ BitVec 32)) T@U)
(declare-fun U_2_bv32 (T@U) (_ BitVec 32))
(declare-fun bv32Type () T@T)
(declare-fun |_module.__default.WordAsBits#canCall| (Int) Bool)
(declare-fun _module.__default.isUInt32 (Int) Bool)
(declare-fun |_module.__default.WordAsBits#requires| (T@U Int) Bool)
(declare-fun _module.__default.BitsAsWord (T@U (_ BitVec 32)) Int)
(declare-fun |_module.__default.BitsAsWord#requires| (T@U (_ BitVec 32)) Bool)
(declare-fun _module.__default.BitAdd (T@U (_ BitVec 32) (_ BitVec 32)) (_ BitVec 32))
(declare-fun |_module.__default.BitAdd#requires| (T@U (_ BitVec 32) (_ BitVec 32)) Bool)
(declare-fun _module.__default.BitSub (T@U (_ BitVec 32) (_ BitVec 32)) (_ BitVec 32))
(declare-fun |_module.__default.BitSub#requires| (T@U (_ BitVec 32) (_ BitVec 32)) Bool)
(declare-fun _module.__default.BitAnd (T@U (_ BitVec 32) (_ BitVec 32)) (_ BitVec 32))
(declare-fun |_module.__default.BitAnd#requires| (T@U (_ BitVec 32) (_ BitVec 32)) Bool)
(declare-fun _module.__default.BitOr (T@U (_ BitVec 32) (_ BitVec 32)) (_ BitVec 32))
(declare-fun |_module.__default.BitOr#requires| (T@U (_ BitVec 32) (_ BitVec 32)) Bool)
(declare-fun _module.__default.BitXor (T@U (_ BitVec 32) (_ BitVec 32)) (_ BitVec 32))
(declare-fun |_module.__default.BitXor#requires| (T@U (_ BitVec 32) (_ BitVec 32)) Bool)
(declare-fun _module.__default.BitMod (T@U (_ BitVec 32) (_ BitVec 32)) (_ BitVec 32))
(declare-fun |_module.__default.BitMod#canCall| ((_ BitVec 32) (_ BitVec 32)) Bool)
(declare-fun |_module.__default.BitMod#requires| (T@U (_ BitVec 32) (_ BitVec 32)) Bool)
(declare-fun _module.__default.BitDiv (T@U (_ BitVec 32) (_ BitVec 32)) (_ BitVec 32))
(declare-fun |_module.__default.BitDiv#canCall| ((_ BitVec 32) (_ BitVec 32)) Bool)
(declare-fun |_module.__default.BitDiv#requires| (T@U (_ BitVec 32) (_ BitVec 32)) Bool)
(declare-fun _module.__default.BitMul (T@U (_ BitVec 32) (_ BitVec 32)) (_ BitVec 32))
(declare-fun |_module.__default.BitMul#requires| (T@U (_ BitVec 32) (_ BitVec 32)) Bool)
(declare-fun _module.__default.BitNot (T@U (_ BitVec 32)) (_ BitVec 32))
(declare-fun |_module.__default.BitNot#requires| (T@U (_ BitVec 32)) Bool)
(declare-fun _module.__default.BitShiftLeft (T@U (_ BitVec 32) Int) (_ BitVec 32))
(declare-fun |_module.__default.BitShiftLeft#canCall| ((_ BitVec 32) Int) Bool)
(declare-fun |_module.__default.BitShiftLeft#requires| (T@U (_ BitVec 32) Int) Bool)
(declare-fun _module.__default.BitShiftRight (T@U (_ BitVec 32) Int) (_ BitVec 32))
(declare-fun |_module.__default.BitShiftRight#canCall| ((_ BitVec 32) Int) Bool)
(declare-fun |_module.__default.BitShiftRight#requires| (T@U (_ BitVec 32) Int) Bool)
(declare-fun _module.__default.BitRotateRight (T@U (_ BitVec 32) Int) (_ BitVec 32))
(declare-fun |_module.__default.BitRotateRight#canCall| ((_ BitVec 32) Int) Bool)
(declare-fun |_module.__default.BitRotateRight#requires| (T@U (_ BitVec 32) Int) Bool)
(declare-fun _module.__default.pow2 (T@U Int) Int)
(declare-fun |_module.__default.pow2#canCall| (Int) Bool)
(declare-fun |_module.__default.pow2#requires| (T@U Int) Bool)
(declare-fun _module.__default.BitAtPos_k (Int) (_ BitVec 32))
(declare-fun |_module.__default.BitAtPos_k#canCall| (Int) Bool)
(declare-fun |_module.__default.BitAtPos_k#requires| (Int) Bool)
(declare-fun _module.__default.BitAtPos (T@U Int) (_ BitVec 32))
(declare-fun StartFuel__module._default.BitsAsWord () T@U)
(declare-fun StartFuel__module._default.pow2 () T@U)
(declare-fun |_module.__default.BitAtPos#canCall| (Int) Bool)
(declare-fun |_module.__default.BitAtPos#requires| (T@U Int) Bool)
(declare-fun _module.__default.BitmaskLow (Int) (_ BitVec 32))
(declare-fun |_module.__default.BitmaskLow#canCall| (Int) Bool)
(declare-fun |_module.__default.BitmaskLow#requires| (Int) Bool)
(declare-fun StartFuel__module._default.BitAtPos () T@U)
(declare-fun _module.__default.BitmaskHigh (Int) (_ BitVec 32))
(declare-fun |_module.__default.BitmaskHigh#canCall| (Int) Bool)
(declare-fun |_module.__default.BitmaskHigh#requires| (Int) Bool)
(declare-fun StartFuel__module._default.BitNot () T@U)
(declare-fun |_module.__default.BitNot#canCall| ((_ BitVec 32)) Bool)
(declare-fun _module.__default.pow2__properties (Int) Bool)
(declare-fun |_module.__default.pow2__properties#canCall| (Int) Bool)
(declare-fun |_module.__default.pow2__properties#requires| (Int) Bool)
(declare-fun _module.__default.BitwiseMaskHigh (T@U Int Int) Int)
(declare-fun |_module.__default.BitwiseMaskHigh#canCall| (Int Int) Bool)
(declare-fun |_module.__default.BitwiseMaskHigh#requires| (T@U Int Int) Bool)
(declare-fun StartFuel__module._default.WordAsBits () T@U)
(declare-fun StartFuel__module._default.BitAnd () T@U)
(declare-fun |_module.__default.BitAnd#canCall| ((_ BitVec 32) (_ BitVec 32)) Bool)
(declare-fun |_module.__default.BitsAsWord#canCall| ((_ BitVec 32)) Bool)
(declare-fun _module.__default.BitwiseMaskLow (T@U Int Int) Int)
(declare-fun |_module.__default.BitwiseMaskLow#canCall| (Int Int) Bool)
(declare-fun |_module.__default.BitwiseMaskLow#requires| (T@U Int Int) Bool)
(declare-fun _module.__default.BitwiseXor (Int Int) Int)
(declare-fun |_module.__default.BitwiseXor#canCall| (Int Int) Bool)
(declare-fun |_module.__default.BitwiseXor#requires| (Int Int) Bool)
(declare-fun StartFuel__module._default.BitXor () T@U)
(declare-fun |_module.__default.BitXor#canCall| ((_ BitVec 32) (_ BitVec 32)) Bool)
(declare-fun _module.__default.BitwiseAnd (Int Int) Int)
(declare-fun |_module.__default.BitwiseAnd#canCall| (Int Int) Bool)
(declare-fun |_module.__default.BitwiseAnd#requires| (Int Int) Bool)
(declare-fun _module.__default.BitwiseOr (Int Int) Int)
(declare-fun |_module.__default.BitwiseOr#canCall| (Int Int) Bool)
(declare-fun |_module.__default.BitwiseOr#requires| (Int Int) Bool)
(declare-fun StartFuel__module._default.BitOr () T@U)
(declare-fun |_module.__default.BitOr#canCall| ((_ BitVec 32) (_ BitVec 32)) Bool)
(declare-fun _module.__default.BitwiseNot (Int) Int)
(declare-fun |_module.__default.BitwiseNot#canCall| (Int) Bool)
(declare-fun |_module.__default.BitwiseNot#requires| (Int) Bool)
(declare-fun _module.__default.LeftShift (Int Int) Int)
(declare-fun |_module.__default.LeftShift#canCall| (Int Int) Bool)
(declare-fun |_module.__default.LeftShift#requires| (Int Int) Bool)
(declare-fun StartFuel__module._default.BitShiftLeft () T@U)
(declare-fun _module.__default.RightShift (Int Int) Int)
(declare-fun |_module.__default.RightShift#canCall| (Int Int) Bool)
(declare-fun |_module.__default.RightShift#requires| (Int Int) Bool)
(declare-fun StartFuel__module._default.BitShiftRight () T@U)
(declare-fun _module.__default.RotateRight (Int Int) Int)
(declare-fun |_module.__default.RotateRight#canCall| (Int Int) Bool)
(declare-fun |_module.__default.RotateRight#requires| (Int Int) Bool)
(declare-fun StartFuel__module._default.BitRotateRight () T@U)
(declare-fun _module.__default.UpdateTopBits (T@U Int Int) Int)
(declare-fun |_module.__default.UpdateTopBits#canCall| (Int Int) Bool)
(declare-fun |_module.__default.UpdateTopBits#requires| (T@U Int Int) Bool)
(declare-fun StartFuel__module._default.BitwiseMaskLow () T@U)
(declare-fun |_module.__default.isUInt32#requires| (Int) Bool)
(declare-fun _module.__default.WordAligned (T@U Int) Bool)
(declare-fun |_module.__default.WordAligned#requires| (T@U Int) Bool)
(declare-fun StartFuel__module._default.WordAligned () T@U)
(declare-fun _module.__default.WordsToBytes (Int) Int)
(declare-fun |_module.__default.WordsToBytes#requires| (Int) Bool)
(declare-fun MoreFuel__module._default.WordAligned0 () T@U)
(declare-fun StartFuelAssert__module._default.WordAligned () T@U)
(declare-fun MoreFuel__module._default.WordAligned1 () T@U)
(declare-fun _module.__default.BytesToWords (Int) Int)
(declare-fun |_module.__default.BytesToWords#canCall| (Int) Bool)
(declare-fun |_module.__default.BytesToWords#requires| (Int) Bool)
(declare-fun MoreFuel__module._default.WordAligned2 () T@U)
(declare-fun MoreFuel__module._default.WordAligned3 () T@U)
(declare-fun _module.__default.TruncateWord (T@U Int) Int)
(declare-fun |_module.__default.TruncateWord#requires| (T@U Int) Bool)
(declare-fun _module.__default.WordOffset_k (Int Int) Int)
(declare-fun |_module.__default.WordOffset_k#canCall| (Int Int) Bool)
(declare-fun |_module.__default.WordOffset_k#requires| (Int Int) Bool)
(declare-fun MoreFuel__module._default.WordAligned4 () T@U)
(declare-fun |_module.__default.WordsToBytes#canCall| (Int) Bool)
(declare-fun MoreFuel__module._default.WordAligned5 () T@U)
(declare-fun _module.__default.ValidWordOffset (Int Int) Bool)
(declare-fun |_module.__default.ValidWordOffset#canCall| (Int Int) Bool)
(declare-fun |_module.__default.ValidWordOffset#requires| (Int Int) Bool)
(declare-fun |_module.__default.WordAligned#canCall| (Int) Bool)
(declare-fun |_module.__default.isUInt32#canCall| (Int) Bool)
(declare-fun _module.__default.WordOffset (Int Int) Int)
(declare-fun |_module.__default.WordOffset#canCall| (Int Int) Bool)
(declare-fun |_module.__default.WordOffset#requires| (Int Int) Bool)
(declare-fun _module.__default.PageAligned (T@U Int) Bool)
(declare-fun |_module.__default.PageAligned#canCall| (Int) Bool)
(declare-fun |_module.__default.PageAligned#requires| (T@U Int) Bool)
(declare-fun _module.__default.WordAlignedAdd (Int Int) Int)
(declare-fun |_module.__default.WordAlignedAdd#canCall| (Int Int) Bool)
(declare-fun |_module.__default.WordAlignedAdd#requires| (Int Int) Bool)
(declare-fun MoreFuel__module._default.WordAligned6 () T@U)
(declare-fun MoreFuel__module._default.WordAligned7 () T@U)
(declare-fun _module.__default.WordAlignedSub (Int Int) Int)
(declare-fun |_module.__default.WordAlignedSub#canCall| (Int Int) Bool)
(declare-fun |_module.__default.WordAlignedSub#requires| (Int Int) Bool)
(declare-fun MoreFuel__module._default.WordAligned8 () T@U)
(declare-fun MoreFuel__module._default.WordAligned9 () T@U)
(declare-fun Tclass._module.shift__amount () T@U)
(declare-fun Tclass._module.addr () T@U)
(declare-fun MapType4Type (T@T T@T) T@T)
(declare-fun MapType4TypeInv0 (T@T) T@T)
(declare-fun MapType4TypeInv1 (T@T) T@T)
(declare-fun MapType4Select (T@U T@U T@U) T@U)
(declare-fun MapType4Store (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#0| (T@U T@U T@U) T@U)
(declare-fun |lambda#1| (T@U T@U T@U) T@U)
(declare-fun |lambda#2| (T@U T@U T@U) T@U)
(declare-fun |lambda#3| (T@U T@U T@U) T@U)
(declare-fun |lambda#4| (T@U T@U T@U) T@U)
(declare-fun |lambda#5| (T@U T@U T@U) T@U)
(declare-fun |lambda#6| (T@U T@U T@U) T@U)
(declare-fun |lambda#7| (T@U T@U T@U) T@U)
(declare-fun |lambda#8| (T@U T@U T@U) T@U)
(declare-fun |lambda#9| (T@U T@U T@U) T@U)
(declare-fun |lambda#10| (T@U T@U T@U) T@U)
(declare-fun |lambda#11| (T@U T@U T@U) T@U)
(declare-fun |lambda#12| (T@U T@U T@U) T@U)
(declare-fun |lambda#13| (T@U T@U T@U) T@U)
(declare-fun |lambda#14| (T@U T@U T@U) T@U)
(declare-fun |lambda#15| (T@U T@U T@U) T@U)
(declare-fun |lambda#16| (T@U T@U T@U) T@U)
(declare-fun |lambda#17| (T@U T@U T@U) T@U)
(declare-fun |lambda#18| (T@U T@U T@U) T@U)
(declare-fun |lambda#19| (T@U T@U T@U) T@U)
(declare-fun |lambda#20| (T@U T@U T@U) T@U)
(declare-fun |lambda#21| (T@U T@U T@U) T@U)
(declare-fun |lambda#22| (T@U T@U T@U) T@U)
(declare-fun |lambda#23| (T@U T@U T@U) T@U)
(declare-fun |lambda#24| (T@U T@U T@U) T@U)
(declare-fun |lambda#25| (T@U T@U T@U) T@U)
(declare-fun |lambda#26| (T@U T@U T@U) T@U)
(declare-fun |lambda#27| (T@U T@U T@U) T@U)
(declare-fun |lambda#28| (T@U T@U T@U) T@U)
(declare-fun |lambda#29| (T@U T@U T@U) T@U)
(declare-fun |lambda#30| (T@U T@U T@U) T@U)
(declare-fun |lambda#31| (T@U T@U T@U) T@U)
(declare-fun |lambda#32| (T@U T@U T@U) T@U)
(declare-fun |lambda#33| (T@U T@U T@U) T@U)
(declare-fun |lambda#34| (T@U T@U T@U) T@U)
(declare-fun |lambda#35| (T@U T@U T@U) T@U)
(declare-fun |lambda#36| (T@U T@U T@U) T@U)
(declare-fun |lambda#37| (T@U T@U T@U) T@U)
(declare-fun |lambda#38| (T@U T@U T@U) T@U)
(declare-fun |lambda#39| (T@U T@U T@U) T@U)
(declare-fun |lambda#40| (T@U T@U T@U) T@U)
(declare-fun |lambda#41| (T@U T@U T@U) T@U)
(declare-fun |lambda#42| (T@U T@U T@U) T@U)
(declare-fun |lambda#43| (T@U T@U T@U) T@U)
(declare-fun |lambda#44| (T@U T@U T@U) T@U)
(declare-fun |lambda#45| (T@U T@U T@U) T@U)
(declare-fun |lambda#46| (T@U T@U T@U) T@U)
(declare-fun |lambda#47| (T@U T@U T@U) T@U)
(declare-fun |lambda#48| (T@U T@U T@U) T@U)
(declare-fun |lambda#49| (T@U T@U T@U) T@U)
(declare-fun |lambda#50| (T@U T@U T@U) T@U)
(declare-fun |lambda#51| (T@U T@U T@U) T@U)
(declare-fun |lambda#52| (T@U T@U T@U) T@U)
(declare-fun |lambda#53| (T@U T@U T@U) T@U)
(assert  (and (and (and (and (and (and (and (and (and (and (and (= (Ctor intType) 0) (= (Ctor realType) 1)) (= (Ctor boolType) 2)) (forall ((arg0 Int) ) (! (= (U_2_int (int_2_U arg0)) arg0) :qid |typeInv:U_2_int| :pattern ( (int_2_U arg0)) ))) (forall ((x T@U) ) (!  (=> (= (type x) intType) (= (int_2_U (U_2_int x)) x)) :qid |cast:U_2_int| :pattern ( (U_2_int x)) ))) (forall ((arg0@@0 Int) ) (! (= (type (int_2_U arg0@@0)) intType) :qid |funType:int_2_U| :pattern ( (int_2_U arg0@@0)) ))) (forall ((arg0@@1 Real) ) (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1) :qid |typeInv:U_2_real| :pattern ( (real_2_U arg0@@1)) ))) (forall ((x@@0 T@U) ) (!  (=> (= (type x@@0) realType) (= (real_2_U (U_2_real x@@0)) x@@0)) :qid |cast:U_2_real| :pattern ( (U_2_real x@@0)) ))) (forall ((arg0@@2 Real) ) (! (= (type (real_2_U arg0@@2)) realType) :qid |funType:real_2_U| :pattern ( (real_2_U arg0@@2)) ))) (forall ((arg0@@3 Bool) ) (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3) :qid |typeInv:U_2_bool| :pattern ( (bool_2_U arg0@@3)) ))) (forall ((x@@1 T@U) ) (!  (=> (= (type x@@1) boolType) (= (bool_2_U (U_2_bool x@@1)) x@@1)) :qid |cast:U_2_bool| :pattern ( (U_2_bool x@@1)) ))) (forall ((arg0@@4 Bool) ) (! (= (type (bool_2_U arg0@@4)) boolType) :qid |funType:bool_2_U| :pattern ( (bool_2_U arg0@@4)) ))))
(assert (forall ((x@@2 T@U) ) (! (UOrdering2 x@@2 x@@2) :qid |bg:subtype-refl| :no-pattern (U_2_int x@@2) :no-pattern (U_2_bool x@@2) )))
(assert (forall ((x@@3 T@U) (y T@U) (z T@U) ) (! (let ((alpha (type x@@3))) (=> (and (and (= (type y) alpha) (= (type z) alpha)) (and (UOrdering2 x@@3 y) (UOrdering2 y z))) (UOrdering2 x@@3 z))) :qid |bg:subtype-trans| :pattern ( (UOrdering2 x@@3 y) (UOrdering2 y z)) )))
(assert (forall ((x@@4 T@U) (y@@0 T@U) ) (! (let ((alpha@@0 (type x@@4))) (=> (= (type y@@0) alpha@@0) (=> (and (UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4)) (= x@@4 y@@0)))) :qid |bg:subtype-antisymm| :pattern ( (UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4)) )))
(assert  (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (Ctor TyType) 3) (= (type TBool) TyType)) (= (type TChar) TyType)) (= (type TInt) TyType)) (= (type TReal) TyType)) (= (Ctor TyTagType) 4)) (= (type TagBool) TyTagType)) (= (type TagChar) TyTagType)) (= (type TagInt) TyTagType)) (= (type TagReal) TyTagType)) (= (type TagSet) TyTagType)) (= (type TagISet) TyTagType)) (= (type TagMultiSet) TyTagType)) (= (type TagSeq) TyTagType)) (= (type TagMap) TyTagType)) (= (type TagIMap) TyTagType)) (= (type TagClass) TyTagType)) (= (Ctor ClassNameType) 5)) (= (type NoTraitAtAll) ClassNameType)) (= (type class._System.int) ClassNameType)) (= (type class._System.bool) ClassNameType)) (= (type class._System.set) ClassNameType)) (= (type class._System.seq) ClassNameType)) (= (type class._System.multiset) ClassNameType)) (forall ((arg0@@5 T@T) ) (! (= (Ctor (FieldType arg0@@5)) 6) :qid |ctor:FieldType| ))) (forall ((arg0@@6 T@T) ) (! (= (FieldTypeInv0 (FieldType arg0@@6)) arg0@@6) :qid |typeInv:FieldTypeInv0| :pattern ( (FieldType arg0@@6)) ))) (= (type alloc) (FieldType boolType))) (= (type Tagclass._System.nat) TyTagType)) (= (type class._System.object) ClassNameType)) (= (type Tagclass._System.object) TyTagType)) (= (type class._System.array) ClassNameType)) (= (type Tagclass._System.array) TyTagType)) (= (type Tagclass._System.___hFunc0) TyTagType)) (= (type Tagclass._System.___hFunc1) TyTagType)) (= (type Tagclass._System.___hFunc2) TyTagType)) (= (type class._System.__tuple_h2) ClassNameType)) (= (Ctor DtCtorIdType) 7)) (= (type |##_System._tuple#2._#Make2|) DtCtorIdType)) (= (type Tagclass._System.__tuple_h2) TyTagType)) (= (type class._module.__default) ClassNameType)) (= (type Tagclass._module.__default) TyTagType)) (= (type Tagclass._module.word) TyTagType)) (= (type Tagclass._module.shift__amount) TyTagType)) (= (type Tagclass._module.addr) TyTagType)))
(assert (distinct TBool TChar TInt TReal TagBool TagChar TagInt TagReal TagSet TagISet TagMultiSet TagSeq TagMap TagIMap TagClass NoTraitAtAll class._System.int class._System.bool class._System.set class._System.seq class._System.multiset alloc Tagclass._System.nat class._System.object Tagclass._System.object class._System.array Tagclass._System.array Tagclass._System.___hFunc0 Tagclass._System.___hFunc1 Tagclass._System.___hFunc2 class._System.__tuple_h2 |##_System._tuple#2._#Make2| Tagclass._System.__tuple_h2 class._module.__default Tagclass._module.__default Tagclass._module.word Tagclass._module.shift__amount Tagclass._module.addr) )
(assert $$Language$Dafny)
(assert  (and (forall ((arg0@@7 T@U) ) (! (= (type (TSet arg0@@7)) TyType) :qid |funType:TSet| :pattern ( (TSet arg0@@7)) )) (forall ((arg0@@8 T@U) ) (! (= (type (Inv0_TSet arg0@@8)) TyType) :qid |funType:Inv0_TSet| :pattern ( (Inv0_TSet arg0@@8)) ))))
(assert (forall ((t T@U) ) (!  (=> (= (type t) TyType) (= (Inv0_TSet (TSet t)) t)) :qid |DafnyPre.31:15| :skolemid |292| :pattern ( (TSet t)) )))
(assert  (and (forall ((arg0@@9 T@U) ) (! (= (type (TISet arg0@@9)) TyType) :qid |funType:TISet| :pattern ( (TISet arg0@@9)) )) (forall ((arg0@@10 T@U) ) (! (= (type (Inv0_TISet arg0@@10)) TyType) :qid |funType:Inv0_TISet| :pattern ( (Inv0_TISet arg0@@10)) ))))
(assert (forall ((t@@0 T@U) ) (!  (=> (= (type t@@0) TyType) (= (Inv0_TISet (TISet t@@0)) t@@0)) :qid |DafnyPre.33:15| :skolemid |293| :pattern ( (TISet t@@0)) )))
(assert  (and (forall ((arg0@@11 T@U) ) (! (= (type (TSeq arg0@@11)) TyType) :qid |funType:TSeq| :pattern ( (TSeq arg0@@11)) )) (forall ((arg0@@12 T@U) ) (! (= (type (Inv0_TSeq arg0@@12)) TyType) :qid |funType:Inv0_TSeq| :pattern ( (Inv0_TSeq arg0@@12)) ))))
(assert (forall ((t@@1 T@U) ) (!  (=> (= (type t@@1) TyType) (= (Inv0_TSeq (TSeq t@@1)) t@@1)) :qid |DafnyPre.35:15| :skolemid |294| :pattern ( (TSeq t@@1)) )))
(assert  (and (forall ((arg0@@13 T@U) ) (! (= (type (TMultiSet arg0@@13)) TyType) :qid |funType:TMultiSet| :pattern ( (TMultiSet arg0@@13)) )) (forall ((arg0@@14 T@U) ) (! (= (type (Inv0_TMultiSet arg0@@14)) TyType) :qid |funType:Inv0_TMultiSet| :pattern ( (Inv0_TMultiSet arg0@@14)) ))))
(assert (forall ((t@@2 T@U) ) (!  (=> (= (type t@@2) TyType) (= (Inv0_TMultiSet (TMultiSet t@@2)) t@@2)) :qid |DafnyPre.37:15| :skolemid |295| :pattern ( (TMultiSet t@@2)) )))
(assert  (and (forall ((arg0@@15 T@U) (arg1 T@U) ) (! (= (type (TMap arg0@@15 arg1)) TyType) :qid |funType:TMap| :pattern ( (TMap arg0@@15 arg1)) )) (forall ((arg0@@16 T@U) ) (! (= (type (Inv0_TMap arg0@@16)) TyType) :qid |funType:Inv0_TMap| :pattern ( (Inv0_TMap arg0@@16)) ))))
(assert (forall ((t@@3 T@U) (u T@U) ) (!  (=> (and (= (type t@@3) TyType) (= (type u) TyType)) (= (Inv0_TMap (TMap t@@3 u)) t@@3)) :qid |DafnyPre.40:15| :skolemid |296| :pattern ( (TMap t@@3 u)) )))
(assert (forall ((arg0@@17 T@U) ) (! (= (type (Inv1_TMap arg0@@17)) TyType) :qid |funType:Inv1_TMap| :pattern ( (Inv1_TMap arg0@@17)) )))
(assert (forall ((t@@4 T@U) (u@@0 T@U) ) (!  (=> (and (= (type t@@4) TyType) (= (type u@@0) TyType)) (= (Inv1_TMap (TMap t@@4 u@@0)) u@@0)) :qid |DafnyPre.41:15| :skolemid |297| :pattern ( (TMap t@@4 u@@0)) )))
(assert  (and (forall ((arg0@@18 T@U) (arg1@@0 T@U) ) (! (= (type (TIMap arg0@@18 arg1@@0)) TyType) :qid |funType:TIMap| :pattern ( (TIMap arg0@@18 arg1@@0)) )) (forall ((arg0@@19 T@U) ) (! (= (type (Inv0_TIMap arg0@@19)) TyType) :qid |funType:Inv0_TIMap| :pattern ( (Inv0_TIMap arg0@@19)) ))))
(assert (forall ((t@@5 T@U) (u@@1 T@U) ) (!  (=> (and (= (type t@@5) TyType) (= (type u@@1) TyType)) (= (Inv0_TIMap (TIMap t@@5 u@@1)) t@@5)) :qid |DafnyPre.44:15| :skolemid |298| :pattern ( (TIMap t@@5 u@@1)) )))
(assert (forall ((arg0@@20 T@U) ) (! (= (type (Inv1_TIMap arg0@@20)) TyType) :qid |funType:Inv1_TIMap| :pattern ( (Inv1_TIMap arg0@@20)) )))
(assert (forall ((t@@6 T@U) (u@@2 T@U) ) (!  (=> (and (= (type t@@6) TyType) (= (type u@@2) TyType)) (= (Inv1_TIMap (TIMap t@@6 u@@2)) u@@2)) :qid |DafnyPre.45:15| :skolemid |299| :pattern ( (TIMap t@@6 u@@2)) )))
(assert (forall ((arg0@@21 T@U) ) (! (= (type (Tag arg0@@21)) TyTagType) :qid |funType:Tag| :pattern ( (Tag arg0@@21)) )))
(assert (= (Tag TBool) TagBool))
(assert (= (Tag TChar) TagChar))
(assert (= (Tag TInt) TagInt))
(assert (= (Tag TReal) TagReal))
(assert (forall ((t@@7 T@U) ) (!  (=> (= (type t@@7) TyType) (= (Tag (TSet t@@7)) TagSet)) :qid |DafnyPre.69:15| :skolemid |300| :pattern ( (TSet t@@7)) )))
(assert (forall ((t@@8 T@U) ) (!  (=> (= (type t@@8) TyType) (= (Tag (TISet t@@8)) TagISet)) :qid |DafnyPre.70:15| :skolemid |301| :pattern ( (TISet t@@8)) )))
(assert (forall ((t@@9 T@U) ) (!  (=> (= (type t@@9) TyType) (= (Tag (TMultiSet t@@9)) TagMultiSet)) :qid |DafnyPre.71:15| :skolemid |302| :pattern ( (TMultiSet t@@9)) )))
(assert (forall ((t@@10 T@U) ) (!  (=> (= (type t@@10) TyType) (= (Tag (TSeq t@@10)) TagSeq)) :qid |DafnyPre.72:15| :skolemid |303| :pattern ( (TSeq t@@10)) )))
(assert (forall ((t@@11 T@U) (u@@3 T@U) ) (!  (=> (and (= (type t@@11) TyType) (= (type u@@3) TyType)) (= (Tag (TMap t@@11 u@@3)) TagMap)) :qid |DafnyPre.73:15| :skolemid |304| :pattern ( (TMap t@@11 u@@3)) )))
(assert (forall ((t@@12 T@U) (u@@4 T@U) ) (!  (=> (and (= (type t@@12) TyType) (= (type u@@4) TyType)) (= (Tag (TIMap t@@12 u@@4)) TagIMap)) :qid |DafnyPre.74:15| :skolemid |305| :pattern ( (TIMap t@@12 u@@4)) )))
(assert (forall ((x@@5 Int) ) (! (= (LitInt x@@5) x@@5) :qid |DafnyPre.79:29| :skolemid |306| :pattern ( (LitInt x@@5)) )))
(assert  (and (and (= (Ctor BoxType) 8) (forall ((arg0@@22 T@U) ) (! (= (type ($Box arg0@@22)) BoxType) :qid |funType:$Box| :pattern ( ($Box arg0@@22)) ))) (forall ((arg0@@23 T@U) ) (! (let ((T (type arg0@@23))) (= (type (Lit arg0@@23)) T)) :qid |funType:Lit| :pattern ( (Lit arg0@@23)) ))))
(assert (forall ((x@@6 Int) ) (! (= ($Box (int_2_U (LitInt x@@6))) (Lit ($Box (int_2_U x@@6)))) :qid |DafnyPre.80:15| :skolemid |307| :pattern ( ($Box (int_2_U (LitInt x@@6)))) )))
(assert (forall ((x@@7 Real) ) (! (= (LitReal x@@7) x@@7) :qid |DafnyPre.81:30| :skolemid |308| :pattern ( (LitReal x@@7)) )))
(assert (forall ((x@@8 Real) ) (! (= ($Box (real_2_U (LitReal x@@8))) (Lit ($Box (real_2_U x@@8)))) :qid |DafnyPre.82:15| :skolemid |309| :pattern ( ($Box (real_2_U (LitReal x@@8)))) )))
(assert (forall ((x@@9 T@U) ) (! (= (Lit x@@9) x@@9) :qid |DafnyPre.83:29| :skolemid |310| :pattern ( (Lit x@@9)) )))
(assert (forall ((x@@10 T@U) ) (! (= ($Box (Lit x@@10)) (Lit ($Box x@@10))) :qid |DafnyPre.84:18| :skolemid |311| :pattern ( ($Box (Lit x@@10))) )))
(assert  (and (= (Ctor charType) 9) (forall ((arg0@@24 Int) ) (! (= (type (|char#FromInt| arg0@@24)) charType) :qid |funType:char#FromInt| :pattern ( (|char#FromInt| arg0@@24)) ))))
(assert (forall ((ch T@U) ) (!  (=> (= (type ch) charType) (= (|char#FromInt| (|char#ToInt| ch)) ch)) :qid |DafnyPre.93:15| :skolemid |312| :pattern ( (|char#ToInt| ch)) )))
(assert (forall ((n Int) ) (!  (=> (and (<= 0 n) (< n 65536)) (= (|char#ToInt| (|char#FromInt| n)) n)) :qid |DafnyPre.96:15| :skolemid |313| :pattern ( (|char#FromInt| n)) )))
(assert (forall ((T@@0 T@T) (arg0@@25 T@U) ) (! (= (type ($Unbox T@@0 arg0@@25)) T@@0) :qid |funType:$Unbox| :pattern ( ($Unbox T@@0 arg0@@25)) )))
(assert (forall ((x@@11 T@U) ) (! (let ((T@@1 (type x@@11))) (= ($Unbox T@@1 ($Box x@@11)) x@@11)) :qid |DafnyPre.124:18| :skolemid |314| :pattern ( ($Box x@@11)) )))
(assert (forall ((bx T@U) ) (!  (=> (and (= (type bx) BoxType) ($IsBox bx TInt)) (and (= ($Box ($Unbox intType bx)) bx) ($Is ($Unbox intType bx) TInt))) :qid |DafnyPre.126:15| :skolemid |315| :pattern ( ($IsBox bx TInt)) )))
(assert (forall ((bx@@0 T@U) ) (!  (=> (and (= (type bx@@0) BoxType) ($IsBox bx@@0 TReal)) (and (= ($Box ($Unbox realType bx@@0)) bx@@0) ($Is ($Unbox realType bx@@0) TReal))) :qid |DafnyPre.129:15| :skolemid |316| :pattern ( ($IsBox bx@@0 TReal)) )))
(assert (forall ((bx@@1 T@U) ) (!  (=> (and (= (type bx@@1) BoxType) ($IsBox bx@@1 TBool)) (and (= ($Box ($Unbox boolType bx@@1)) bx@@1) ($Is ($Unbox boolType bx@@1) TBool))) :qid |DafnyPre.132:15| :skolemid |317| :pattern ( ($IsBox bx@@1 TBool)) )))
(assert (forall ((bx@@2 T@U) ) (!  (=> (and (= (type bx@@2) BoxType) ($IsBox bx@@2 TChar)) (and (= ($Box ($Unbox charType bx@@2)) bx@@2) ($Is ($Unbox charType bx@@2) TChar))) :qid |DafnyPre.135:15| :skolemid |318| :pattern ( ($IsBox bx@@2 TChar)) )))
(assert  (and (and (and (and (and (and (forall ((arg0@@26 T@T) (arg1@@1 T@T) ) (! (= (Ctor (MapType0Type arg0@@26 arg1@@1)) 10) :qid |ctor:MapType0Type| )) (forall ((arg0@@27 T@T) (arg1@@2 T@T) ) (! (= (MapType0TypeInv0 (MapType0Type arg0@@27 arg1@@2)) arg0@@27) :qid |typeInv:MapType0TypeInv0| :pattern ( (MapType0Type arg0@@27 arg1@@2)) ))) (forall ((arg0@@28 T@T) (arg1@@3 T@T) ) (! (= (MapType0TypeInv1 (MapType0Type arg0@@28 arg1@@3)) arg1@@3) :qid |typeInv:MapType0TypeInv1| :pattern ( (MapType0Type arg0@@28 arg1@@3)) ))) (forall ((arg0@@29 T@U) (arg1@@4 T@U) ) (! (let ((aVar1 (MapType0TypeInv1 (type arg0@@29)))) (= (type (MapType0Select arg0@@29 arg1@@4)) aVar1)) :qid |funType:MapType0Select| :pattern ( (MapType0Select arg0@@29 arg1@@4)) ))) (forall ((arg0@@30 T@U) (arg1@@5 T@U) (arg2 T@U) ) (! (let ((aVar1@@0 (type arg2))) (let ((aVar0 (type arg1@@5))) (= (type (MapType0Store arg0@@30 arg1@@5 arg2)) (MapType0Type aVar0 aVar1@@0)))) :qid |funType:MapType0Store| :pattern ( (MapType0Store arg0@@30 arg1@@5 arg2)) ))) (forall ((m T@U) (x0 T@U) (val T@U) ) (! (let ((aVar1@@1 (MapType0TypeInv1 (type m)))) (=> (= (type val) aVar1@@1) (= (MapType0Select (MapType0Store m x0 val) x0) val))) :qid |mapAx0:MapType0Select| :weight 0 ))) (and (forall ((val@@0 T@U) (m@@0 T@U) (x0@@0 T@U) (y0 T@U) ) (!  (or (= x0@@0 y0) (= (MapType0Select (MapType0Store m@@0 x0@@0 val@@0) y0) (MapType0Select m@@0 y0))) :qid |mapAx1:MapType0Select:0| :weight 0 )) (forall ((val@@1 T@U) (m@@1 T@U) (x0@@1 T@U) (y0@@0 T@U) ) (!  (or true (= (MapType0Select (MapType0Store m@@1 x0@@1 val@@1) y0@@0) (MapType0Select m@@1 y0@@0))) :qid |mapAx2:MapType0Select| :weight 0 )))))
(assert (forall ((bx@@3 T@U) (t@@13 T@U) ) (!  (=> (and (and (= (type bx@@3) BoxType) (= (type t@@13) TyType)) ($IsBox bx@@3 (TSet t@@13))) (and (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@3)) bx@@3) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@3) (TSet t@@13)))) :qid |DafnyPre.138:15| :skolemid |319| :pattern ( ($IsBox bx@@3 (TSet t@@13))) )))
(assert (forall ((bx@@4 T@U) (t@@14 T@U) ) (!  (=> (and (and (= (type bx@@4) BoxType) (= (type t@@14) TyType)) ($IsBox bx@@4 (TISet t@@14))) (and (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@4)) bx@@4) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@4) (TISet t@@14)))) :qid |DafnyPre.141:15| :skolemid |320| :pattern ( ($IsBox bx@@4 (TISet t@@14))) )))
(assert (forall ((bx@@5 T@U) (t@@15 T@U) ) (!  (=> (and (and (= (type bx@@5) BoxType) (= (type t@@15) TyType)) ($IsBox bx@@5 (TMultiSet t@@15))) (and (= ($Box ($Unbox (MapType0Type BoxType intType) bx@@5)) bx@@5) ($Is ($Unbox (MapType0Type BoxType intType) bx@@5) (TMultiSet t@@15)))) :qid |DafnyPre.144:15| :skolemid |321| :pattern ( ($IsBox bx@@5 (TMultiSet t@@15))) )))
(assert  (and (forall ((arg0@@31 T@T) ) (! (= (Ctor (SeqType arg0@@31)) 11) :qid |ctor:SeqType| )) (forall ((arg0@@32 T@T) ) (! (= (SeqTypeInv0 (SeqType arg0@@32)) arg0@@32) :qid |typeInv:SeqTypeInv0| :pattern ( (SeqType arg0@@32)) ))))
(assert (forall ((bx@@6 T@U) (t@@16 T@U) ) (!  (=> (and (and (= (type bx@@6) BoxType) (= (type t@@16) TyType)) ($IsBox bx@@6 (TSeq t@@16))) (and (= ($Box ($Unbox (SeqType BoxType) bx@@6)) bx@@6) ($Is ($Unbox (SeqType BoxType) bx@@6) (TSeq t@@16)))) :qid |DafnyPre.147:15| :skolemid |322| :pattern ( ($IsBox bx@@6 (TSeq t@@16))) )))
(assert  (and (and (forall ((arg0@@33 T@T) (arg1@@6 T@T) ) (! (= (Ctor (MapType arg0@@33 arg1@@6)) 12) :qid |ctor:MapType| )) (forall ((arg0@@34 T@T) (arg1@@7 T@T) ) (! (= (MapTypeInv0 (MapType arg0@@34 arg1@@7)) arg0@@34) :qid |typeInv:MapTypeInv0| :pattern ( (MapType arg0@@34 arg1@@7)) ))) (forall ((arg0@@35 T@T) (arg1@@8 T@T) ) (! (= (MapTypeInv1 (MapType arg0@@35 arg1@@8)) arg1@@8) :qid |typeInv:MapTypeInv1| :pattern ( (MapType arg0@@35 arg1@@8)) ))))
(assert (forall ((bx@@7 T@U) (s T@U) (t@@17 T@U) ) (!  (=> (and (and (and (= (type bx@@7) BoxType) (= (type s) TyType)) (= (type t@@17) TyType)) ($IsBox bx@@7 (TMap s t@@17))) (and (= ($Box ($Unbox (MapType BoxType BoxType) bx@@7)) bx@@7) ($Is ($Unbox (MapType BoxType BoxType) bx@@7) (TMap s t@@17)))) :qid |DafnyPre.150:15| :skolemid |323| :pattern ( ($IsBox bx@@7 (TMap s t@@17))) )))
(assert  (and (and (forall ((arg0@@36 T@T) (arg1@@9 T@T) ) (! (= (Ctor (IMapType arg0@@36 arg1@@9)) 13) :qid |ctor:IMapType| )) (forall ((arg0@@37 T@T) (arg1@@10 T@T) ) (! (= (IMapTypeInv0 (IMapType arg0@@37 arg1@@10)) arg0@@37) :qid |typeInv:IMapTypeInv0| :pattern ( (IMapType arg0@@37 arg1@@10)) ))) (forall ((arg0@@38 T@T) (arg1@@11 T@T) ) (! (= (IMapTypeInv1 (IMapType arg0@@38 arg1@@11)) arg1@@11) :qid |typeInv:IMapTypeInv1| :pattern ( (IMapType arg0@@38 arg1@@11)) ))))
(assert (forall ((bx@@8 T@U) (s@@0 T@U) (t@@18 T@U) ) (!  (=> (and (and (and (= (type bx@@8) BoxType) (= (type s@@0) TyType)) (= (type t@@18) TyType)) ($IsBox bx@@8 (TIMap s@@0 t@@18))) (and (= ($Box ($Unbox (IMapType BoxType BoxType) bx@@8)) bx@@8) ($Is ($Unbox (IMapType BoxType BoxType) bx@@8) (TIMap s@@0 t@@18)))) :qid |DafnyPre.153:15| :skolemid |324| :pattern ( ($IsBox bx@@8 (TIMap s@@0 t@@18))) )))
(assert (forall ((v T@U) (t@@19 T@U) ) (!  (=> (= (type t@@19) TyType) (and (=> ($IsBox ($Box v) t@@19) ($Is v t@@19)) (=> ($Is v t@@19) ($IsBox ($Box v) t@@19)))) :qid |DafnyPre.157:18| :skolemid |325| :pattern ( ($IsBox ($Box v) t@@19)) )))
(assert  (and (and (and (and (and (and (forall ((arg0@@39 T@T) ) (! (= (Ctor (MapType1Type arg0@@39)) 14) :qid |ctor:MapType1Type| )) (forall ((arg0@@40 T@T) ) (! (= (MapType1TypeInv0 (MapType1Type arg0@@40)) arg0@@40) :qid |typeInv:MapType1TypeInv0| :pattern ( (MapType1Type arg0@@40)) ))) (forall ((arg0@@41 T@U) (arg1@@12 T@U) (arg2@@0 T@U) ) (! (let ((alpha@@1 (FieldTypeInv0 (type arg2@@0)))) (= (type (MapType1Select arg0@@41 arg1@@12 arg2@@0)) alpha@@1)) :qid |funType:MapType1Select| :pattern ( (MapType1Select arg0@@41 arg1@@12 arg2@@0)) ))) (forall ((arg0@@42 T@U) (arg1@@13 T@U) (arg2@@1 T@U) (arg3 T@U) ) (! (let ((aVar0@@0 (type arg1@@13))) (= (type (MapType1Store arg0@@42 arg1@@13 arg2@@1 arg3)) (MapType1Type aVar0@@0))) :qid |funType:MapType1Store| :pattern ( (MapType1Store arg0@@42 arg1@@13 arg2@@1 arg3)) ))) (forall ((m@@2 T@U) (x0@@2 T@U) (x1 T@U) (val@@2 T@U) ) (! (let ((alpha@@2 (FieldTypeInv0 (type x1)))) (=> (= (type val@@2) alpha@@2) (= (MapType1Select (MapType1Store m@@2 x0@@2 x1 val@@2) x0@@2 x1) val@@2))) :qid |mapAx0:MapType1Select| :weight 0 ))) (and (and (forall ((val@@3 T@U) (m@@3 T@U) (x0@@3 T@U) (x1@@0 T@U) (y0@@1 T@U) (y1 T@U) ) (!  (or (= x0@@3 y0@@1) (= (MapType1Select (MapType1Store m@@3 x0@@3 x1@@0 val@@3) y0@@1 y1) (MapType1Select m@@3 y0@@1 y1))) :qid |mapAx1:MapType1Select:0| :weight 0 )) (forall ((val@@4 T@U) (m@@4 T@U) (x0@@4 T@U) (x1@@1 T@U) (y0@@2 T@U) (y1@@0 T@U) ) (!  (or (= x1@@1 y1@@0) (= (MapType1Select (MapType1Store m@@4 x0@@4 x1@@1 val@@4) y0@@2 y1@@0) (MapType1Select m@@4 y0@@2 y1@@0))) :qid |mapAx1:MapType1Select:1| :weight 0 ))) (forall ((val@@5 T@U) (m@@5 T@U) (x0@@5 T@U) (x1@@2 T@U) (y0@@3 T@U) (y1@@1 T@U) ) (!  (or true (= (MapType1Select (MapType1Store m@@5 x0@@5 x1@@2 val@@5) y0@@3 y1@@1) (MapType1Select m@@5 y0@@3 y1@@1))) :qid |mapAx2:MapType1Select| :weight 0 )))) (= (Ctor refType) 15)))
(assert (forall ((v@@0 T@U) (t@@20 T@U) (h T@U) ) (!  (=> (and (= (type t@@20) TyType) (= (type h) (MapType1Type refType))) (and (=> ($IsAllocBox ($Box v@@0) t@@20 h) ($IsAlloc v@@0 t@@20 h)) (=> ($IsAlloc v@@0 t@@20 h) ($IsAllocBox ($Box v@@0) t@@20 h)))) :qid |DafnyPre.160:18| :skolemid |326| :pattern ( ($IsAllocBox ($Box v@@0) t@@20 h)) )))
(assert (forall ((v@@1 T@U) ) (!  (=> (= (type v@@1) intType) ($Is v@@1 TInt)) :qid |DafnyPre.178:14| :skolemid |327| :pattern ( ($Is v@@1 TInt)) )))
(assert (forall ((v@@2 T@U) ) (!  (=> (= (type v@@2) realType) ($Is v@@2 TReal)) :qid |DafnyPre.179:14| :skolemid |328| :pattern ( ($Is v@@2 TReal)) )))
(assert (forall ((v@@3 T@U) ) (!  (=> (= (type v@@3) boolType) ($Is v@@3 TBool)) :qid |DafnyPre.180:14| :skolemid |329| :pattern ( ($Is v@@3 TBool)) )))
(assert (forall ((v@@4 T@U) ) (!  (=> (= (type v@@4) charType) ($Is v@@4 TChar)) :qid |DafnyPre.181:14| :skolemid |330| :pattern ( ($Is v@@4 TChar)) )))
(assert (forall ((h@@0 T@U) (v@@5 T@U) ) (!  (=> (and (= (type h@@0) (MapType1Type refType)) (= (type v@@5) intType)) ($IsAlloc v@@5 TInt h@@0)) :qid |DafnyPre.183:14| :skolemid |331| :pattern ( ($IsAlloc v@@5 TInt h@@0)) )))
(assert (forall ((h@@1 T@U) (v@@6 T@U) ) (!  (=> (and (= (type h@@1) (MapType1Type refType)) (= (type v@@6) realType)) ($IsAlloc v@@6 TReal h@@1)) :qid |DafnyPre.184:14| :skolemid |332| :pattern ( ($IsAlloc v@@6 TReal h@@1)) )))
(assert (forall ((h@@2 T@U) (v@@7 T@U) ) (!  (=> (and (= (type h@@2) (MapType1Type refType)) (= (type v@@7) boolType)) ($IsAlloc v@@7 TBool h@@2)) :qid |DafnyPre.185:14| :skolemid |333| :pattern ( ($IsAlloc v@@7 TBool h@@2)) )))
(assert (forall ((h@@3 T@U) (v@@8 T@U) ) (!  (=> (and (= (type h@@3) (MapType1Type refType)) (= (type v@@8) charType)) ($IsAlloc v@@8 TChar h@@3)) :qid |DafnyPre.186:14| :skolemid |334| :pattern ( ($IsAlloc v@@8 TChar h@@3)) )))
(assert (forall ((v@@9 T@U) (t0 T@U) ) (!  (=> (and (= (type v@@9) (MapType0Type BoxType boolType)) (= (type t0) TyType)) (and (=> ($Is v@@9 (TSet t0)) (forall ((bx@@9 T@U) ) (!  (=> (and (= (type bx@@9) BoxType) (U_2_bool (MapType0Select v@@9 bx@@9))) ($IsBox bx@@9 t0)) :qid |DafnyPre.190:11| :skolemid |335| :pattern ( (MapType0Select v@@9 bx@@9)) ))) (=> (forall ((bx@@10 T@U) ) (!  (=> (and (= (type bx@@10) BoxType) (U_2_bool (MapType0Select v@@9 bx@@10))) ($IsBox bx@@10 t0)) :qid |DafnyPre.190:11| :skolemid |335| :pattern ( (MapType0Select v@@9 bx@@10)) )) ($Is v@@9 (TSet t0))))) :qid |DafnyPre.188:15| :skolemid |336| :pattern ( ($Is v@@9 (TSet t0))) )))
(assert (forall ((v@@10 T@U) (t0@@0 T@U) ) (!  (=> (and (= (type v@@10) (MapType0Type BoxType boolType)) (= (type t0@@0) TyType)) (and (=> ($Is v@@10 (TISet t0@@0)) (forall ((bx@@11 T@U) ) (!  (=> (and (= (type bx@@11) BoxType) (U_2_bool (MapType0Select v@@10 bx@@11))) ($IsBox bx@@11 t0@@0)) :qid |DafnyPre.194:11| :skolemid |337| :pattern ( (MapType0Select v@@10 bx@@11)) ))) (=> (forall ((bx@@12 T@U) ) (!  (=> (and (= (type bx@@12) BoxType) (U_2_bool (MapType0Select v@@10 bx@@12))) ($IsBox bx@@12 t0@@0)) :qid |DafnyPre.194:11| :skolemid |337| :pattern ( (MapType0Select v@@10 bx@@12)) )) ($Is v@@10 (TISet t0@@0))))) :qid |DafnyPre.192:15| :skolemid |338| :pattern ( ($Is v@@10 (TISet t0@@0))) )))
(assert (forall ((v@@11 T@U) (t0@@1 T@U) ) (!  (=> (and (= (type v@@11) (MapType0Type BoxType intType)) (= (type t0@@1) TyType)) (and (=> ($Is v@@11 (TMultiSet t0@@1)) (forall ((bx@@13 T@U) ) (!  (=> (and (= (type bx@@13) BoxType) (< 0 (U_2_int (MapType0Select v@@11 bx@@13)))) ($IsBox bx@@13 t0@@1)) :qid |DafnyPre.198:11| :skolemid |339| :pattern ( (MapType0Select v@@11 bx@@13)) ))) (=> (forall ((bx@@14 T@U) ) (!  (=> (and (= (type bx@@14) BoxType) (< 0 (U_2_int (MapType0Select v@@11 bx@@14)))) ($IsBox bx@@14 t0@@1)) :qid |DafnyPre.198:11| :skolemid |339| :pattern ( (MapType0Select v@@11 bx@@14)) )) ($Is v@@11 (TMultiSet t0@@1))))) :qid |DafnyPre.196:15| :skolemid |340| :pattern ( ($Is v@@11 (TMultiSet t0@@1))) )))
(assert (forall ((v@@12 T@U) (t0@@2 T@U) ) (!  (=> (and (and (= (type v@@12) (MapType0Type BoxType intType)) (= (type t0@@2) TyType)) ($Is v@@12 (TMultiSet t0@@2))) ($IsGoodMultiSet v@@12)) :qid |DafnyPre.200:15| :skolemid |341| :pattern ( ($Is v@@12 (TMultiSet t0@@2))) )))
(assert (forall ((arg0@@43 T@U) (arg1@@14 Int) ) (! (let ((T@@2 (SeqTypeInv0 (type arg0@@43)))) (= (type (|Seq#Index| arg0@@43 arg1@@14)) T@@2)) :qid |funType:Seq#Index| :pattern ( (|Seq#Index| arg0@@43 arg1@@14)) )))
(assert (forall ((v@@13 T@U) (t0@@3 T@U) ) (!  (=> (and (= (type v@@13) (SeqType BoxType)) (= (type t0@@3) TyType)) (and (=> ($Is v@@13 (TSeq t0@@3)) (forall ((i Int) ) (!  (=> (and (<= 0 i) (< i (|Seq#Length| v@@13))) ($IsBox (|Seq#Index| v@@13 i) t0@@3)) :qid |DafnyPre.204:11| :skolemid |342| :pattern ( (|Seq#Index| v@@13 i)) ))) (=> (forall ((i@@0 Int) ) (!  (=> (and (<= 0 i@@0) (< i@@0 (|Seq#Length| v@@13))) ($IsBox (|Seq#Index| v@@13 i@@0) t0@@3)) :qid |DafnyPre.204:11| :skolemid |342| :pattern ( (|Seq#Index| v@@13 i@@0)) )) ($Is v@@13 (TSeq t0@@3))))) :qid |DafnyPre.202:15| :skolemid |343| :pattern ( ($Is v@@13 (TSeq t0@@3))) )))
(assert (forall ((v@@14 T@U) (t0@@4 T@U) (h@@4 T@U) ) (!  (=> (and (and (= (type v@@14) (MapType0Type BoxType boolType)) (= (type t0@@4) TyType)) (= (type h@@4) (MapType1Type refType))) (and (=> ($IsAlloc v@@14 (TSet t0@@4) h@@4) (forall ((bx@@15 T@U) ) (!  (=> (and (= (type bx@@15) BoxType) (U_2_bool (MapType0Select v@@14 bx@@15))) ($IsAllocBox bx@@15 t0@@4 h@@4)) :qid |DafnyPre.209:11| :skolemid |344| :pattern ( (MapType0Select v@@14 bx@@15)) ))) (=> (forall ((bx@@16 T@U) ) (!  (=> (and (= (type bx@@16) BoxType) (U_2_bool (MapType0Select v@@14 bx@@16))) ($IsAllocBox bx@@16 t0@@4 h@@4)) :qid |DafnyPre.209:11| :skolemid |344| :pattern ( (MapType0Select v@@14 bx@@16)) )) ($IsAlloc v@@14 (TSet t0@@4) h@@4)))) :qid |DafnyPre.207:15| :skolemid |345| :pattern ( ($IsAlloc v@@14 (TSet t0@@4) h@@4)) )))
(assert (forall ((v@@15 T@U) (t0@@5 T@U) (h@@5 T@U) ) (!  (=> (and (and (= (type v@@15) (MapType0Type BoxType boolType)) (= (type t0@@5) TyType)) (= (type h@@5) (MapType1Type refType))) (and (=> ($IsAlloc v@@15 (TISet t0@@5) h@@5) (forall ((bx@@17 T@U) ) (!  (=> (and (= (type bx@@17) BoxType) (U_2_bool (MapType0Select v@@15 bx@@17))) ($IsAllocBox bx@@17 t0@@5 h@@5)) :qid |DafnyPre.213:11| :skolemid |346| :pattern ( (MapType0Select v@@15 bx@@17)) ))) (=> (forall ((bx@@18 T@U) ) (!  (=> (and (= (type bx@@18) BoxType) (U_2_bool (MapType0Select v@@15 bx@@18))) ($IsAllocBox bx@@18 t0@@5 h@@5)) :qid |DafnyPre.213:11| :skolemid |346| :pattern ( (MapType0Select v@@15 bx@@18)) )) ($IsAlloc v@@15 (TISet t0@@5) h@@5)))) :qid |DafnyPre.211:15| :skolemid |347| :pattern ( ($IsAlloc v@@15 (TISet t0@@5) h@@5)) )))
(assert (forall ((v@@16 T@U) (t0@@6 T@U) (h@@6 T@U) ) (!  (=> (and (and (= (type v@@16) (MapType0Type BoxType intType)) (= (type t0@@6) TyType)) (= (type h@@6) (MapType1Type refType))) (and (=> ($IsAlloc v@@16 (TMultiSet t0@@6) h@@6) (forall ((bx@@19 T@U) ) (!  (=> (and (= (type bx@@19) BoxType) (< 0 (U_2_int (MapType0Select v@@16 bx@@19)))) ($IsAllocBox bx@@19 t0@@6 h@@6)) :qid |DafnyPre.217:11| :skolemid |348| :pattern ( (MapType0Select v@@16 bx@@19)) ))) (=> (forall ((bx@@20 T@U) ) (!  (=> (and (= (type bx@@20) BoxType) (< 0 (U_2_int (MapType0Select v@@16 bx@@20)))) ($IsAllocBox bx@@20 t0@@6 h@@6)) :qid |DafnyPre.217:11| :skolemid |348| :pattern ( (MapType0Select v@@16 bx@@20)) )) ($IsAlloc v@@16 (TMultiSet t0@@6) h@@6)))) :qid |DafnyPre.215:15| :skolemid |349| :pattern ( ($IsAlloc v@@16 (TMultiSet t0@@6) h@@6)) )))
(assert (forall ((v@@17 T@U) (t0@@7 T@U) (h@@7 T@U) ) (!  (=> (and (and (= (type v@@17) (SeqType BoxType)) (= (type t0@@7) TyType)) (= (type h@@7) (MapType1Type refType))) (and (=> ($IsAlloc v@@17 (TSeq t0@@7) h@@7) (forall ((i@@1 Int) ) (!  (=> (and (<= 0 i@@1) (< i@@1 (|Seq#Length| v@@17))) ($IsAllocBox (|Seq#Index| v@@17 i@@1) t0@@7 h@@7)) :qid |DafnyPre.221:11| :skolemid |350| :pattern ( (|Seq#Index| v@@17 i@@1)) ))) (=> (forall ((i@@2 Int) ) (!  (=> (and (<= 0 i@@2) (< i@@2 (|Seq#Length| v@@17))) ($IsAllocBox (|Seq#Index| v@@17 i@@2) t0@@7 h@@7)) :qid |DafnyPre.221:11| :skolemid |350| :pattern ( (|Seq#Index| v@@17 i@@2)) )) ($IsAlloc v@@17 (TSeq t0@@7) h@@7)))) :qid |DafnyPre.219:15| :skolemid |351| :pattern ( ($IsAlloc v@@17 (TSeq t0@@7) h@@7)) )))
(assert  (and (forall ((arg0@@44 T@U) ) (! (let ((V (MapTypeInv1 (type arg0@@44)))) (let ((U (MapTypeInv0 (type arg0@@44)))) (= (type (|Map#Elements| arg0@@44)) (MapType0Type U V)))) :qid |funType:Map#Elements| :pattern ( (|Map#Elements| arg0@@44)) )) (forall ((arg0@@45 T@U) ) (! (let ((U@@0 (MapTypeInv0 (type arg0@@45)))) (= (type (|Map#Domain| arg0@@45)) (MapType0Type U@@0 boolType))) :qid |funType:Map#Domain| :pattern ( (|Map#Domain| arg0@@45)) ))))
(assert (forall ((v@@18 T@U) (t0@@8 T@U) (t1 T@U) ) (!  (=> (and (and (= (type v@@18) (MapType BoxType BoxType)) (= (type t0@@8) TyType)) (= (type t1) TyType)) (and (=> ($Is v@@18 (TMap t0@@8 t1)) (forall ((bx@@21 T@U) ) (!  (=> (and (= (type bx@@21) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@18) bx@@21))) (and ($IsBox (MapType0Select (|Map#Elements| v@@18) bx@@21) t1) ($IsBox bx@@21 t0@@8))) :qid |DafnyPre.228:19| :skolemid |352| :pattern ( (MapType0Select (|Map#Elements| v@@18) bx@@21)) :pattern ( (MapType0Select (|Map#Domain| v@@18) bx@@21)) ))) (=> (forall ((bx@@22 T@U) ) (!  (=> (and (= (type bx@@22) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@18) bx@@22))) (and ($IsBox (MapType0Select (|Map#Elements| v@@18) bx@@22) t1) ($IsBox bx@@22 t0@@8))) :qid |DafnyPre.228:19| :skolemid |352| :pattern ( (MapType0Select (|Map#Elements| v@@18) bx@@22)) :pattern ( (MapType0Select (|Map#Domain| v@@18) bx@@22)) )) ($Is v@@18 (TMap t0@@8 t1))))) :qid |DafnyPre.225:15| :skolemid |353| :pattern ( ($Is v@@18 (TMap t0@@8 t1))) )))
(assert (forall ((v@@19 T@U) (t0@@9 T@U) (t1@@0 T@U) (h@@8 T@U) ) (!  (=> (and (and (and (= (type v@@19) (MapType BoxType BoxType)) (= (type t0@@9) TyType)) (= (type t1@@0) TyType)) (= (type h@@8) (MapType1Type refType))) (and (=> ($IsAlloc v@@19 (TMap t0@@9 t1@@0) h@@8) (forall ((bx@@23 T@U) ) (!  (=> (and (= (type bx@@23) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@19) bx@@23))) (and ($IsAllocBox (MapType0Select (|Map#Elements| v@@19) bx@@23) t1@@0 h@@8) ($IsAllocBox bx@@23 t0@@9 h@@8))) :qid |DafnyPre.236:19| :skolemid |354| :pattern ( (MapType0Select (|Map#Elements| v@@19) bx@@23)) :pattern ( (MapType0Select (|Map#Domain| v@@19) bx@@23)) ))) (=> (forall ((bx@@24 T@U) ) (!  (=> (and (= (type bx@@24) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@19) bx@@24))) (and ($IsAllocBox (MapType0Select (|Map#Elements| v@@19) bx@@24) t1@@0 h@@8) ($IsAllocBox bx@@24 t0@@9 h@@8))) :qid |DafnyPre.236:19| :skolemid |354| :pattern ( (MapType0Select (|Map#Elements| v@@19) bx@@24)) :pattern ( (MapType0Select (|Map#Domain| v@@19) bx@@24)) )) ($IsAlloc v@@19 (TMap t0@@9 t1@@0) h@@8)))) :qid |DafnyPre.233:15| :skolemid |355| :pattern ( ($IsAlloc v@@19 (TMap t0@@9 t1@@0) h@@8)) )))
(assert  (and (forall ((arg0@@46 T@U) ) (! (let ((V@@0 (IMapTypeInv1 (type arg0@@46)))) (let ((U@@1 (IMapTypeInv0 (type arg0@@46)))) (= (type (|IMap#Elements| arg0@@46)) (MapType0Type U@@1 V@@0)))) :qid |funType:IMap#Elements| :pattern ( (|IMap#Elements| arg0@@46)) )) (forall ((arg0@@47 T@U) ) (! (let ((U@@2 (IMapTypeInv0 (type arg0@@47)))) (= (type (|IMap#Domain| arg0@@47)) (MapType0Type U@@2 boolType))) :qid |funType:IMap#Domain| :pattern ( (|IMap#Domain| arg0@@47)) ))))
(assert (forall ((v@@20 T@U) (t0@@10 T@U) (t1@@1 T@U) ) (!  (=> (and (and (= (type v@@20) (IMapType BoxType BoxType)) (= (type t0@@10) TyType)) (= (type t1@@1) TyType)) (and (=> ($Is v@@20 (TIMap t0@@10 t1@@1)) (forall ((bx@@25 T@U) ) (!  (=> (and (= (type bx@@25) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@20) bx@@25))) (and ($IsBox (MapType0Select (|IMap#Elements| v@@20) bx@@25) t1@@1) ($IsBox bx@@25 t0@@10))) :qid |DafnyPre.245:19| :skolemid |356| :pattern ( (MapType0Select (|IMap#Elements| v@@20) bx@@25)) :pattern ( (MapType0Select (|IMap#Domain| v@@20) bx@@25)) ))) (=> (forall ((bx@@26 T@U) ) (!  (=> (and (= (type bx@@26) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@20) bx@@26))) (and ($IsBox (MapType0Select (|IMap#Elements| v@@20) bx@@26) t1@@1) ($IsBox bx@@26 t0@@10))) :qid |DafnyPre.245:19| :skolemid |356| :pattern ( (MapType0Select (|IMap#Elements| v@@20) bx@@26)) :pattern ( (MapType0Select (|IMap#Domain| v@@20) bx@@26)) )) ($Is v@@20 (TIMap t0@@10 t1@@1))))) :qid |DafnyPre.242:15| :skolemid |357| :pattern ( ($Is v@@20 (TIMap t0@@10 t1@@1))) )))
(assert (forall ((v@@21 T@U) (t0@@11 T@U) (t1@@2 T@U) (h@@9 T@U) ) (!  (=> (and (and (and (= (type v@@21) (IMapType BoxType BoxType)) (= (type t0@@11) TyType)) (= (type t1@@2) TyType)) (= (type h@@9) (MapType1Type refType))) (and (=> ($IsAlloc v@@21 (TIMap t0@@11 t1@@2) h@@9) (forall ((bx@@27 T@U) ) (!  (=> (and (= (type bx@@27) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@21) bx@@27))) (and ($IsAllocBox (MapType0Select (|IMap#Elements| v@@21) bx@@27) t1@@2 h@@9) ($IsAllocBox bx@@27 t0@@11 h@@9))) :qid |DafnyPre.253:19| :skolemid |358| :pattern ( (MapType0Select (|IMap#Elements| v@@21) bx@@27)) :pattern ( (MapType0Select (|IMap#Domain| v@@21) bx@@27)) ))) (=> (forall ((bx@@28 T@U) ) (!  (=> (and (= (type bx@@28) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@21) bx@@28))) (and ($IsAllocBox (MapType0Select (|IMap#Elements| v@@21) bx@@28) t1@@2 h@@9) ($IsAllocBox bx@@28 t0@@11 h@@9))) :qid |DafnyPre.253:19| :skolemid |358| :pattern ( (MapType0Select (|IMap#Elements| v@@21) bx@@28)) :pattern ( (MapType0Select (|IMap#Domain| v@@21) bx@@28)) )) ($IsAlloc v@@21 (TIMap t0@@11 t1@@2) h@@9)))) :qid |DafnyPre.250:15| :skolemid |359| :pattern ( ($IsAlloc v@@21 (TIMap t0@@11 t1@@2) h@@9)) )))
(assert  (and (and (forall ((arg0@@48 T@U) (arg1@@15 T@U) ) (! (= (type (TypeTuple arg0@@48 arg1@@15)) ClassNameType) :qid |funType:TypeTuple| :pattern ( (TypeTuple arg0@@48 arg1@@15)) )) (forall ((arg0@@49 T@U) ) (! (= (type (TypeTupleCar arg0@@49)) ClassNameType) :qid |funType:TypeTupleCar| :pattern ( (TypeTupleCar arg0@@49)) ))) (forall ((arg0@@50 T@U) ) (! (= (type (TypeTupleCdr arg0@@50)) ClassNameType) :qid |funType:TypeTupleCdr| :pattern ( (TypeTupleCdr arg0@@50)) ))))
(assert (forall ((a T@U) (b T@U) ) (!  (=> (and (= (type a) ClassNameType) (= (type b) ClassNameType)) (and (= (TypeTupleCar (TypeTuple a b)) a) (= (TypeTupleCdr (TypeTuple a b)) b))) :qid |DafnyPre.278:15| :skolemid |360| :pattern ( (TypeTuple a b)) )))
(assert (forall ((arg0@@51 T@U) ) (! (= (type (SetRef_to_SetBox arg0@@51)) (MapType0Type BoxType boolType)) :qid |funType:SetRef_to_SetBox| :pattern ( (SetRef_to_SetBox arg0@@51)) )))
(assert (forall ((s@@1 T@U) (bx@@29 T@U) ) (!  (=> (and (= (type s@@1) (MapType0Type refType boolType)) (= (type bx@@29) BoxType)) (and (=> (U_2_bool (MapType0Select (SetRef_to_SetBox s@@1) bx@@29)) (U_2_bool (MapType0Select s@@1 ($Unbox refType bx@@29)))) (=> (U_2_bool (MapType0Select s@@1 ($Unbox refType bx@@29))) (U_2_bool (MapType0Select (SetRef_to_SetBox s@@1) bx@@29))))) :qid |DafnyPre.287:15| :skolemid |361| :pattern ( (MapType0Select (SetRef_to_SetBox s@@1) bx@@29)) )))
(assert (= (type Tclass._System.object) TyType))
(assert (forall ((s@@2 T@U) ) (!  (=> (= (type s@@2) (MapType0Type refType boolType)) ($Is (SetRef_to_SetBox s@@2) (TSet Tclass._System.object))) :qid |DafnyPre.289:15| :skolemid |362| :pattern ( (SetRef_to_SetBox s@@2)) )))
(assert (= (Ctor DatatypeTypeType) 16))
(assert (forall ((d T@U) ) (!  (=> (= (type d) DatatypeTypeType) (= (BoxRank ($Box d)) (DtRank d))) :qid |DafnyPre.304:15| :skolemid |363| :pattern ( (BoxRank ($Box d))) )))
(assert  (and (= (Ctor LayerTypeType) 17) (forall ((arg0@@52 T@U) (arg1@@16 T@U) ) (! (let ((A (MapType0TypeInv1 (type arg0@@52)))) (= (type (AtLayer arg0@@52 arg1@@16)) A)) :qid |funType:AtLayer| :pattern ( (AtLayer arg0@@52 arg1@@16)) ))))
(assert (forall ((f T@U) (ly T@U) ) (! (let ((A@@0 (MapType0TypeInv1 (type f)))) (=> (and (= (type f) (MapType0Type LayerTypeType A@@0)) (= (type ly) LayerTypeType)) (= (AtLayer f ly) (MapType0Select f ly)))) :qid |DafnyPre.324:18| :skolemid |364| :pattern ( (AtLayer f ly)) )))
(assert (forall ((arg0@@53 T@U) ) (! (= (type ($LS arg0@@53)) LayerTypeType) :qid |funType:$LS| :pattern ( ($LS arg0@@53)) )))
(assert (forall ((f@@0 T@U) (ly@@0 T@U) ) (! (let ((A@@1 (MapType0TypeInv1 (type f@@0)))) (=> (and (= (type f@@0) (MapType0Type LayerTypeType A@@1)) (= (type ly@@0) LayerTypeType)) (= (AtLayer f@@0 ($LS ly@@0)) (AtLayer f@@0 ly@@0)))) :qid |DafnyPre.325:18| :skolemid |365| :pattern ( (AtLayer f@@0 ($LS ly@@0))) )))
(assert (forall ((arg0@@54 Int) ) (! (= (type (IndexField arg0@@54)) (FieldType BoxType)) :qid |funType:IndexField| :pattern ( (IndexField arg0@@54)) )))
(assert (forall ((i@@3 Int) ) (! (= (FDim (IndexField i@@3)) 1) :qid |DafnyPre.336:15| :skolemid |366| :pattern ( (IndexField i@@3)) )))
(assert (forall ((i@@4 Int) ) (! (= (IndexField_Inverse (IndexField i@@4)) i@@4) :qid |DafnyPre.338:15| :skolemid |367| :pattern ( (IndexField i@@4)) )))
(assert (forall ((arg0@@55 T@U) (arg1@@17 Int) ) (! (= (type (MultiIndexField arg0@@55 arg1@@17)) (FieldType BoxType)) :qid |funType:MultiIndexField| :pattern ( (MultiIndexField arg0@@55 arg1@@17)) )))
(assert (forall ((f@@1 T@U) (i@@5 Int) ) (!  (=> (= (type f@@1) (FieldType BoxType)) (= (FDim (MultiIndexField f@@1 i@@5)) (+ (FDim f@@1) 1))) :qid |DafnyPre.341:15| :skolemid |368| :pattern ( (MultiIndexField f@@1 i@@5)) )))
(assert (forall ((arg0@@56 T@U) ) (! (let ((T@@3 (FieldTypeInv0 (type arg0@@56)))) (= (type (MultiIndexField_Inverse0 arg0@@56)) (FieldType T@@3))) :qid |funType:MultiIndexField_Inverse0| :pattern ( (MultiIndexField_Inverse0 arg0@@56)) )))
(assert (forall ((f@@2 T@U) (i@@6 Int) ) (!  (=> (= (type f@@2) (FieldType BoxType)) (and (= (MultiIndexField_Inverse0 (MultiIndexField f@@2 i@@6)) f@@2) (= (MultiIndexField_Inverse1 (MultiIndexField f@@2 i@@6)) i@@6))) :qid |DafnyPre.344:15| :skolemid |369| :pattern ( (MultiIndexField f@@2 i@@6)) )))
(assert  (and (and (and (= (Ctor NameFamilyType) 18) (forall ((alpha@@3 T@T) (arg0@@57 T@U) (arg1@@18 T@U) ) (! (= (type (FieldOfDecl alpha@@3 arg0@@57 arg1@@18)) (FieldType alpha@@3)) :qid |funType:FieldOfDecl| :pattern ( (FieldOfDecl alpha@@3 arg0@@57 arg1@@18)) ))) (forall ((arg0@@58 T@U) ) (! (= (type (DeclType arg0@@58)) ClassNameType) :qid |funType:DeclType| :pattern ( (DeclType arg0@@58)) ))) (forall ((arg0@@59 T@U) ) (! (= (type (DeclName arg0@@59)) NameFamilyType) :qid |funType:DeclName| :pattern ( (DeclName arg0@@59)) ))))
(assert (forall ((cl T@U) (nm T@U) (T@@4 T@T) ) (!  (=> (and (= (type cl) ClassNameType) (= (type nm) NameFamilyType)) (and (= (DeclType (FieldOfDecl T@@4 cl nm)) cl) (= (DeclName (FieldOfDecl T@@4 cl nm)) nm))) :qid |DafnyPre.353:18| :skolemid |370| :pattern ( (FieldOfDecl T@@4 cl nm)) )))
(assert (forall ((h@@10 T@U) (k T@U) (v@@22 T@U) (t@@21 T@U) ) (!  (=> (and (and (and (and (= (type h@@10) (MapType1Type refType)) (= (type k) (MapType1Type refType))) (= (type t@@21) TyType)) ($HeapSucc h@@10 k)) ($IsAlloc v@@22 t@@21 h@@10)) ($IsAlloc v@@22 t@@21 k)) :qid |DafnyPre.366:17| :skolemid |371| :pattern ( ($HeapSucc h@@10 k) ($IsAlloc v@@22 t@@21 h@@10)) )))
(assert (forall ((h@@11 T@U) (k@@0 T@U) (bx@@30 T@U) (t@@22 T@U) ) (!  (=> (and (and (and (and (and (= (type h@@11) (MapType1Type refType)) (= (type k@@0) (MapType1Type refType))) (= (type bx@@30) BoxType)) (= (type t@@22) TyType)) ($HeapSucc h@@11 k@@0)) ($IsAllocBox bx@@30 t@@22 h@@11)) ($IsAllocBox bx@@30 t@@22 k@@0)) :qid |DafnyPre.369:14| :skolemid |372| :pattern ( ($HeapSucc h@@11 k@@0) ($IsAllocBox bx@@30 t@@22 h@@11)) )))
(assert (= (FDim alloc) 0))
(assert  (not ($IsGhostField alloc)))
(assert (forall ((o T@U) ) (!  (=> (= (type o) refType) (<= 0 (_System.array.Length o))) :qid |DafnyPre.383:15| :skolemid |373| :no-pattern (type o) :no-pattern (U_2_int o) :no-pattern (U_2_bool o) )))
(assert (forall ((x@@12 Real) ) (! (= (q@Int x@@12) (to_int x@@12)) :qid |DafnyPre.389:14| :skolemid |374| :pattern ( (q@Int x@@12)) )))
(assert (forall ((x@@13 Int) ) (! (= (q@Real x@@13) (to_real x@@13)) :qid |DafnyPre.390:15| :skolemid |375| :pattern ( (q@Real x@@13)) )))
(assert (forall ((i@@7 Int) ) (! (= (q@Int (q@Real i@@7)) i@@7) :qid |DafnyPre.391:15| :skolemid |376| :pattern ( (q@Int (q@Real i@@7))) )))
(assert (forall ((h@@12 T@U) (r T@U) (f@@3 T@U) (x@@14 T@U) ) (! (let ((alpha@@4 (type x@@14))) (=> (and (and (and (= (type h@@12) (MapType1Type refType)) (= (type r) refType)) (= (type f@@3) (FieldType alpha@@4))) ($IsGoodHeap (MapType1Store h@@12 r f@@3 x@@14))) ($HeapSucc h@@12 (MapType1Store h@@12 r f@@3 x@@14)))) :qid |DafnyPre.408:22| :skolemid |377| :pattern ( (MapType1Store h@@12 r f@@3 x@@14)) )))
(assert (forall ((a@@0 T@U) (b@@0 T@U) (c T@U) ) (!  (=> (and (and (and (= (type a@@0) (MapType1Type refType)) (= (type b@@0) (MapType1Type refType))) (= (type c) (MapType1Type refType))) (and ($HeapSucc a@@0 b@@0) ($HeapSucc b@@0 c))) ($HeapSucc a@@0 c)) :qid |DafnyPre.411:15| :skolemid |378| :pattern ( ($HeapSucc a@@0 b@@0) ($HeapSucc b@@0 c)) )))
(assert (forall ((h@@13 T@U) (k@@1 T@U) ) (!  (=> (and (and (= (type h@@13) (MapType1Type refType)) (= (type k@@1) (MapType1Type refType))) ($HeapSucc h@@13 k@@1)) (forall ((o@@0 T@U) ) (!  (=> (and (= (type o@@0) refType) (U_2_bool (MapType1Select h@@13 o@@0 alloc))) (U_2_bool (MapType1Select k@@1 o@@0 alloc))) :qid |DafnyPre.414:30| :skolemid |379| :pattern ( (MapType1Select k@@1 o@@0 alloc)) ))) :qid |DafnyPre.413:15| :skolemid |380| :pattern ( ($HeapSucc h@@13 k@@1)) )))
(assert (forall ((h@@14 T@U) (k@@2 T@U) ) (!  (=> (and (and (= (type h@@14) (MapType1Type refType)) (= (type k@@2) (MapType1Type refType))) ($HeapSuccGhost h@@14 k@@2)) (and ($HeapSucc h@@14 k@@2) (forall ((o@@1 T@U) (f@@4 T@U) ) (! (let ((alpha@@5 (FieldTypeInv0 (type f@@4)))) (=> (and (and (= (type o@@1) refType) (= (type f@@4) (FieldType alpha@@5))) (not ($IsGhostField f@@4))) (= (MapType1Select h@@14 o@@1 f@@4) (MapType1Select k@@2 o@@1 f@@4)))) :qid |DafnyPre.420:20| :skolemid |381| :pattern ( (MapType1Select k@@2 o@@1 f@@4)) )))) :qid |DafnyPre.417:15| :skolemid |382| :pattern ( ($HeapSuccGhost h@@14 k@@2)) )))
(assert (forall ((s@@3 T@U) ) (! (let ((T@@5 (MapType0TypeInv0 (type s@@3)))) (=> (= (type s@@3) (MapType0Type T@@5 boolType)) (<= 0 (|Set#Card| s@@3)))) :qid |DafnyPre.478:18| :skolemid |387| :pattern ( (|Set#Card| s@@3)) )))
(assert (forall ((T@@6 T@T) ) (! (= (type (|Set#Empty| T@@6)) (MapType0Type T@@6 boolType)) :qid |funType:Set#Empty| :pattern ( (|Set#Empty| T@@6)) )))
(assert (forall ((o@@2 T@U) ) (! (let ((T@@7 (type o@@2))) (not (U_2_bool (MapType0Select (|Set#Empty| T@@7) o@@2)))) :qid |DafnyPre.481:18| :skolemid |388| :pattern ( (let ((T@@7 (type o@@2))) (MapType0Select (|Set#Empty| T@@7) o@@2))) )))
(assert (forall ((s@@4 T@U) ) (! (let ((T@@8 (MapType0TypeInv0 (type s@@4)))) (=> (= (type s@@4) (MapType0Type T@@8 boolType)) (and (and (=> (= (|Set#Card| s@@4) 0) (= s@@4 (|Set#Empty| T@@8))) (=> (= s@@4 (|Set#Empty| T@@8)) (= (|Set#Card| s@@4) 0))) (=> (not (= (|Set#Card| s@@4) 0)) (exists ((x@@15 T@U) ) (!  (and (= (type x@@15) T@@8) (U_2_bool (MapType0Select s@@4 x@@15))) :qid |DafnyPre.484:33| :skolemid |389| :no-pattern (type x@@15) :no-pattern (U_2_int x@@15) :no-pattern (U_2_bool x@@15) )))))) :qid |DafnyPre.482:18| :skolemid |390| :pattern ( (|Set#Card| s@@4)) )))
(assert (forall ((arg0@@60 T@U) ) (! (let ((T@@9 (type arg0@@60))) (= (type (|Set#Singleton| arg0@@60)) (MapType0Type T@@9 boolType))) :qid |funType:Set#Singleton| :pattern ( (|Set#Singleton| arg0@@60)) )))
(assert (forall ((r@@0 T@U) ) (! (U_2_bool (MapType0Select (|Set#Singleton| r@@0) r@@0)) :qid |DafnyPre.490:18| :skolemid |391| :pattern ( (|Set#Singleton| r@@0)) )))
(assert (forall ((r@@1 T@U) (o@@3 T@U) ) (! (let ((T@@10 (type r@@1))) (=> (= (type o@@3) T@@10) (and (=> (U_2_bool (MapType0Select (|Set#Singleton| r@@1) o@@3)) (= r@@1 o@@3)) (=> (= r@@1 o@@3) (U_2_bool (MapType0Select (|Set#Singleton| r@@1) o@@3)))))) :qid |DafnyPre.491:18| :skolemid |392| :pattern ( (MapType0Select (|Set#Singleton| r@@1) o@@3)) )))
(assert (forall ((r@@2 T@U) ) (! (= (|Set#Card| (|Set#Singleton| r@@2)) 1) :qid |DafnyPre.492:18| :skolemid |393| :pattern ( (|Set#Card| (|Set#Singleton| r@@2))) )))
(assert (forall ((arg0@@61 T@U) (arg1@@19 T@U) ) (! (let ((T@@11 (type arg1@@19))) (= (type (|Set#UnionOne| arg0@@61 arg1@@19)) (MapType0Type T@@11 boolType))) :qid |funType:Set#UnionOne| :pattern ( (|Set#UnionOne| arg0@@61 arg1@@19)) )))
(assert (forall ((a@@1 T@U) (x@@16 T@U) (o@@4 T@U) ) (! (let ((T@@12 (type x@@16))) (=> (and (= (type a@@1) (MapType0Type T@@12 boolType)) (= (type o@@4) T@@12)) (and (=> (U_2_bool (MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)) (or (= o@@4 x@@16) (U_2_bool (MapType0Select a@@1 o@@4)))) (=> (or (= o@@4 x@@16) (U_2_bool (MapType0Select a@@1 o@@4))) (U_2_bool (MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)))))) :qid |DafnyPre.495:18| :skolemid |394| :pattern ( (MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)) )))
(assert (forall ((a@@2 T@U) (x@@17 T@U) ) (! (let ((T@@13 (type x@@17))) (=> (= (type a@@2) (MapType0Type T@@13 boolType)) (U_2_bool (MapType0Select (|Set#UnionOne| a@@2 x@@17) x@@17)))) :qid |DafnyPre.497:18| :skolemid |395| :pattern ( (|Set#UnionOne| a@@2 x@@17)) )))
(assert (forall ((a@@3 T@U) (x@@18 T@U) (y@@1 T@U) ) (! (let ((T@@14 (type x@@18))) (=> (and (and (= (type a@@3) (MapType0Type T@@14 boolType)) (= (type y@@1) T@@14)) (U_2_bool (MapType0Select a@@3 y@@1))) (U_2_bool (MapType0Select (|Set#UnionOne| a@@3 x@@18) y@@1)))) :qid |DafnyPre.499:18| :skolemid |396| :pattern ( (|Set#UnionOne| a@@3 x@@18) (MapType0Select a@@3 y@@1)) )))
(assert (forall ((a@@4 T@U) (x@@19 T@U) ) (! (let ((T@@15 (type x@@19))) (=> (and (= (type a@@4) (MapType0Type T@@15 boolType)) (U_2_bool (MapType0Select a@@4 x@@19))) (= (|Set#Card| (|Set#UnionOne| a@@4 x@@19)) (|Set#Card| a@@4)))) :qid |DafnyPre.501:18| :skolemid |397| :pattern ( (|Set#Card| (|Set#UnionOne| a@@4 x@@19))) )))
(assert (forall ((a@@5 T@U) (x@@20 T@U) ) (! (let ((T@@16 (type x@@20))) (=> (and (= (type a@@5) (MapType0Type T@@16 boolType)) (not (U_2_bool (MapType0Select a@@5 x@@20)))) (= (|Set#Card| (|Set#UnionOne| a@@5 x@@20)) (+ (|Set#Card| a@@5) 1)))) :qid |DafnyPre.503:18| :skolemid |398| :pattern ( (|Set#Card| (|Set#UnionOne| a@@5 x@@20))) )))
(assert (forall ((arg0@@62 T@U) (arg1@@20 T@U) ) (! (let ((T@@17 (MapType0TypeInv0 (type arg0@@62)))) (= (type (|Set#Union| arg0@@62 arg1@@20)) (MapType0Type T@@17 boolType))) :qid |funType:Set#Union| :pattern ( (|Set#Union| arg0@@62 arg1@@20)) )))
(assert (forall ((a@@6 T@U) (b@@1 T@U) (o@@5 T@U) ) (! (let ((T@@18 (type o@@5))) (=> (and (= (type a@@6) (MapType0Type T@@18 boolType)) (= (type b@@1) (MapType0Type T@@18 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Union| a@@6 b@@1) o@@5)) (or (U_2_bool (MapType0Select a@@6 o@@5)) (U_2_bool (MapType0Select b@@1 o@@5)))) (=> (or (U_2_bool (MapType0Select a@@6 o@@5)) (U_2_bool (MapType0Select b@@1 o@@5))) (U_2_bool (MapType0Select (|Set#Union| a@@6 b@@1) o@@5)))))) :qid |DafnyPre.507:18| :skolemid |399| :pattern ( (MapType0Select (|Set#Union| a@@6 b@@1) o@@5)) )))
(assert (forall ((a@@7 T@U) (b@@2 T@U) (y@@2 T@U) ) (! (let ((T@@19 (type y@@2))) (=> (and (and (= (type a@@7) (MapType0Type T@@19 boolType)) (= (type b@@2) (MapType0Type T@@19 boolType))) (U_2_bool (MapType0Select a@@7 y@@2))) (U_2_bool (MapType0Select (|Set#Union| a@@7 b@@2) y@@2)))) :qid |DafnyPre.509:18| :skolemid |400| :pattern ( (|Set#Union| a@@7 b@@2) (MapType0Select a@@7 y@@2)) )))
(assert (forall ((a@@8 T@U) (b@@3 T@U) (y@@3 T@U) ) (! (let ((T@@20 (type y@@3))) (=> (and (and (= (type a@@8) (MapType0Type T@@20 boolType)) (= (type b@@3) (MapType0Type T@@20 boolType))) (U_2_bool (MapType0Select b@@3 y@@3))) (U_2_bool (MapType0Select (|Set#Union| a@@8 b@@3) y@@3)))) :qid |DafnyPre.511:18| :skolemid |401| :pattern ( (|Set#Union| a@@8 b@@3) (MapType0Select b@@3 y@@3)) )))
(assert (forall ((arg0@@63 T@U) (arg1@@21 T@U) ) (! (let ((T@@21 (MapType0TypeInv0 (type arg0@@63)))) (= (type (|Set#Difference| arg0@@63 arg1@@21)) (MapType0Type T@@21 boolType))) :qid |funType:Set#Difference| :pattern ( (|Set#Difference| arg0@@63 arg1@@21)) )))
(assert (forall ((a@@9 T@U) (b@@4 T@U) ) (! (let ((T@@22 (MapType0TypeInv0 (type a@@9)))) (=> (and (and (= (type a@@9) (MapType0Type T@@22 boolType)) (= (type b@@4) (MapType0Type T@@22 boolType))) (|Set#Disjoint| a@@9 b@@4)) (and (= (|Set#Difference| (|Set#Union| a@@9 b@@4) a@@9) b@@4) (= (|Set#Difference| (|Set#Union| a@@9 b@@4) b@@4) a@@9)))) :qid |DafnyPre.513:18| :skolemid |402| :pattern ( (|Set#Union| a@@9 b@@4)) )))
(assert (forall ((arg0@@64 T@U) (arg1@@22 T@U) ) (! (let ((T@@23 (MapType0TypeInv0 (type arg0@@64)))) (= (type (|Set#Intersection| arg0@@64 arg1@@22)) (MapType0Type T@@23 boolType))) :qid |funType:Set#Intersection| :pattern ( (|Set#Intersection| arg0@@64 arg1@@22)) )))
(assert (forall ((a@@10 T@U) (b@@5 T@U) (o@@6 T@U) ) (! (let ((T@@24 (type o@@6))) (=> (and (= (type a@@10) (MapType0Type T@@24 boolType)) (= (type b@@5) (MapType0Type T@@24 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)) (and (U_2_bool (MapType0Select a@@10 o@@6)) (U_2_bool (MapType0Select b@@5 o@@6)))) (=> (and (U_2_bool (MapType0Select a@@10 o@@6)) (U_2_bool (MapType0Select b@@5 o@@6))) (U_2_bool (MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)))))) :qid |DafnyPre.523:18| :skolemid |403| :pattern ( (MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)) )))
(assert (forall ((a@@11 T@U) (b@@6 T@U) ) (! (let ((T@@25 (MapType0TypeInv0 (type a@@11)))) (=> (and (= (type a@@11) (MapType0Type T@@25 boolType)) (= (type b@@6) (MapType0Type T@@25 boolType))) (= (|Set#Union| (|Set#Union| a@@11 b@@6) b@@6) (|Set#Union| a@@11 b@@6)))) :qid |DafnyPre.526:18| :skolemid |404| :pattern ( (|Set#Union| (|Set#Union| a@@11 b@@6) b@@6)) )))
(assert (forall ((a@@12 T@U) (b@@7 T@U) ) (! (let ((T@@26 (MapType0TypeInv0 (type a@@12)))) (=> (and (= (type a@@12) (MapType0Type T@@26 boolType)) (= (type b@@7) (MapType0Type T@@26 boolType))) (= (|Set#Union| a@@12 (|Set#Union| a@@12 b@@7)) (|Set#Union| a@@12 b@@7)))) :qid |DafnyPre.528:18| :skolemid |405| :pattern ( (|Set#Union| a@@12 (|Set#Union| a@@12 b@@7))) )))
(assert (forall ((a@@13 T@U) (b@@8 T@U) ) (! (let ((T@@27 (MapType0TypeInv0 (type a@@13)))) (=> (and (= (type a@@13) (MapType0Type T@@27 boolType)) (= (type b@@8) (MapType0Type T@@27 boolType))) (= (|Set#Intersection| (|Set#Intersection| a@@13 b@@8) b@@8) (|Set#Intersection| a@@13 b@@8)))) :qid |DafnyPre.530:18| :skolemid |406| :pattern ( (|Set#Intersection| (|Set#Intersection| a@@13 b@@8) b@@8)) )))
(assert (forall ((a@@14 T@U) (b@@9 T@U) ) (! (let ((T@@28 (MapType0TypeInv0 (type a@@14)))) (=> (and (= (type a@@14) (MapType0Type T@@28 boolType)) (= (type b@@9) (MapType0Type T@@28 boolType))) (= (|Set#Intersection| a@@14 (|Set#Intersection| a@@14 b@@9)) (|Set#Intersection| a@@14 b@@9)))) :qid |DafnyPre.532:18| :skolemid |407| :pattern ( (|Set#Intersection| a@@14 (|Set#Intersection| a@@14 b@@9))) )))
(assert (forall ((a@@15 T@U) (b@@10 T@U) ) (! (let ((T@@29 (MapType0TypeInv0 (type a@@15)))) (=> (and (= (type a@@15) (MapType0Type T@@29 boolType)) (= (type b@@10) (MapType0Type T@@29 boolType))) (= (+ (|Set#Card| (|Set#Union| a@@15 b@@10)) (|Set#Card| (|Set#Intersection| a@@15 b@@10))) (+ (|Set#Card| a@@15) (|Set#Card| b@@10))))) :qid |DafnyPre.534:18| :skolemid |408| :pattern ( (|Set#Card| (|Set#Union| a@@15 b@@10))) :pattern ( (|Set#Card| (|Set#Intersection| a@@15 b@@10))) )))
(assert (forall ((a@@16 T@U) (b@@11 T@U) (o@@7 T@U) ) (! (let ((T@@30 (type o@@7))) (=> (and (= (type a@@16) (MapType0Type T@@30 boolType)) (= (type b@@11) (MapType0Type T@@30 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)) (and (U_2_bool (MapType0Select a@@16 o@@7)) (not (U_2_bool (MapType0Select b@@11 o@@7))))) (=> (and (U_2_bool (MapType0Select a@@16 o@@7)) (not (U_2_bool (MapType0Select b@@11 o@@7)))) (U_2_bool (MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)))))) :qid |DafnyPre.538:18| :skolemid |409| :pattern ( (MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)) )))
(assert (forall ((a@@17 T@U) (b@@12 T@U) (y@@4 T@U) ) (! (let ((T@@31 (type y@@4))) (=> (and (and (= (type a@@17) (MapType0Type T@@31 boolType)) (= (type b@@12) (MapType0Type T@@31 boolType))) (U_2_bool (MapType0Select b@@12 y@@4))) (not (U_2_bool (MapType0Select (|Set#Difference| a@@17 b@@12) y@@4))))) :qid |DafnyPre.540:18| :skolemid |410| :pattern ( (|Set#Difference| a@@17 b@@12) (MapType0Select b@@12 y@@4)) )))
(assert (forall ((a@@18 T@U) (b@@13 T@U) ) (! (let ((T@@32 (MapType0TypeInv0 (type a@@18)))) (=> (and (= (type a@@18) (MapType0Type T@@32 boolType)) (= (type b@@13) (MapType0Type T@@32 boolType))) (and (= (+ (+ (|Set#Card| (|Set#Difference| a@@18 b@@13)) (|Set#Card| (|Set#Difference| b@@13 a@@18))) (|Set#Card| (|Set#Intersection| a@@18 b@@13))) (|Set#Card| (|Set#Union| a@@18 b@@13))) (= (|Set#Card| (|Set#Difference| a@@18 b@@13)) (- (|Set#Card| a@@18) (|Set#Card| (|Set#Intersection| a@@18 b@@13))))))) :qid |DafnyPre.542:18| :skolemid |411| :pattern ( (|Set#Card| (|Set#Difference| a@@18 b@@13))) )))
(assert (forall ((a@@19 T@U) (b@@14 T@U) ) (! (let ((T@@33 (MapType0TypeInv0 (type a@@19)))) (=> (and (= (type a@@19) (MapType0Type T@@33 boolType)) (= (type b@@14) (MapType0Type T@@33 boolType))) (and (=> (|Set#Subset| a@@19 b@@14) (forall ((o@@8 T@U) ) (!  (=> (and (= (type o@@8) T@@33) (U_2_bool (MapType0Select a@@19 o@@8))) (U_2_bool (MapType0Select b@@14 o@@8))) :qid |DafnyPre.551:32| :skolemid |412| :pattern ( (MapType0Select a@@19 o@@8)) :pattern ( (MapType0Select b@@14 o@@8)) ))) (=> (forall ((o@@9 T@U) ) (!  (=> (and (= (type o@@9) T@@33) (U_2_bool (MapType0Select a@@19 o@@9))) (U_2_bool (MapType0Select b@@14 o@@9))) :qid |DafnyPre.551:32| :skolemid |412| :pattern ( (MapType0Select a@@19 o@@9)) :pattern ( (MapType0Select b@@14 o@@9)) )) (|Set#Subset| a@@19 b@@14))))) :qid |DafnyPre.550:17| :skolemid |413| :pattern ( (|Set#Subset| a@@19 b@@14)) )))
(assert (forall ((a@@20 T@U) (b@@15 T@U) ) (! (let ((T@@34 (MapType0TypeInv0 (type a@@20)))) (=> (and (= (type a@@20) (MapType0Type T@@34 boolType)) (= (type b@@15) (MapType0Type T@@34 boolType))) (and (=> (|Set#Equal| a@@20 b@@15) (forall ((o@@10 T@U) ) (!  (=> (= (type o@@10) T@@34) (and (=> (U_2_bool (MapType0Select a@@20 o@@10)) (U_2_bool (MapType0Select b@@15 o@@10))) (=> (U_2_bool (MapType0Select b@@15 o@@10)) (U_2_bool (MapType0Select a@@20 o@@10))))) :qid |DafnyPre.559:31| :skolemid |414| :pattern ( (MapType0Select a@@20 o@@10)) :pattern ( (MapType0Select b@@15 o@@10)) ))) (=> (forall ((o@@11 T@U) ) (!  (=> (= (type o@@11) T@@34) (and (=> (U_2_bool (MapType0Select a@@20 o@@11)) (U_2_bool (MapType0Select b@@15 o@@11))) (=> (U_2_bool (MapType0Select b@@15 o@@11)) (U_2_bool (MapType0Select a@@20 o@@11))))) :qid |DafnyPre.559:31| :skolemid |414| :pattern ( (MapType0Select a@@20 o@@11)) :pattern ( (MapType0Select b@@15 o@@11)) )) (|Set#Equal| a@@20 b@@15))))) :qid |DafnyPre.558:17| :skolemid |415| :pattern ( (|Set#Equal| a@@20 b@@15)) )))
(assert (forall ((a@@21 T@U) (b@@16 T@U) ) (! (let ((T@@35 (MapType0TypeInv0 (type a@@21)))) (=> (and (and (= (type a@@21) (MapType0Type T@@35 boolType)) (= (type b@@16) (MapType0Type T@@35 boolType))) (|Set#Equal| a@@21 b@@16)) (= a@@21 b@@16))) :qid |DafnyPre.560:17| :skolemid |416| :pattern ( (|Set#Equal| a@@21 b@@16)) )))
(assert (forall ((a@@22 T@U) (b@@17 T@U) ) (! (let ((T@@36 (MapType0TypeInv0 (type a@@22)))) (=> (and (= (type a@@22) (MapType0Type T@@36 boolType)) (= (type b@@17) (MapType0Type T@@36 boolType))) (and (=> (|Set#Disjoint| a@@22 b@@17) (forall ((o@@12 T@U) ) (!  (=> (= (type o@@12) T@@36) (or (not (U_2_bool (MapType0Select a@@22 o@@12))) (not (U_2_bool (MapType0Select b@@17 o@@12))))) :qid |DafnyPre.565:34| :skolemid |417| :pattern ( (MapType0Select a@@22 o@@12)) :pattern ( (MapType0Select b@@17 o@@12)) ))) (=> (forall ((o@@13 T@U) ) (!  (=> (= (type o@@13) T@@36) (or (not (U_2_bool (MapType0Select a@@22 o@@13))) (not (U_2_bool (MapType0Select b@@17 o@@13))))) :qid |DafnyPre.565:34| :skolemid |417| :pattern ( (MapType0Select a@@22 o@@13)) :pattern ( (MapType0Select b@@17 o@@13)) )) (|Set#Disjoint| a@@22 b@@17))))) :qid |DafnyPre.564:18| :skolemid |418| :pattern ( (|Set#Disjoint| a@@22 b@@17)) )))
(assert (forall ((T@@37 T@T) ) (! (= (type (|ISet#Empty| T@@37)) (MapType0Type T@@37 boolType)) :qid |funType:ISet#Empty| :pattern ( (|ISet#Empty| T@@37)) )))
(assert (forall ((o@@14 T@U) ) (! (let ((T@@38 (type o@@14))) (not (U_2_bool (MapType0Select (|ISet#Empty| T@@38) o@@14)))) :qid |DafnyPre.574:18| :skolemid |419| :pattern ( (let ((T@@38 (type o@@14))) (MapType0Select (|ISet#Empty| T@@38) o@@14))) )))
(assert (forall ((arg0@@65 T@U) (arg1@@23 T@U) ) (! (let ((T@@39 (type arg1@@23))) (= (type (|ISet#UnionOne| arg0@@65 arg1@@23)) (MapType0Type T@@39 boolType))) :qid |funType:ISet#UnionOne| :pattern ( (|ISet#UnionOne| arg0@@65 arg1@@23)) )))
(assert (forall ((a@@23 T@U) (x@@21 T@U) (o@@15 T@U) ) (! (let ((T@@40 (type x@@21))) (=> (and (= (type a@@23) (MapType0Type T@@40 boolType)) (= (type o@@15) T@@40)) (and (=> (U_2_bool (MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)) (or (= o@@15 x@@21) (U_2_bool (MapType0Select a@@23 o@@15)))) (=> (or (= o@@15 x@@21) (U_2_bool (MapType0Select a@@23 o@@15))) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)))))) :qid |DafnyPre.581:18| :skolemid |420| :pattern ( (MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)) )))
(assert (forall ((a@@24 T@U) (x@@22 T@U) ) (! (let ((T@@41 (type x@@22))) (=> (= (type a@@24) (MapType0Type T@@41 boolType)) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@24 x@@22) x@@22)))) :qid |DafnyPre.583:18| :skolemid |421| :pattern ( (|ISet#UnionOne| a@@24 x@@22)) )))
(assert (forall ((a@@25 T@U) (x@@23 T@U) (y@@5 T@U) ) (! (let ((T@@42 (type x@@23))) (=> (and (and (= (type a@@25) (MapType0Type T@@42 boolType)) (= (type y@@5) T@@42)) (U_2_bool (MapType0Select a@@25 y@@5))) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@25 x@@23) y@@5)))) :qid |DafnyPre.585:18| :skolemid |422| :pattern ( (|ISet#UnionOne| a@@25 x@@23) (MapType0Select a@@25 y@@5)) )))
(assert (forall ((arg0@@66 T@U) (arg1@@24 T@U) ) (! (let ((T@@43 (MapType0TypeInv0 (type arg0@@66)))) (= (type (|ISet#Union| arg0@@66 arg1@@24)) (MapType0Type T@@43 boolType))) :qid |funType:ISet#Union| :pattern ( (|ISet#Union| arg0@@66 arg1@@24)) )))
(assert (forall ((a@@26 T@U) (b@@18 T@U) (o@@16 T@U) ) (! (let ((T@@44 (type o@@16))) (=> (and (= (type a@@26) (MapType0Type T@@44 boolType)) (= (type b@@18) (MapType0Type T@@44 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)) (or (U_2_bool (MapType0Select a@@26 o@@16)) (U_2_bool (MapType0Select b@@18 o@@16)))) (=> (or (U_2_bool (MapType0Select a@@26 o@@16)) (U_2_bool (MapType0Select b@@18 o@@16))) (U_2_bool (MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)))))) :qid |DafnyPre.589:18| :skolemid |423| :pattern ( (MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)) )))
(assert (forall ((a@@27 T@U) (b@@19 T@U) (y@@6 T@U) ) (! (let ((T@@45 (type y@@6))) (=> (and (and (= (type a@@27) (MapType0Type T@@45 boolType)) (= (type b@@19) (MapType0Type T@@45 boolType))) (U_2_bool (MapType0Select a@@27 y@@6))) (U_2_bool (MapType0Select (|ISet#Union| a@@27 b@@19) y@@6)))) :qid |DafnyPre.591:18| :skolemid |424| :pattern ( (|ISet#Union| a@@27 b@@19) (MapType0Select a@@27 y@@6)) )))
(assert (forall ((a@@28 T@U) (b@@20 T@U) (y@@7 T@U) ) (! (let ((T@@46 (type y@@7))) (=> (and (and (= (type a@@28) (MapType0Type T@@46 boolType)) (= (type b@@20) (MapType0Type T@@46 boolType))) (U_2_bool (MapType0Select b@@20 y@@7))) (U_2_bool (MapType0Select (|ISet#Union| a@@28 b@@20) y@@7)))) :qid |DafnyPre.593:18| :skolemid |425| :pattern ( (|ISet#Union| a@@28 b@@20) (MapType0Select b@@20 y@@7)) )))
(assert (forall ((arg0@@67 T@U) (arg1@@25 T@U) ) (! (let ((T@@47 (MapType0TypeInv0 (type arg0@@67)))) (= (type (|ISet#Difference| arg0@@67 arg1@@25)) (MapType0Type T@@47 boolType))) :qid |funType:ISet#Difference| :pattern ( (|ISet#Difference| arg0@@67 arg1@@25)) )))
(assert (forall ((a@@29 T@U) (b@@21 T@U) ) (! (let ((T@@48 (MapType0TypeInv0 (type a@@29)))) (=> (and (and (= (type a@@29) (MapType0Type T@@48 boolType)) (= (type b@@21) (MapType0Type T@@48 boolType))) (|ISet#Disjoint| a@@29 b@@21)) (and (= (|ISet#Difference| (|ISet#Union| a@@29 b@@21) a@@29) b@@21) (= (|ISet#Difference| (|ISet#Union| a@@29 b@@21) b@@21) a@@29)))) :qid |DafnyPre.595:18| :skolemid |426| :pattern ( (|ISet#Union| a@@29 b@@21)) )))
(assert (forall ((arg0@@68 T@U) (arg1@@26 T@U) ) (! (let ((T@@49 (MapType0TypeInv0 (type arg0@@68)))) (= (type (|ISet#Intersection| arg0@@68 arg1@@26)) (MapType0Type T@@49 boolType))) :qid |funType:ISet#Intersection| :pattern ( (|ISet#Intersection| arg0@@68 arg1@@26)) )))
(assert (forall ((a@@30 T@U) (b@@22 T@U) (o@@17 T@U) ) (! (let ((T@@50 (type o@@17))) (=> (and (= (type a@@30) (MapType0Type T@@50 boolType)) (= (type b@@22) (MapType0Type T@@50 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)) (and (U_2_bool (MapType0Select a@@30 o@@17)) (U_2_bool (MapType0Select b@@22 o@@17)))) (=> (and (U_2_bool (MapType0Select a@@30 o@@17)) (U_2_bool (MapType0Select b@@22 o@@17))) (U_2_bool (MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)))))) :qid |DafnyPre.605:18| :skolemid |427| :pattern ( (MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)) )))
(assert (forall ((a@@31 T@U) (b@@23 T@U) ) (! (let ((T@@51 (MapType0TypeInv0 (type a@@31)))) (=> (and (= (type a@@31) (MapType0Type T@@51 boolType)) (= (type b@@23) (MapType0Type T@@51 boolType))) (= (|ISet#Union| (|ISet#Union| a@@31 b@@23) b@@23) (|ISet#Union| a@@31 b@@23)))) :qid |DafnyPre.608:18| :skolemid |428| :pattern ( (|ISet#Union| (|ISet#Union| a@@31 b@@23) b@@23)) )))
(assert (forall ((a@@32 T@U) (b@@24 T@U) ) (! (let ((T@@52 (MapType0TypeInv0 (type a@@32)))) (=> (and (= (type a@@32) (MapType0Type T@@52 boolType)) (= (type b@@24) (MapType0Type T@@52 boolType))) (= (|ISet#Union| a@@32 (|ISet#Union| a@@32 b@@24)) (|ISet#Union| a@@32 b@@24)))) :qid |DafnyPre.610:18| :skolemid |429| :pattern ( (|ISet#Union| a@@32 (|ISet#Union| a@@32 b@@24))) )))
(assert (forall ((a@@33 T@U) (b@@25 T@U) ) (! (let ((T@@53 (MapType0TypeInv0 (type a@@33)))) (=> (and (= (type a@@33) (MapType0Type T@@53 boolType)) (= (type b@@25) (MapType0Type T@@53 boolType))) (= (|ISet#Intersection| (|ISet#Intersection| a@@33 b@@25) b@@25) (|ISet#Intersection| a@@33 b@@25)))) :qid |DafnyPre.612:18| :skolemid |430| :pattern ( (|ISet#Intersection| (|ISet#Intersection| a@@33 b@@25) b@@25)) )))
(assert (forall ((a@@34 T@U) (b@@26 T@U) ) (! (let ((T@@54 (MapType0TypeInv0 (type a@@34)))) (=> (and (= (type a@@34) (MapType0Type T@@54 boolType)) (= (type b@@26) (MapType0Type T@@54 boolType))) (= (|ISet#Intersection| a@@34 (|ISet#Intersection| a@@34 b@@26)) (|ISet#Intersection| a@@34 b@@26)))) :qid |DafnyPre.614:18| :skolemid |431| :pattern ( (|ISet#Intersection| a@@34 (|ISet#Intersection| a@@34 b@@26))) )))
(assert (forall ((a@@35 T@U) (b@@27 T@U) (o@@18 T@U) ) (! (let ((T@@55 (type o@@18))) (=> (and (= (type a@@35) (MapType0Type T@@55 boolType)) (= (type b@@27) (MapType0Type T@@55 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)) (and (U_2_bool (MapType0Select a@@35 o@@18)) (not (U_2_bool (MapType0Select b@@27 o@@18))))) (=> (and (U_2_bool (MapType0Select a@@35 o@@18)) (not (U_2_bool (MapType0Select b@@27 o@@18)))) (U_2_bool (MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)))))) :qid |DafnyPre.619:18| :skolemid |432| :pattern ( (MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)) )))
(assert (forall ((a@@36 T@U) (b@@28 T@U) (y@@8 T@U) ) (! (let ((T@@56 (type y@@8))) (=> (and (and (= (type a@@36) (MapType0Type T@@56 boolType)) (= (type b@@28) (MapType0Type T@@56 boolType))) (U_2_bool (MapType0Select b@@28 y@@8))) (not (U_2_bool (MapType0Select (|ISet#Difference| a@@36 b@@28) y@@8))))) :qid |DafnyPre.621:18| :skolemid |433| :pattern ( (|ISet#Difference| a@@36 b@@28) (MapType0Select b@@28 y@@8)) )))
(assert (forall ((a@@37 T@U) (b@@29 T@U) ) (! (let ((T@@57 (MapType0TypeInv0 (type a@@37)))) (=> (and (= (type a@@37) (MapType0Type T@@57 boolType)) (= (type b@@29) (MapType0Type T@@57 boolType))) (and (=> (|ISet#Subset| a@@37 b@@29) (forall ((o@@19 T@U) ) (!  (=> (and (= (type o@@19) T@@57) (U_2_bool (MapType0Select a@@37 o@@19))) (U_2_bool (MapType0Select b@@29 o@@19))) :qid |DafnyPre.626:33| :skolemid |434| :pattern ( (MapType0Select a@@37 o@@19)) :pattern ( (MapType0Select b@@29 o@@19)) ))) (=> (forall ((o@@20 T@U) ) (!  (=> (and (= (type o@@20) T@@57) (U_2_bool (MapType0Select a@@37 o@@20))) (U_2_bool (MapType0Select b@@29 o@@20))) :qid |DafnyPre.626:33| :skolemid |434| :pattern ( (MapType0Select a@@37 o@@20)) :pattern ( (MapType0Select b@@29 o@@20)) )) (|ISet#Subset| a@@37 b@@29))))) :qid |DafnyPre.625:17| :skolemid |435| :pattern ( (|ISet#Subset| a@@37 b@@29)) )))
(assert (forall ((a@@38 T@U) (b@@30 T@U) ) (! (let ((T@@58 (MapType0TypeInv0 (type a@@38)))) (=> (and (= (type a@@38) (MapType0Type T@@58 boolType)) (= (type b@@30) (MapType0Type T@@58 boolType))) (and (=> (|ISet#Equal| a@@38 b@@30) (forall ((o@@21 T@U) ) (!  (=> (= (type o@@21) T@@58) (and (=> (U_2_bool (MapType0Select a@@38 o@@21)) (U_2_bool (MapType0Select b@@30 o@@21))) (=> (U_2_bool (MapType0Select b@@30 o@@21)) (U_2_bool (MapType0Select a@@38 o@@21))))) :qid |DafnyPre.634:32| :skolemid |436| :pattern ( (MapType0Select a@@38 o@@21)) :pattern ( (MapType0Select b@@30 o@@21)) ))) (=> (forall ((o@@22 T@U) ) (!  (=> (= (type o@@22) T@@58) (and (=> (U_2_bool (MapType0Select a@@38 o@@22)) (U_2_bool (MapType0Select b@@30 o@@22))) (=> (U_2_bool (MapType0Select b@@30 o@@22)) (U_2_bool (MapType0Select a@@38 o@@22))))) :qid |DafnyPre.634:32| :skolemid |436| :pattern ( (MapType0Select a@@38 o@@22)) :pattern ( (MapType0Select b@@30 o@@22)) )) (|ISet#Equal| a@@38 b@@30))))) :qid |DafnyPre.633:17| :skolemid |437| :pattern ( (|ISet#Equal| a@@38 b@@30)) )))
(assert (forall ((a@@39 T@U) (b@@31 T@U) ) (! (let ((T@@59 (MapType0TypeInv0 (type a@@39)))) (=> (and (and (= (type a@@39) (MapType0Type T@@59 boolType)) (= (type b@@31) (MapType0Type T@@59 boolType))) (|ISet#Equal| a@@39 b@@31)) (= a@@39 b@@31))) :qid |DafnyPre.635:17| :skolemid |438| :pattern ( (|ISet#Equal| a@@39 b@@31)) )))
(assert (forall ((a@@40 T@U) (b@@32 T@U) ) (! (let ((T@@60 (MapType0TypeInv0 (type a@@40)))) (=> (and (= (type a@@40) (MapType0Type T@@60 boolType)) (= (type b@@32) (MapType0Type T@@60 boolType))) (and (=> (|ISet#Disjoint| a@@40 b@@32) (forall ((o@@23 T@U) ) (!  (=> (= (type o@@23) T@@60) (or (not (U_2_bool (MapType0Select a@@40 o@@23))) (not (U_2_bool (MapType0Select b@@32 o@@23))))) :qid |DafnyPre.640:35| :skolemid |439| :pattern ( (MapType0Select a@@40 o@@23)) :pattern ( (MapType0Select b@@32 o@@23)) ))) (=> (forall ((o@@24 T@U) ) (!  (=> (= (type o@@24) T@@60) (or (not (U_2_bool (MapType0Select a@@40 o@@24))) (not (U_2_bool (MapType0Select b@@32 o@@24))))) :qid |DafnyPre.640:35| :skolemid |439| :pattern ( (MapType0Select a@@40 o@@24)) :pattern ( (MapType0Select b@@32 o@@24)) )) (|ISet#Disjoint| a@@40 b@@32))))) :qid |DafnyPre.639:18| :skolemid |440| :pattern ( (|ISet#Disjoint| a@@40 b@@32)) )))
(assert (forall ((a@@41 Int) (b@@33 Int) ) (!  (and (=> (<= a@@41 b@@33) (= (|Math#min| a@@41 b@@33) a@@41)) (=> (= (|Math#min| a@@41 b@@33) a@@41) (<= a@@41 b@@33))) :qid |DafnyPre.647:15| :skolemid |441| :pattern ( (|Math#min| a@@41 b@@33)) )))
(assert (forall ((a@@42 Int) (b@@34 Int) ) (!  (and (=> (<= b@@34 a@@42) (= (|Math#min| a@@42 b@@34) b@@34)) (=> (= (|Math#min| a@@42 b@@34) b@@34) (<= b@@34 a@@42))) :qid |DafnyPre.648:15| :skolemid |442| :pattern ( (|Math#min| a@@42 b@@34)) )))
(assert (forall ((a@@43 Int) (b@@35 Int) ) (!  (or (= (|Math#min| a@@43 b@@35) a@@43) (= (|Math#min| a@@43 b@@35) b@@35)) :qid |DafnyPre.649:15| :skolemid |443| :pattern ( (|Math#min| a@@43 b@@35)) )))
(assert (forall ((a@@44 Int) ) (!  (=> (<= 0 a@@44) (= (|Math#clip| a@@44) a@@44)) :qid |DafnyPre.652:15| :skolemid |444| :pattern ( (|Math#clip| a@@44)) )))
(assert (forall ((a@@45 Int) ) (!  (=> (< a@@45 0) (= (|Math#clip| a@@45) 0)) :qid |DafnyPre.653:15| :skolemid |445| :pattern ( (|Math#clip| a@@45)) )))
(assert (forall ((ms T@U) ) (! (let ((T@@61 (MapType0TypeInv0 (type ms)))) (=> (= (type ms) (MapType0Type T@@61 intType)) (and (=> ($IsGoodMultiSet ms) (forall ((bx@@31 T@U) ) (!  (=> (= (type bx@@31) T@@61) (and (<= 0 (U_2_int (MapType0Select ms bx@@31))) (<= (U_2_int (MapType0Select ms bx@@31)) (|MultiSet#Card| ms)))) :qid |DafnyPre.661:11| :skolemid |446| :pattern ( (MapType0Select ms bx@@31)) ))) (=> (forall ((bx@@32 T@U) ) (!  (=> (= (type bx@@32) T@@61) (and (<= 0 (U_2_int (MapType0Select ms bx@@32))) (<= (U_2_int (MapType0Select ms bx@@32)) (|MultiSet#Card| ms)))) :qid |DafnyPre.661:11| :skolemid |446| :pattern ( (MapType0Select ms bx@@32)) )) ($IsGoodMultiSet ms))))) :qid |DafnyPre.659:18| :skolemid |447| :pattern ( ($IsGoodMultiSet ms)) )))
(assert (forall ((s@@5 T@U) ) (! (let ((T@@62 (MapType0TypeInv0 (type s@@5)))) (=> (= (type s@@5) (MapType0Type T@@62 intType)) (<= 0 (|MultiSet#Card| s@@5)))) :qid |DafnyPre.664:18| :skolemid |448| :pattern ( (|MultiSet#Card| s@@5)) )))
(assert (forall ((s@@6 T@U) (x@@24 T@U) (n@@0 T@U) ) (! (let ((T@@63 (type x@@24))) (=> (and (and (= (type s@@6) (MapType0Type T@@63 intType)) (= (type n@@0) intType)) (<= 0 (U_2_int n@@0))) (= (|MultiSet#Card| (MapType0Store s@@6 x@@24 n@@0)) (+ (- (|MultiSet#Card| s@@6) (U_2_int (MapType0Select s@@6 x@@24))) (U_2_int n@@0))))) :qid |DafnyPre.665:18| :skolemid |449| :pattern ( (|MultiSet#Card| (MapType0Store s@@6 x@@24 n@@0))) )))
(assert (forall ((T@@64 T@T) ) (! (= (type (|MultiSet#Empty| T@@64)) (MapType0Type T@@64 intType)) :qid |funType:MultiSet#Empty| :pattern ( (|MultiSet#Empty| T@@64)) )))
(assert (forall ((o@@25 T@U) ) (! (let ((T@@65 (type o@@25))) (= (U_2_int (MapType0Select (|MultiSet#Empty| T@@65) o@@25)) 0)) :qid |DafnyPre.669:18| :skolemid |450| :pattern ( (let ((T@@65 (type o@@25))) (MapType0Select (|MultiSet#Empty| T@@65) o@@25))) )))
(assert (forall ((s@@7 T@U) ) (! (let ((T@@66 (MapType0TypeInv0 (type s@@7)))) (=> (= (type s@@7) (MapType0Type T@@66 intType)) (and (and (=> (= (|MultiSet#Card| s@@7) 0) (= s@@7 (|MultiSet#Empty| T@@66))) (=> (= s@@7 (|MultiSet#Empty| T@@66)) (= (|MultiSet#Card| s@@7) 0))) (=> (not (= (|MultiSet#Card| s@@7) 0)) (exists ((x@@25 T@U) ) (!  (and (= (type x@@25) T@@66) (< 0 (U_2_int (MapType0Select s@@7 x@@25)))) :qid |DafnyPre.672:38| :skolemid |451| :no-pattern (type x@@25) :no-pattern (U_2_int x@@25) :no-pattern (U_2_bool x@@25) )))))) :qid |DafnyPre.670:18| :skolemid |452| :pattern ( (|MultiSet#Card| s@@7)) )))
(assert (forall ((arg0@@69 T@U) ) (! (let ((T@@67 (type arg0@@69))) (= (type (|MultiSet#Singleton| arg0@@69)) (MapType0Type T@@67 intType))) :qid |funType:MultiSet#Singleton| :pattern ( (|MultiSet#Singleton| arg0@@69)) )))
(assert (forall ((r@@3 T@U) (o@@26 T@U) ) (! (let ((T@@68 (type r@@3))) (=> (= (type o@@26) T@@68) (and (and (=> (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 1) (= r@@3 o@@26)) (=> (= r@@3 o@@26) (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 1))) (and (=> (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 0) (not (= r@@3 o@@26))) (=> (not (= r@@3 o@@26)) (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 0)))))) :qid |DafnyPre.675:18| :skolemid |453| :pattern ( (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) )))
(assert (forall ((arg0@@70 T@U) (arg1@@27 T@U) ) (! (let ((T@@69 (type arg1@@27))) (= (type (|MultiSet#UnionOne| arg0@@70 arg1@@27)) (MapType0Type T@@69 intType))) :qid |funType:MultiSet#UnionOne| :pattern ( (|MultiSet#UnionOne| arg0@@70 arg1@@27)) )))
(assert (forall ((r@@4 T@U) ) (! (let ((T@@70 (type r@@4))) (= (|MultiSet#Singleton| r@@4) (|MultiSet#UnionOne| (|MultiSet#Empty| T@@70) r@@4))) :qid |DafnyPre.677:18| :skolemid |454| :pattern ( (|MultiSet#Singleton| r@@4)) )))
(assert (forall ((a@@46 T@U) (x@@26 T@U) (o@@27 T@U) ) (! (let ((T@@71 (type x@@26))) (=> (and (= (type a@@46) (MapType0Type T@@71 intType)) (= (type o@@27) T@@71)) (and (=> (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27))) (or (= o@@27 x@@26) (< 0 (U_2_int (MapType0Select a@@46 o@@27))))) (=> (or (= o@@27 x@@26) (< 0 (U_2_int (MapType0Select a@@46 o@@27)))) (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27))))))) :qid |DafnyPre.681:18| :skolemid |455| :pattern ( (MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27)) )))
(assert (forall ((a@@47 T@U) (x@@27 T@U) ) (! (let ((T@@72 (type x@@27))) (=> (= (type a@@47) (MapType0Type T@@72 intType)) (= (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@47 x@@27) x@@27)) (+ (U_2_int (MapType0Select a@@47 x@@27)) 1)))) :qid |DafnyPre.684:18| :skolemid |456| :pattern ( (|MultiSet#UnionOne| a@@47 x@@27)) )))
(assert (forall ((a@@48 T@U) (x@@28 T@U) (y@@9 T@U) ) (! (let ((T@@73 (type x@@28))) (=> (and (and (= (type a@@48) (MapType0Type T@@73 intType)) (= (type y@@9) T@@73)) (< 0 (U_2_int (MapType0Select a@@48 y@@9)))) (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@48 x@@28) y@@9))))) :qid |DafnyPre.687:18| :skolemid |457| :pattern ( (|MultiSet#UnionOne| a@@48 x@@28) (MapType0Select a@@48 y@@9)) )))
(assert (forall ((a@@49 T@U) (x@@29 T@U) (y@@10 T@U) ) (! (let ((T@@74 (type x@@29))) (=> (and (and (= (type a@@49) (MapType0Type T@@74 intType)) (= (type y@@10) T@@74)) (not (= x@@29 y@@10))) (= (U_2_int (MapType0Select a@@49 y@@10)) (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@49 x@@29) y@@10))))) :qid |DafnyPre.690:18| :skolemid |458| :pattern ( (|MultiSet#UnionOne| a@@49 x@@29) (MapType0Select a@@49 y@@10)) )))
(assert (forall ((a@@50 T@U) (x@@30 T@U) ) (! (let ((T@@75 (type x@@30))) (=> (= (type a@@50) (MapType0Type T@@75 intType)) (= (|MultiSet#Card| (|MultiSet#UnionOne| a@@50 x@@30)) (+ (|MultiSet#Card| a@@50) 1)))) :qid |DafnyPre.692:18| :skolemid |459| :pattern ( (|MultiSet#Card| (|MultiSet#UnionOne| a@@50 x@@30))) )))
(assert (forall ((arg0@@71 T@U) (arg1@@28 T@U) ) (! (let ((T@@76 (MapType0TypeInv0 (type arg0@@71)))) (= (type (|MultiSet#Union| arg0@@71 arg1@@28)) (MapType0Type T@@76 intType))) :qid |funType:MultiSet#Union| :pattern ( (|MultiSet#Union| arg0@@71 arg1@@28)) )))
(assert (forall ((a@@51 T@U) (b@@36 T@U) (o@@28 T@U) ) (! (let ((T@@77 (type o@@28))) (=> (and (= (type a@@51) (MapType0Type T@@77 intType)) (= (type b@@36) (MapType0Type T@@77 intType))) (= (U_2_int (MapType0Select (|MultiSet#Union| a@@51 b@@36) o@@28)) (+ (U_2_int (MapType0Select a@@51 o@@28)) (U_2_int (MapType0Select b@@36 o@@28)))))) :qid |DafnyPre.698:18| :skolemid |460| :pattern ( (MapType0Select (|MultiSet#Union| a@@51 b@@36) o@@28)) )))
(assert (forall ((a@@52 T@U) (b@@37 T@U) ) (! (let ((T@@78 (MapType0TypeInv0 (type a@@52)))) (=> (and (= (type a@@52) (MapType0Type T@@78 intType)) (= (type b@@37) (MapType0Type T@@78 intType))) (= (|MultiSet#Card| (|MultiSet#Union| a@@52 b@@37)) (+ (|MultiSet#Card| a@@52) (|MultiSet#Card| b@@37))))) :qid |DafnyPre.700:18| :skolemid |461| :pattern ( (|MultiSet#Card| (|MultiSet#Union| a@@52 b@@37))) )))
(assert (forall ((arg0@@72 T@U) (arg1@@29 T@U) ) (! (let ((T@@79 (MapType0TypeInv0 (type arg0@@72)))) (= (type (|MultiSet#Intersection| arg0@@72 arg1@@29)) (MapType0Type T@@79 intType))) :qid |funType:MultiSet#Intersection| :pattern ( (|MultiSet#Intersection| arg0@@72 arg1@@29)) )))
(assert (forall ((a@@53 T@U) (b@@38 T@U) (o@@29 T@U) ) (! (let ((T@@80 (type o@@29))) (=> (and (= (type a@@53) (MapType0Type T@@80 intType)) (= (type b@@38) (MapType0Type T@@80 intType))) (= (U_2_int (MapType0Select (|MultiSet#Intersection| a@@53 b@@38) o@@29)) (|Math#min| (U_2_int (MapType0Select a@@53 o@@29)) (U_2_int (MapType0Select b@@38 o@@29)))))) :qid |DafnyPre.704:18| :skolemid |462| :pattern ( (MapType0Select (|MultiSet#Intersection| a@@53 b@@38) o@@29)) )))
(assert (forall ((a@@54 T@U) (b@@39 T@U) ) (! (let ((T@@81 (MapType0TypeInv0 (type a@@54)))) (=> (and (= (type a@@54) (MapType0Type T@@81 intType)) (= (type b@@39) (MapType0Type T@@81 intType))) (= (|MultiSet#Intersection| (|MultiSet#Intersection| a@@54 b@@39) b@@39) (|MultiSet#Intersection| a@@54 b@@39)))) :qid |DafnyPre.708:18| :skolemid |463| :pattern ( (|MultiSet#Intersection| (|MultiSet#Intersection| a@@54 b@@39) b@@39)) )))
(assert (forall ((a@@55 T@U) (b@@40 T@U) ) (! (let ((T@@82 (MapType0TypeInv0 (type a@@55)))) (=> (and (= (type a@@55) (MapType0Type T@@82 intType)) (= (type b@@40) (MapType0Type T@@82 intType))) (= (|MultiSet#Intersection| a@@55 (|MultiSet#Intersection| a@@55 b@@40)) (|MultiSet#Intersection| a@@55 b@@40)))) :qid |DafnyPre.710:18| :skolemid |464| :pattern ( (|MultiSet#Intersection| a@@55 (|MultiSet#Intersection| a@@55 b@@40))) )))
(assert (forall ((arg0@@73 T@U) (arg1@@30 T@U) ) (! (let ((T@@83 (MapType0TypeInv0 (type arg0@@73)))) (= (type (|MultiSet#Difference| arg0@@73 arg1@@30)) (MapType0Type T@@83 intType))) :qid |funType:MultiSet#Difference| :pattern ( (|MultiSet#Difference| arg0@@73 arg1@@30)) )))
(assert (forall ((a@@56 T@U) (b@@41 T@U) (o@@30 T@U) ) (! (let ((T@@84 (type o@@30))) (=> (and (= (type a@@56) (MapType0Type T@@84 intType)) (= (type b@@41) (MapType0Type T@@84 intType))) (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@56 b@@41) o@@30)) (|Math#clip| (- (U_2_int (MapType0Select a@@56 o@@30)) (U_2_int (MapType0Select b@@41 o@@30))))))) :qid |DafnyPre.715:18| :skolemid |465| :pattern ( (MapType0Select (|MultiSet#Difference| a@@56 b@@41) o@@30)) )))
(assert (forall ((a@@57 T@U) (b@@42 T@U) (y@@11 T@U) ) (! (let ((T@@85 (type y@@11))) (=> (and (and (= (type a@@57) (MapType0Type T@@85 intType)) (= (type b@@42) (MapType0Type T@@85 intType))) (<= (U_2_int (MapType0Select a@@57 y@@11)) (U_2_int (MapType0Select b@@42 y@@11)))) (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@57 b@@42) y@@11)) 0))) :qid |DafnyPre.717:18| :skolemid |466| :pattern ( (|MultiSet#Difference| a@@57 b@@42) (MapType0Select b@@42 y@@11) (MapType0Select a@@57 y@@11)) )))
(assert (forall ((a@@58 T@U) (b@@43 T@U) ) (! (let ((T@@86 (MapType0TypeInv0 (type a@@58)))) (=> (and (= (type a@@58) (MapType0Type T@@86 intType)) (= (type b@@43) (MapType0Type T@@86 intType))) (and (= (+ (+ (|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43)) (|MultiSet#Card| (|MultiSet#Difference| b@@43 a@@58))) (* 2 (|MultiSet#Card| (|MultiSet#Intersection| a@@58 b@@43)))) (|MultiSet#Card| (|MultiSet#Union| a@@58 b@@43))) (= (|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43)) (- (|MultiSet#Card| a@@58) (|MultiSet#Card| (|MultiSet#Intersection| a@@58 b@@43))))))) :qid |DafnyPre.719:18| :skolemid |467| :pattern ( (|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43))) )))
(assert (forall ((a@@59 T@U) (b@@44 T@U) ) (! (let ((T@@87 (MapType0TypeInv0 (type a@@59)))) (=> (and (= (type a@@59) (MapType0Type T@@87 intType)) (= (type b@@44) (MapType0Type T@@87 intType))) (and (=> (|MultiSet#Subset| a@@59 b@@44) (forall ((o@@31 T@U) ) (!  (=> (= (type o@@31) T@@87) (<= (U_2_int (MapType0Select a@@59 o@@31)) (U_2_int (MapType0Select b@@44 o@@31)))) :qid |DafnyPre.729:37| :skolemid |468| :pattern ( (MapType0Select a@@59 o@@31)) :pattern ( (MapType0Select b@@44 o@@31)) ))) (=> (forall ((o@@32 T@U) ) (!  (=> (= (type o@@32) T@@87) (<= (U_2_int (MapType0Select a@@59 o@@32)) (U_2_int (MapType0Select b@@44 o@@32)))) :qid |DafnyPre.729:37| :skolemid |468| :pattern ( (MapType0Select a@@59 o@@32)) :pattern ( (MapType0Select b@@44 o@@32)) )) (|MultiSet#Subset| a@@59 b@@44))))) :qid |DafnyPre.728:17| :skolemid |469| :pattern ( (|MultiSet#Subset| a@@59 b@@44)) )))
(assert (forall ((a@@60 T@U) (b@@45 T@U) ) (! (let ((T@@88 (MapType0TypeInv0 (type a@@60)))) (=> (and (= (type a@@60) (MapType0Type T@@88 intType)) (= (type b@@45) (MapType0Type T@@88 intType))) (and (=> (|MultiSet#Equal| a@@60 b@@45) (forall ((o@@33 T@U) ) (!  (=> (= (type o@@33) T@@88) (= (U_2_int (MapType0Select a@@60 o@@33)) (U_2_int (MapType0Select b@@45 o@@33)))) :qid |DafnyPre.733:36| :skolemid |470| :pattern ( (MapType0Select a@@60 o@@33)) :pattern ( (MapType0Select b@@45 o@@33)) ))) (=> (forall ((o@@34 T@U) ) (!  (=> (= (type o@@34) T@@88) (= (U_2_int (MapType0Select a@@60 o@@34)) (U_2_int (MapType0Select b@@45 o@@34)))) :qid |DafnyPre.733:36| :skolemid |470| :pattern ( (MapType0Select a@@60 o@@34)) :pattern ( (MapType0Select b@@45 o@@34)) )) (|MultiSet#Equal| a@@60 b@@45))))) :qid |DafnyPre.732:17| :skolemid |471| :pattern ( (|MultiSet#Equal| a@@60 b@@45)) )))
(assert (forall ((a@@61 T@U) (b@@46 T@U) ) (! (let ((T@@89 (MapType0TypeInv0 (type a@@61)))) (=> (and (and (= (type a@@61) (MapType0Type T@@89 intType)) (= (type b@@46) (MapType0Type T@@89 intType))) (|MultiSet#Equal| a@@61 b@@46)) (= a@@61 b@@46))) :qid |DafnyPre.735:17| :skolemid |472| :pattern ( (|MultiSet#Equal| a@@61 b@@46)) )))
(assert (forall ((a@@62 T@U) (b@@47 T@U) ) (! (let ((T@@90 (MapType0TypeInv0 (type a@@62)))) (=> (and (= (type a@@62) (MapType0Type T@@90 intType)) (= (type b@@47) (MapType0Type T@@90 intType))) (and (=> (|MultiSet#Disjoint| a@@62 b@@47) (forall ((o@@35 T@U) ) (!  (=> (= (type o@@35) T@@90) (or (= (U_2_int (MapType0Select a@@62 o@@35)) 0) (= (U_2_int (MapType0Select b@@47 o@@35)) 0))) :qid |DafnyPre.740:39| :skolemid |473| :pattern ( (MapType0Select a@@62 o@@35)) :pattern ( (MapType0Select b@@47 o@@35)) ))) (=> (forall ((o@@36 T@U) ) (!  (=> (= (type o@@36) T@@90) (or (= (U_2_int (MapType0Select a@@62 o@@36)) 0) (= (U_2_int (MapType0Select b@@47 o@@36)) 0))) :qid |DafnyPre.740:39| :skolemid |473| :pattern ( (MapType0Select a@@62 o@@36)) :pattern ( (MapType0Select b@@47 o@@36)) )) (|MultiSet#Disjoint| a@@62 b@@47))))) :qid |DafnyPre.739:18| :skolemid |474| :pattern ( (|MultiSet#Disjoint| a@@62 b@@47)) )))
(assert (forall ((arg0@@74 T@U) ) (! (let ((T@@91 (MapType0TypeInv0 (type arg0@@74)))) (= (type (|MultiSet#FromSet| arg0@@74)) (MapType0Type T@@91 intType))) :qid |funType:MultiSet#FromSet| :pattern ( (|MultiSet#FromSet| arg0@@74)) )))
(assert (forall ((s@@8 T@U) (a@@63 T@U) ) (! (let ((T@@92 (type a@@63))) (=> (= (type s@@8) (MapType0Type T@@92 boolType)) (and (and (=> (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 0) (not (U_2_bool (MapType0Select s@@8 a@@63)))) (=> (not (U_2_bool (MapType0Select s@@8 a@@63))) (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 0))) (and (=> (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 1) (U_2_bool (MapType0Select s@@8 a@@63))) (=> (U_2_bool (MapType0Select s@@8 a@@63)) (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 1)))))) :qid |DafnyPre.744:18| :skolemid |475| :pattern ( (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) )))
(assert (forall ((s@@9 T@U) ) (! (let ((T@@93 (MapType0TypeInv0 (type s@@9)))) (=> (= (type s@@9) (MapType0Type T@@93 boolType)) (= (|MultiSet#Card| (|MultiSet#FromSet| s@@9)) (|Set#Card| s@@9)))) :qid |DafnyPre.747:18| :skolemid |476| :pattern ( (|MultiSet#Card| (|MultiSet#FromSet| s@@9))) )))
(assert (forall ((arg0@@75 T@U) ) (! (let ((T@@94 (SeqTypeInv0 (type arg0@@75)))) (= (type (|MultiSet#FromSeq| arg0@@75)) (MapType0Type T@@94 intType))) :qid |funType:MultiSet#FromSeq| :pattern ( (|MultiSet#FromSeq| arg0@@75)) )))
(assert (forall ((s@@10 T@U) ) (! (let ((T@@95 (SeqTypeInv0 (type s@@10)))) (=> (= (type s@@10) (SeqType T@@95)) ($IsGoodMultiSet (|MultiSet#FromSeq| s@@10)))) :qid |DafnyPre.753:18| :skolemid |477| :pattern ( (|MultiSet#FromSeq| s@@10)) )))
(assert (forall ((s@@11 T@U) ) (! (let ((T@@96 (SeqTypeInv0 (type s@@11)))) (=> (= (type s@@11) (SeqType T@@96)) (= (|MultiSet#Card| (|MultiSet#FromSeq| s@@11)) (|Seq#Length| s@@11)))) :qid |DafnyPre.755:18| :skolemid |478| :pattern ( (|MultiSet#Card| (|MultiSet#FromSeq| s@@11))) )))
(assert (forall ((arg0@@76 T@U) (arg1@@31 T@U) ) (! (let ((T@@97 (type arg1@@31))) (= (type (|Seq#Build| arg0@@76 arg1@@31)) (SeqType T@@97))) :qid |funType:Seq#Build| :pattern ( (|Seq#Build| arg0@@76 arg1@@31)) )))
(assert (forall ((s@@12 T@U) (v@@23 T@U) ) (! (let ((T@@98 (type v@@23))) (=> (= (type s@@12) (SeqType T@@98)) (= (|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@23)) (|MultiSet#UnionOne| (|MultiSet#FromSeq| s@@12) v@@23)))) :qid |DafnyPre.759:18| :skolemid |479| :pattern ( (|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@23))) )))
(assert (forall ((T@@99 T@T) ) (! (= (type (|Seq#Empty| T@@99)) (SeqType T@@99)) :qid |funType:Seq#Empty| :pattern ( (|Seq#Empty| T@@99)) )))
(assert (forall ((T@@100 T@T) ) (! (= (|MultiSet#FromSeq| (|Seq#Empty| T@@100)) (|MultiSet#Empty| T@@100)) :skolemid |480| )))
(assert (forall ((arg0@@77 T@U) (arg1@@32 T@U) ) (! (let ((T@@101 (SeqTypeInv0 (type arg0@@77)))) (= (type (|Seq#Append| arg0@@77 arg1@@32)) (SeqType T@@101))) :qid |funType:Seq#Append| :pattern ( (|Seq#Append| arg0@@77 arg1@@32)) )))
(assert (forall ((a@@64 T@U) (b@@48 T@U) ) (! (let ((T@@102 (SeqTypeInv0 (type a@@64)))) (=> (and (= (type a@@64) (SeqType T@@102)) (= (type b@@48) (SeqType T@@102))) (= (|MultiSet#FromSeq| (|Seq#Append| a@@64 b@@48)) (|MultiSet#Union| (|MultiSet#FromSeq| a@@64) (|MultiSet#FromSeq| b@@48))))) :qid |DafnyPre.766:18| :skolemid |481| :pattern ( (|MultiSet#FromSeq| (|Seq#Append| a@@64 b@@48))) )))
(assert (forall ((arg0@@78 T@U) (arg1@@33 Int) (arg2@@2 T@U) ) (! (let ((T@@103 (type arg2@@2))) (= (type (|Seq#Update| arg0@@78 arg1@@33 arg2@@2)) (SeqType T@@103))) :qid |funType:Seq#Update| :pattern ( (|Seq#Update| arg0@@78 arg1@@33 arg2@@2)) )))
(assert (forall ((s@@13 T@U) (i@@8 Int) (v@@24 T@U) (x@@31 T@U) ) (! (let ((T@@104 (type v@@24))) (=> (and (and (= (type s@@13) (SeqType T@@104)) (= (type x@@31) T@@104)) (and (<= 0 i@@8) (< i@@8 (|Seq#Length| s@@13)))) (= (U_2_int (MapType0Select (|MultiSet#FromSeq| (|Seq#Update| s@@13 i@@8 v@@24)) x@@31)) (U_2_int (MapType0Select (|MultiSet#Union| (|MultiSet#Difference| (|MultiSet#FromSeq| s@@13) (|MultiSet#Singleton| (|Seq#Index| s@@13 i@@8))) (|MultiSet#Singleton| v@@24)) x@@31))))) :qid |DafnyPre.771:18| :skolemid |482| :pattern ( (MapType0Select (|MultiSet#FromSeq| (|Seq#Update| s@@13 i@@8 v@@24)) x@@31)) )))
(assert (forall ((s@@14 T@U) (x@@32 T@U) ) (! (let ((T@@105 (type x@@32))) (=> (= (type s@@14) (SeqType T@@105)) (and (=> (exists ((i@@9 Int) ) (!  (and (and (<= 0 i@@9) (< i@@9 (|Seq#Length| s@@14))) (= x@@32 (|Seq#Index| s@@14 i@@9))) :qid |DafnyPre.778:11| :skolemid |483| :pattern ( (|Seq#Index| s@@14 i@@9)) )) (< 0 (U_2_int (MapType0Select (|MultiSet#FromSeq| s@@14) x@@32)))) (=> (< 0 (U_2_int (MapType0Select (|MultiSet#FromSeq| s@@14) x@@32))) (exists ((i@@10 Int) ) (!  (and (and (<= 0 i@@10) (< i@@10 (|Seq#Length| s@@14))) (= x@@32 (|Seq#Index| s@@14 i@@10))) :qid |DafnyPre.778:11| :skolemid |483| :pattern ( (|Seq#Index| s@@14 i@@10)) )))))) :qid |DafnyPre.777:18| :skolemid |484| :pattern ( (MapType0Select (|MultiSet#FromSeq| s@@14) x@@32)) )))
(assert (forall ((s@@15 T@U) ) (! (let ((T@@106 (SeqTypeInv0 (type s@@15)))) (=> (= (type s@@15) (SeqType T@@106)) (<= 0 (|Seq#Length| s@@15)))) :qid |DafnyPre.787:18| :skolemid |485| :pattern ( (|Seq#Length| s@@15)) )))
(assert (forall ((T@@107 T@T) ) (! (= (|Seq#Length| (|Seq#Empty| T@@107)) 0) :skolemid |486| )))
(assert (forall ((s@@16 T@U) ) (! (let ((T@@108 (SeqTypeInv0 (type s@@16)))) (=> (and (= (type s@@16) (SeqType T@@108)) (= (|Seq#Length| s@@16) 0)) (= s@@16 (|Seq#Empty| T@@108)))) :qid |DafnyPre.791:18| :skolemid |487| :pattern ( (|Seq#Length| s@@16)) )))
(assert (forall ((t@@23 T@U) (T@@109 T@T) ) (!  (=> (= (type t@@23) TyType) ($Is (|Seq#Empty| T@@109) t@@23)) :qid |DafnyPre.801:18| :skolemid |488| :pattern ( ($Is (|Seq#Empty| T@@109) t@@23)) )))
(assert (forall ((arg0@@79 T@U) ) (! (let ((T@@110 (type arg0@@79))) (= (type (|Seq#Singleton| arg0@@79)) (SeqType T@@110))) :qid |funType:Seq#Singleton| :pattern ( (|Seq#Singleton| arg0@@79)) )))
(assert (forall ((t@@24 T@U) ) (! (= (|Seq#Length| (|Seq#Singleton| t@@24)) 1) :qid |DafnyPre.804:18| :skolemid |489| :pattern ( (|Seq#Length| (|Seq#Singleton| t@@24))) )))
(assert  (and (forall ((arg0@@80 T@U) ) (! (let ((T@@111 (SeqTypeInv0 (type arg0@@80)))) (= (type (|Seq#Build_inv0| arg0@@80)) (SeqType T@@111))) :qid |funType:Seq#Build_inv0| :pattern ( (|Seq#Build_inv0| arg0@@80)) )) (forall ((arg0@@81 T@U) ) (! (let ((T@@112 (SeqTypeInv0 (type arg0@@81)))) (= (type (|Seq#Build_inv1| arg0@@81)) T@@112)) :qid |funType:Seq#Build_inv1| :pattern ( (|Seq#Build_inv1| arg0@@81)) ))))
(assert (forall ((s@@17 T@U) (val@@6 T@U) ) (! (let ((T@@113 (type val@@6))) (=> (= (type s@@17) (SeqType T@@113)) (and (= (|Seq#Build_inv0| (|Seq#Build| s@@17 val@@6)) s@@17) (= (|Seq#Build_inv1| (|Seq#Build| s@@17 val@@6)) val@@6)))) :qid |DafnyPre.809:18| :skolemid |490| :pattern ( (|Seq#Build| s@@17 val@@6)) )))
(assert (forall ((s@@18 T@U) (v@@25 T@U) ) (! (let ((T@@114 (type v@@25))) (=> (= (type s@@18) (SeqType T@@114)) (= (|Seq#Length| (|Seq#Build| s@@18 v@@25)) (+ 1 (|Seq#Length| s@@18))))) :qid |DafnyPre.814:18| :skolemid |491| :pattern ( (|Seq#Length| (|Seq#Build| s@@18 v@@25))) )))
(assert (forall ((s@@19 T@U) (i@@11 Int) (v@@26 T@U) ) (! (let ((T@@115 (type v@@26))) (=> (= (type s@@19) (SeqType T@@115)) (and (=> (= i@@11 (|Seq#Length| s@@19)) (= (|Seq#Index| (|Seq#Build| s@@19 v@@26) i@@11) v@@26)) (=> (not (= i@@11 (|Seq#Length| s@@19))) (= (|Seq#Index| (|Seq#Build| s@@19 v@@26) i@@11) (|Seq#Index| s@@19 i@@11)))))) :qid |DafnyPre.816:18| :skolemid |492| :pattern ( (|Seq#Index| (|Seq#Build| s@@19 v@@26) i@@11)) )))
(assert (forall ((s@@20 T@U) (bx@@33 T@U) (t@@25 T@U) ) (!  (=> (and (and (and (= (type s@@20) (SeqType BoxType)) (= (type bx@@33) BoxType)) (= (type t@@25) TyType)) (and ($Is s@@20 (TSeq t@@25)) ($IsBox bx@@33 t@@25))) ($Is (|Seq#Build| s@@20 bx@@33) (TSeq t@@25))) :qid |DafnyPre.821:15| :skolemid |493| :pattern ( ($Is (|Seq#Build| s@@20 bx@@33) (TSeq t@@25))) )))
(assert (forall ((s0 T@U) (s1 T@U) ) (! (let ((T@@116 (SeqTypeInv0 (type s0)))) (=> (and (= (type s0) (SeqType T@@116)) (= (type s1) (SeqType T@@116))) (= (|Seq#Length| (|Seq#Append| s0 s1)) (+ (|Seq#Length| s0) (|Seq#Length| s1))))) :qid |DafnyPre.825:18| :skolemid |494| :pattern ( (|Seq#Length| (|Seq#Append| s0 s1))) )))
(assert (forall ((s0@@0 T@U) (s1@@0 T@U) (t@@26 T@U) ) (!  (=> (and (and (and (= (type s0@@0) (SeqType BoxType)) (= (type s1@@0) (SeqType BoxType))) (= (type t@@26) TyType)) (and ($Is s0@@0 t@@26) ($Is s1@@0 t@@26))) ($Is (|Seq#Append| s0@@0 s1@@0) t@@26)) :qid |DafnyPre.829:15| :skolemid |495| :pattern ( ($Is (|Seq#Append| s0@@0 s1@@0) t@@26)) )))
(assert (forall ((t@@27 T@U) ) (! (= (|Seq#Index| (|Seq#Singleton| t@@27) 0) t@@27) :qid |DafnyPre.833:18| :skolemid |496| :pattern ( (|Seq#Index| (|Seq#Singleton| t@@27) 0)) )))
(assert (forall ((s0@@1 T@U) (s1@@1 T@U) (n@@1 Int) ) (! (let ((T@@117 (SeqTypeInv0 (type s0@@1)))) (=> (and (= (type s0@@1) (SeqType T@@117)) (= (type s1@@1) (SeqType T@@117))) (and (=> (< n@@1 (|Seq#Length| s0@@1)) (= (|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1) (|Seq#Index| s0@@1 n@@1))) (=> (<= (|Seq#Length| s0@@1) n@@1) (= (|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1) (|Seq#Index| s1@@1 (- n@@1 (|Seq#Length| s0@@1)))))))) :qid |DafnyPre.834:18| :skolemid |497| :pattern ( (|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1)) )))
(assert (forall ((s@@21 T@U) (i@@12 Int) (v@@27 T@U) ) (! (let ((T@@118 (type v@@27))) (=> (= (type s@@21) (SeqType T@@118)) (=> (and (<= 0 i@@12) (< i@@12 (|Seq#Length| s@@21))) (= (|Seq#Length| (|Seq#Update| s@@21 i@@12 v@@27)) (|Seq#Length| s@@21))))) :qid |DafnyPre.839:18| :skolemid |498| :pattern ( (|Seq#Length| (|Seq#Update| s@@21 i@@12 v@@27))) )))
(assert (forall ((s@@22 T@U) (i@@13 Int) (v@@28 T@U) (n@@2 Int) ) (! (let ((T@@119 (type v@@28))) (=> (= (type s@@22) (SeqType T@@119)) (=> (and (<= 0 n@@2) (< n@@2 (|Seq#Length| s@@22))) (and (=> (= i@@13 n@@2) (= (|Seq#Index| (|Seq#Update| s@@22 i@@13 v@@28) n@@2) v@@28)) (=> (not (= i@@13 n@@2)) (= (|Seq#Index| (|Seq#Update| s@@22 i@@13 v@@28) n@@2) (|Seq#Index| s@@22 n@@2))))))) :qid |DafnyPre.841:18| :skolemid |499| :pattern ( (|Seq#Index| (|Seq#Update| s@@22 i@@13 v@@28) n@@2)) )))
(assert (forall ((s@@23 T@U) (x@@33 T@U) ) (! (let ((T@@120 (type x@@33))) (=> (= (type s@@23) (SeqType T@@120)) (and (=> (|Seq#Contains| s@@23 x@@33) (exists ((i@@14 Int) ) (!  (and (and (<= 0 i@@14) (< i@@14 (|Seq#Length| s@@23))) (= (|Seq#Index| s@@23 i@@14) x@@33)) :qid |DafnyPre.849:13| :skolemid |500| :pattern ( (|Seq#Index| s@@23 i@@14)) ))) (=> (exists ((i@@15 Int) ) (!  (and (and (<= 0 i@@15) (< i@@15 (|Seq#Length| s@@23))) (= (|Seq#Index| s@@23 i@@15) x@@33)) :qid |DafnyPre.849:13| :skolemid |500| :pattern ( (|Seq#Index| s@@23 i@@15)) )) (|Seq#Contains| s@@23 x@@33))))) :qid |DafnyPre.847:18| :skolemid |501| :pattern ( (|Seq#Contains| s@@23 x@@33)) )))
(assert (forall ((x@@34 T@U) ) (! (let ((T@@121 (type x@@34))) (not (|Seq#Contains| (|Seq#Empty| T@@121) x@@34))) :qid |DafnyPre.850:18| :skolemid |502| :pattern ( (let ((T@@121 (type x@@34))) (|Seq#Contains| (|Seq#Empty| T@@121) x@@34))) )))
(assert (forall ((s0@@2 T@U) (s1@@2 T@U) (x@@35 T@U) ) (! (let ((T@@122 (type x@@35))) (=> (and (= (type s0@@2) (SeqType T@@122)) (= (type s1@@2) (SeqType T@@122))) (and (=> (|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35) (or (|Seq#Contains| s0@@2 x@@35) (|Seq#Contains| s1@@2 x@@35))) (=> (or (|Seq#Contains| s0@@2 x@@35) (|Seq#Contains| s1@@2 x@@35)) (|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35))))) :qid |DafnyPre.854:18| :skolemid |503| :pattern ( (|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35)) )))
(assert (forall ((s@@24 T@U) (v@@29 T@U) (x@@36 T@U) ) (! (let ((T@@123 (type v@@29))) (=> (and (= (type s@@24) (SeqType T@@123)) (= (type x@@36) T@@123)) (and (=> (|Seq#Contains| (|Seq#Build| s@@24 v@@29) x@@36) (or (= v@@29 x@@36) (|Seq#Contains| s@@24 x@@36))) (=> (or (= v@@29 x@@36) (|Seq#Contains| s@@24 x@@36)) (|Seq#Contains| (|Seq#Build| s@@24 v@@29) x@@36))))) :qid |DafnyPre.859:18| :skolemid |504| :pattern ( (|Seq#Contains| (|Seq#Build| s@@24 v@@29) x@@36)) )))
(assert (forall ((arg0@@82 T@U) (arg1@@34 Int) ) (! (let ((T@@124 (SeqTypeInv0 (type arg0@@82)))) (= (type (|Seq#Take| arg0@@82 arg1@@34)) (SeqType T@@124))) :qid |funType:Seq#Take| :pattern ( (|Seq#Take| arg0@@82 arg1@@34)) )))
(assert (forall ((s@@25 T@U) (n@@3 Int) (x@@37 T@U) ) (! (let ((T@@125 (type x@@37))) (=> (= (type s@@25) (SeqType T@@125)) (and (=> (|Seq#Contains| (|Seq#Take| s@@25 n@@3) x@@37) (exists ((i@@16 Int) ) (!  (and (and (and (<= 0 i@@16) (< i@@16 n@@3)) (< i@@16 (|Seq#Length| s@@25))) (= (|Seq#Index| s@@25 i@@16) x@@37)) :qid |DafnyPre.866:13| :skolemid |505| :pattern ( (|Seq#Index| s@@25 i@@16)) ))) (=> (exists ((i@@17 Int) ) (!  (and (and (and (<= 0 i@@17) (< i@@17 n@@3)) (< i@@17 (|Seq#Length| s@@25))) (= (|Seq#Index| s@@25 i@@17) x@@37)) :qid |DafnyPre.866:13| :skolemid |505| :pattern ( (|Seq#Index| s@@25 i@@17)) )) (|Seq#Contains| (|Seq#Take| s@@25 n@@3) x@@37))))) :qid |DafnyPre.863:18| :skolemid |506| :pattern ( (|Seq#Contains| (|Seq#Take| s@@25 n@@3) x@@37)) )))
(assert (forall ((arg0@@83 T@U) (arg1@@35 Int) ) (! (let ((T@@126 (SeqTypeInv0 (type arg0@@83)))) (= (type (|Seq#Drop| arg0@@83 arg1@@35)) (SeqType T@@126))) :qid |funType:Seq#Drop| :pattern ( (|Seq#Drop| arg0@@83 arg1@@35)) )))
(assert (forall ((s@@26 T@U) (n@@4 Int) (x@@38 T@U) ) (! (let ((T@@127 (type x@@38))) (=> (= (type s@@26) (SeqType T@@127)) (and (=> (|Seq#Contains| (|Seq#Drop| s@@26 n@@4) x@@38) (exists ((i@@18 Int) ) (!  (and (and (and (<= 0 n@@4) (<= n@@4 i@@18)) (< i@@18 (|Seq#Length| s@@26))) (= (|Seq#Index| s@@26 i@@18) x@@38)) :qid |DafnyPre.871:13| :skolemid |507| :pattern ( (|Seq#Index| s@@26 i@@18)) ))) (=> (exists ((i@@19 Int) ) (!  (and (and (and (<= 0 n@@4) (<= n@@4 i@@19)) (< i@@19 (|Seq#Length| s@@26))) (= (|Seq#Index| s@@26 i@@19) x@@38)) :qid |DafnyPre.871:13| :skolemid |507| :pattern ( (|Seq#Index| s@@26 i@@19)) )) (|Seq#Contains| (|Seq#Drop| s@@26 n@@4) x@@38))))) :qid |DafnyPre.868:18| :skolemid |508| :pattern ( (|Seq#Contains| (|Seq#Drop| s@@26 n@@4) x@@38)) )))
(assert (forall ((s0@@3 T@U) (s1@@3 T@U) ) (! (let ((T@@128 (SeqTypeInv0 (type s0@@3)))) (=> (and (= (type s0@@3) (SeqType T@@128)) (= (type s1@@3) (SeqType T@@128))) (and (=> (|Seq#Equal| s0@@3 s1@@3) (and (= (|Seq#Length| s0@@3) (|Seq#Length| s1@@3)) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|Seq#Length| s0@@3))) (= (|Seq#Index| s0@@3 j) (|Seq#Index| s1@@3 j))) :qid |DafnyPre.878:13| :skolemid |509| :pattern ( (|Seq#Index| s0@@3 j)) :pattern ( (|Seq#Index| s1@@3 j)) )))) (=> (and (= (|Seq#Length| s0@@3) (|Seq#Length| s1@@3)) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|Seq#Length| s0@@3))) (= (|Seq#Index| s0@@3 j@@0) (|Seq#Index| s1@@3 j@@0))) :qid |DafnyPre.878:13| :skolemid |509| :pattern ( (|Seq#Index| s0@@3 j@@0)) :pattern ( (|Seq#Index| s1@@3 j@@0)) ))) (|Seq#Equal| s0@@3 s1@@3))))) :qid |DafnyPre.875:18| :skolemid |510| :pattern ( (|Seq#Equal| s0@@3 s1@@3)) )))
(assert (forall ((a@@65 T@U) (b@@49 T@U) ) (! (let ((T@@129 (SeqTypeInv0 (type a@@65)))) (=> (and (and (= (type a@@65) (SeqType T@@129)) (= (type b@@49) (SeqType T@@129))) (|Seq#Equal| a@@65 b@@49)) (= a@@65 b@@49))) :qid |DafnyPre.880:18| :skolemid |511| :pattern ( (|Seq#Equal| a@@65 b@@49)) )))
(assert (forall ((s0@@4 T@U) (s1@@4 T@U) (n@@5 Int) ) (! (let ((T@@130 (SeqTypeInv0 (type s0@@4)))) (=> (and (= (type s0@@4) (SeqType T@@130)) (= (type s1@@4) (SeqType T@@130))) (and (=> (|Seq#SameUntil| s0@@4 s1@@4 n@@5) (forall ((j@@1 Int) ) (!  (=> (and (<= 0 j@@1) (< j@@1 n@@5)) (= (|Seq#Index| s0@@4 j@@1) (|Seq#Index| s1@@4 j@@1))) :qid |DafnyPre.886:13| :skolemid |512| :pattern ( (|Seq#Index| s0@@4 j@@1)) :pattern ( (|Seq#Index| s1@@4 j@@1)) ))) (=> (forall ((j@@2 Int) ) (!  (=> (and (<= 0 j@@2) (< j@@2 n@@5)) (= (|Seq#Index| s0@@4 j@@2) (|Seq#Index| s1@@4 j@@2))) :qid |DafnyPre.886:13| :skolemid |512| :pattern ( (|Seq#Index| s0@@4 j@@2)) :pattern ( (|Seq#Index| s1@@4 j@@2)) )) (|Seq#SameUntil| s0@@4 s1@@4 n@@5))))) :qid |DafnyPre.884:18| :skolemid |513| :pattern ( (|Seq#SameUntil| s0@@4 s1@@4 n@@5)) )))
(assert (forall ((s@@27 T@U) (n@@6 Int) ) (! (let ((T@@131 (SeqTypeInv0 (type s@@27)))) (=> (= (type s@@27) (SeqType T@@131)) (=> (and (<= 0 n@@6) (<= n@@6 (|Seq#Length| s@@27))) (= (|Seq#Length| (|Seq#Take| s@@27 n@@6)) n@@6)))) :qid |DafnyPre.890:18| :skolemid |514| :pattern ( (|Seq#Length| (|Seq#Take| s@@27 n@@6))) )))
(assert (forall ((s@@28 T@U) (n@@7 Int) (j@@3 Int) ) (! (let ((T@@132 (SeqTypeInv0 (type s@@28)))) (=> (= (type s@@28) (SeqType T@@132)) (=> (and (and (<= 0 j@@3) (< j@@3 n@@7)) (< j@@3 (|Seq#Length| s@@28))) (= (|Seq#Index| (|Seq#Take| s@@28 n@@7) j@@3) (|Seq#Index| s@@28 j@@3))))) :qid |DafnyPre.892:18| :weight 25 :skolemid |515| :pattern ( (|Seq#Index| (|Seq#Take| s@@28 n@@7) j@@3)) :pattern ( (|Seq#Index| s@@28 j@@3) (|Seq#Take| s@@28 n@@7)) )))
(assert (forall ((s@@29 T@U) (n@@8 Int) ) (! (let ((T@@133 (SeqTypeInv0 (type s@@29)))) (=> (= (type s@@29) (SeqType T@@133)) (=> (and (<= 0 n@@8) (<= n@@8 (|Seq#Length| s@@29))) (= (|Seq#Length| (|Seq#Drop| s@@29 n@@8)) (- (|Seq#Length| s@@29) n@@8))))) :qid |DafnyPre.900:18| :skolemid |516| :pattern ( (|Seq#Length| (|Seq#Drop| s@@29 n@@8))) )))
(assert (forall ((s@@30 T@U) (n@@9 Int) (j@@4 Int) ) (! (let ((T@@134 (SeqTypeInv0 (type s@@30)))) (=> (= (type s@@30) (SeqType T@@134)) (=> (and (and (<= 0 n@@9) (<= 0 j@@4)) (< j@@4 (- (|Seq#Length| s@@30) n@@9))) (= (|Seq#Index| (|Seq#Drop| s@@30 n@@9) j@@4) (|Seq#Index| s@@30 (+ j@@4 n@@9)))))) :qid |DafnyPre.902:18| :weight 25 :skolemid |517| :pattern ( (|Seq#Index| (|Seq#Drop| s@@30 n@@9) j@@4)) )))
(assert (forall ((s@@31 T@U) (n@@10 Int) (k@@3 Int) ) (! (let ((T@@135 (SeqTypeInv0 (type s@@31)))) (=> (= (type s@@31) (SeqType T@@135)) (=> (and (and (<= 0 n@@10) (<= n@@10 k@@3)) (< k@@3 (|Seq#Length| s@@31))) (= (|Seq#Index| (|Seq#Drop| s@@31 n@@10) (- k@@3 n@@10)) (|Seq#Index| s@@31 k@@3))))) :qid |DafnyPre.907:18| :weight 25 :skolemid |518| :pattern ( (|Seq#Index| s@@31 k@@3) (|Seq#Drop| s@@31 n@@10)) )))
(assert (forall ((s@@32 T@U) (t@@28 T@U) ) (! (let ((T@@136 (SeqTypeInv0 (type s@@32)))) (=> (and (= (type s@@32) (SeqType T@@136)) (= (type t@@28) (SeqType T@@136))) (and (= (|Seq#Take| (|Seq#Append| s@@32 t@@28) (|Seq#Length| s@@32)) s@@32) (= (|Seq#Drop| (|Seq#Append| s@@32 t@@28) (|Seq#Length| s@@32)) t@@28)))) :qid |DafnyPre.913:18| :skolemid |519| :pattern ( (|Seq#Append| s@@32 t@@28)) )))
(assert (forall ((arg0@@84 T@U) (arg1@@36 T@U) ) (! (= (type (|Seq#FromArray| arg0@@84 arg1@@36)) (SeqType BoxType)) :qid |funType:Seq#FromArray| :pattern ( (|Seq#FromArray| arg0@@84 arg1@@36)) )))
(assert (forall ((h@@15 T@U) (a@@66 T@U) ) (!  (=> (and (= (type h@@15) (MapType1Type refType)) (= (type a@@66) refType)) (= (|Seq#Length| (|Seq#FromArray| h@@15 a@@66)) (_System.array.Length a@@66))) :qid |DafnyPre.919:15| :skolemid |520| :pattern ( (|Seq#Length| (|Seq#FromArray| h@@15 a@@66))) )))
(assert (forall ((h@@16 T@U) (a@@67 T@U) ) (!  (=> (and (= (type h@@16) (MapType1Type refType)) (= (type a@@67) refType)) (forall ((i@@20 Int) ) (!  (=> (and (<= 0 i@@20) (< i@@20 (|Seq#Length| (|Seq#FromArray| h@@16 a@@67)))) (= (|Seq#Index| (|Seq#FromArray| h@@16 a@@67) i@@20) (MapType1Select h@@16 a@@67 (IndexField i@@20)))) :qid |DafnyPre.924:11| :skolemid |521| :pattern ( (MapType1Select h@@16 a@@67 (IndexField i@@20))) :pattern ( (|Seq#Index| (|Seq#FromArray| h@@16 a@@67) i@@20)) ))) :qid |DafnyPre.922:15| :skolemid |522| :pattern ( (|Seq#FromArray| h@@16 a@@67)) )))
(assert (forall ((h0 T@U) (h1 T@U) (a@@68 T@U) ) (!  (=> (and (and (= (type h0) (MapType1Type refType)) (= (type h1) (MapType1Type refType))) (= (type a@@68) refType)) (=> (and (and (and ($IsGoodHeap h0) ($IsGoodHeap h1)) ($HeapSucc h0 h1)) (forall ((i@@21 Int) ) (!  (=> (and (<= 0 i@@21) (< i@@21 (_System.array.Length a@@68))) (= (MapType1Select h0 a@@68 (IndexField i@@21)) (MapType1Select h1 a@@68 (IndexField i@@21)))) :qid |DafnyPre.937:11| :skolemid |523| ))) (= (|Seq#FromArray| h0 a@@68) (|Seq#FromArray| h1 a@@68)))) :qid |DafnyPre.934:15| :skolemid |524| :pattern ( (|Seq#FromArray| h1 a@@68) ($HeapSucc h0 h1)) )))
(assert (forall ((h@@17 T@U) (i@@22 Int) (v@@30 T@U) (a@@69 T@U) ) (!  (=> (and (and (and (= (type h@@17) (MapType1Type refType)) (= (type v@@30) BoxType)) (= (type a@@69) refType)) (and (<= 0 i@@22) (< i@@22 (_System.array.Length a@@69)))) (= (|Seq#FromArray| (MapType1Store h@@17 a@@69 (IndexField i@@22) v@@30) a@@69) (|Seq#Update| (|Seq#FromArray| h@@17 a@@69) i@@22 v@@30))) :qid |DafnyPre.941:15| :skolemid |525| :pattern ( (|Seq#FromArray| (MapType1Store h@@17 a@@69 (IndexField i@@22) v@@30) a@@69)) )))
(assert (forall ((s@@33 T@U) (i@@23 Int) (v@@31 T@U) (n@@11 Int) ) (! (let ((T@@137 (type v@@31))) (=> (= (type s@@33) (SeqType T@@137)) (=> (and (and (<= 0 i@@23) (< i@@23 n@@11)) (<= n@@11 (|Seq#Length| s@@33))) (= (|Seq#Take| (|Seq#Update| s@@33 i@@23 v@@31) n@@11) (|Seq#Update| (|Seq#Take| s@@33 n@@11) i@@23 v@@31))))) :qid |DafnyPre.946:18| :skolemid |526| :pattern ( (|Seq#Take| (|Seq#Update| s@@33 i@@23 v@@31) n@@11)) )))
(assert (forall ((s@@34 T@U) (i@@24 Int) (v@@32 T@U) (n@@12 Int) ) (! (let ((T@@138 (type v@@32))) (=> (= (type s@@34) (SeqType T@@138)) (=> (and (<= n@@12 i@@24) (< i@@24 (|Seq#Length| s@@34))) (= (|Seq#Take| (|Seq#Update| s@@34 i@@24 v@@32) n@@12) (|Seq#Take| s@@34 n@@12))))) :qid |DafnyPre.949:18| :skolemid |527| :pattern ( (|Seq#Take| (|Seq#Update| s@@34 i@@24 v@@32) n@@12)) )))
(assert (forall ((s@@35 T@U) (i@@25 Int) (v@@33 T@U) (n@@13 Int) ) (! (let ((T@@139 (type v@@33))) (=> (= (type s@@35) (SeqType T@@139)) (=> (and (and (<= 0 n@@13) (<= n@@13 i@@25)) (< i@@25 (|Seq#Length| s@@35))) (= (|Seq#Drop| (|Seq#Update| s@@35 i@@25 v@@33) n@@13) (|Seq#Update| (|Seq#Drop| s@@35 n@@13) (- i@@25 n@@13) v@@33))))) :qid |DafnyPre.952:18| :skolemid |528| :pattern ( (|Seq#Drop| (|Seq#Update| s@@35 i@@25 v@@33) n@@13)) )))
(assert (forall ((s@@36 T@U) (i@@26 Int) (v@@34 T@U) (n@@14 Int) ) (! (let ((T@@140 (type v@@34))) (=> (= (type s@@36) (SeqType T@@140)) (=> (and (and (<= 0 i@@26) (< i@@26 n@@14)) (< n@@14 (|Seq#Length| s@@36))) (= (|Seq#Drop| (|Seq#Update| s@@36 i@@26 v@@34) n@@14) (|Seq#Drop| s@@36 n@@14))))) :qid |DafnyPre.955:18| :skolemid |529| :pattern ( (|Seq#Drop| (|Seq#Update| s@@36 i@@26 v@@34) n@@14)) )))
(assert (forall ((h@@18 T@U) (a@@70 T@U) (n0 Int) (n1 Int) ) (!  (=> (and (= (type h@@18) (MapType1Type refType)) (= (type a@@70) refType)) (=> (and (and (= (+ n0 1) n1) (<= 0 n0)) (<= n1 (_System.array.Length a@@70))) (= (|Seq#Take| (|Seq#FromArray| h@@18 a@@70) n1) (|Seq#Build| (|Seq#Take| (|Seq#FromArray| h@@18 a@@70) n0) (MapType1Select h@@18 a@@70 (IndexField n0)))))) :qid |DafnyPre.959:15| :skolemid |530| :pattern ( (|Seq#Take| (|Seq#FromArray| h@@18 a@@70) n0) (|Seq#Take| (|Seq#FromArray| h@@18 a@@70) n1)) )))
(assert (forall ((s@@37 T@U) (v@@35 T@U) (n@@15 Int) ) (! (let ((T@@141 (type v@@35))) (=> (= (type s@@37) (SeqType T@@141)) (=> (and (<= 0 n@@15) (<= n@@15 (|Seq#Length| s@@37))) (= (|Seq#Drop| (|Seq#Build| s@@37 v@@35) n@@15) (|Seq#Build| (|Seq#Drop| s@@37 n@@15) v@@35))))) :qid |DafnyPre.963:18| :skolemid |531| :pattern ( (|Seq#Drop| (|Seq#Build| s@@37 v@@35) n@@15)) )))
(assert (forall ((s@@38 T@U) (i@@27 Int) ) (!  (=> (= (type s@@38) (SeqType BoxType)) (=> (and (<= 0 i@@27) (< i@@27 (|Seq#Length| s@@38))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@38 i@@27))) (|Seq#Rank| s@@38)))) :qid |DafnyPre.968:15| :skolemid |532| :pattern ( (DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@38 i@@27)))) )))
(assert (forall ((s@@39 T@U) (i@@28 Int) ) (! (let ((T@@142 (SeqTypeInv0 (type s@@39)))) (=> (= (type s@@39) (SeqType T@@142)) (=> (and (< 0 i@@28) (<= i@@28 (|Seq#Length| s@@39))) (< (|Seq#Rank| (|Seq#Drop| s@@39 i@@28)) (|Seq#Rank| s@@39))))) :qid |DafnyPre.971:18| :skolemid |533| :pattern ( (|Seq#Rank| (|Seq#Drop| s@@39 i@@28))) )))
(assert (forall ((s@@40 T@U) (i@@29 Int) ) (! (let ((T@@143 (SeqTypeInv0 (type s@@40)))) (=> (= (type s@@40) (SeqType T@@143)) (=> (and (<= 0 i@@29) (< i@@29 (|Seq#Length| s@@40))) (< (|Seq#Rank| (|Seq#Take| s@@40 i@@29)) (|Seq#Rank| s@@40))))) :qid |DafnyPre.974:18| :skolemid |534| :pattern ( (|Seq#Rank| (|Seq#Take| s@@40 i@@29))) )))
(assert (forall ((s@@41 T@U) (i@@30 Int) (j@@5 Int) ) (! (let ((T@@144 (SeqTypeInv0 (type s@@41)))) (=> (= (type s@@41) (SeqType T@@144)) (=> (and (and (<= 0 i@@30) (< i@@30 j@@5)) (<= j@@5 (|Seq#Length| s@@41))) (< (|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@41 i@@30) (|Seq#Drop| s@@41 j@@5))) (|Seq#Rank| s@@41))))) :qid |DafnyPre.977:18| :skolemid |535| :pattern ( (|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@41 i@@30) (|Seq#Drop| s@@41 j@@5)))) )))
(assert (forall ((s@@42 T@U) (n@@16 Int) ) (! (let ((T@@145 (SeqTypeInv0 (type s@@42)))) (=> (and (= (type s@@42) (SeqType T@@145)) (= n@@16 0)) (= (|Seq#Drop| s@@42 n@@16) s@@42))) :qid |DafnyPre.982:18| :skolemid |536| :pattern ( (|Seq#Drop| s@@42 n@@16)) )))
(assert (forall ((s@@43 T@U) (n@@17 Int) ) (! (let ((T@@146 (SeqTypeInv0 (type s@@43)))) (=> (and (= (type s@@43) (SeqType T@@146)) (= n@@17 0)) (= (|Seq#Take| s@@43 n@@17) (|Seq#Empty| T@@146)))) :qid |DafnyPre.984:18| :skolemid |537| :pattern ( (|Seq#Take| s@@43 n@@17)) )))
(assert (forall ((s@@44 T@U) (m@@6 Int) (n@@18 Int) ) (! (let ((T@@147 (SeqTypeInv0 (type s@@44)))) (=> (= (type s@@44) (SeqType T@@147)) (=> (and (and (<= 0 m@@6) (<= 0 n@@18)) (<= (+ m@@6 n@@18) (|Seq#Length| s@@44))) (= (|Seq#Drop| (|Seq#Drop| s@@44 m@@6) n@@18) (|Seq#Drop| s@@44 (+ m@@6 n@@18)))))) :qid |DafnyPre.986:18| :skolemid |538| :pattern ( (|Seq#Drop| (|Seq#Drop| s@@44 m@@6) n@@18)) )))
(assert (forall ((m@@7 T@U) ) (! (let ((V@@1 (MapTypeInv1 (type m@@7)))) (let ((U@@3 (MapTypeInv0 (type m@@7)))) (=> (= (type m@@7) (MapType U@@3 V@@1)) (<= 0 (|Map#Card| m@@7))))) :qid |DafnyPre.1004:20| :skolemid |539| :pattern ( (|Map#Card| m@@7)) )))
(assert (forall ((m@@8 T@U) ) (! (let ((V@@2 (MapTypeInv1 (type m@@8)))) (let ((U@@4 (MapTypeInv0 (type m@@8)))) (=> (= (type m@@8) (MapType U@@4 V@@2)) (= (|Set#Card| (|Map#Domain| m@@8)) (|Map#Card| m@@8))))) :qid |DafnyPre.1009:20| :skolemid |540| :pattern ( (|Set#Card| (|Map#Domain| m@@8))) )))
(assert (forall ((arg0@@85 T@U) ) (! (let ((V@@3 (MapTypeInv1 (type arg0@@85)))) (= (type (|Map#Values| arg0@@85)) (MapType0Type V@@3 boolType))) :qid |funType:Map#Values| :pattern ( (|Map#Values| arg0@@85)) )))
(assert (forall ((m@@9 T@U) ) (! (let ((V@@4 (MapTypeInv1 (type m@@9)))) (let ((U@@5 (MapTypeInv0 (type m@@9)))) (=> (= (type m@@9) (MapType U@@5 V@@4)) (= (|Set#Card| (|Map#Values| m@@9)) (|Map#Card| m@@9))))) :qid |DafnyPre.1019:20| :skolemid |541| :pattern ( (|Set#Card| (|Map#Values| m@@9))) )))
(assert (forall ((m@@10 T@U) (v@@36 T@U) ) (! (let ((V@@5 (type v@@36))) (let ((U@@6 (MapTypeInv0 (type m@@10)))) (=> (= (type m@@10) (MapType U@@6 V@@5)) (and (=> (U_2_bool (MapType0Select (|Map#Values| m@@10) v@@36)) (exists ((u@@5 T@U) ) (!  (and (= (type u@@5) U@@6) (and (U_2_bool (MapType0Select (|Map#Domain| m@@10) u@@5)) (= v@@36 (MapType0Select (|Map#Elements| m@@10) u@@5)))) :qid |DafnyPre.1024:10| :skolemid |542| :pattern ( (MapType0Select (|Map#Domain| m@@10) u@@5)) :pattern ( (MapType0Select (|Map#Elements| m@@10) u@@5)) ))) (=> (exists ((u@@6 T@U) ) (!  (and (= (type u@@6) U@@6) (and (U_2_bool (MapType0Select (|Map#Domain| m@@10) u@@6)) (= v@@36 (MapType0Select (|Map#Elements| m@@10) u@@6)))) :qid |DafnyPre.1024:10| :skolemid |542| :pattern ( (MapType0Select (|Map#Domain| m@@10) u@@6)) :pattern ( (MapType0Select (|Map#Elements| m@@10) u@@6)) )) (U_2_bool (MapType0Select (|Map#Values| m@@10) v@@36))))))) :qid |DafnyPre.1022:20| :skolemid |543| :pattern ( (MapType0Select (|Map#Values| m@@10) v@@36)) )))
(assert (forall ((arg0@@86 T@U) ) (! (= (type (|Map#Items| arg0@@86)) (MapType0Type BoxType boolType)) :qid |funType:Map#Items| :pattern ( (|Map#Items| arg0@@86)) )))
(assert (forall ((m@@11 T@U) ) (! (let ((V@@6 (MapTypeInv1 (type m@@11)))) (let ((U@@7 (MapTypeInv0 (type m@@11)))) (=> (= (type m@@11) (MapType U@@7 V@@6)) (= (|Set#Card| (|Map#Items| m@@11)) (|Map#Card| m@@11))))) :qid |DafnyPre.1043:20| :skolemid |544| :pattern ( (|Set#Card| (|Map#Items| m@@11))) )))
(assert  (and (forall ((arg0@@87 T@U) ) (! (= (type (_System.__tuple_h2._0 arg0@@87)) BoxType) :qid |funType:_System.__tuple_h2._0| :pattern ( (_System.__tuple_h2._0 arg0@@87)) )) (forall ((arg0@@88 T@U) ) (! (= (type (_System.__tuple_h2._1 arg0@@88)) BoxType) :qid |funType:_System.__tuple_h2._1| :pattern ( (_System.__tuple_h2._1 arg0@@88)) ))))
(assert (forall ((m@@12 T@U) (item T@U) ) (!  (=> (and (= (type m@@12) (MapType BoxType BoxType)) (= (type item) BoxType)) (and (=> (U_2_bool (MapType0Select (|Map#Items| m@@12) item)) (and (U_2_bool (MapType0Select (|Map#Domain| m@@12) (_System.__tuple_h2._0 ($Unbox DatatypeTypeType item)))) (= (MapType0Select (|Map#Elements| m@@12) (_System.__tuple_h2._0 ($Unbox DatatypeTypeType item))) (_System.__tuple_h2._1 ($Unbox DatatypeTypeType item))))) (=> (and (U_2_bool (MapType0Select (|Map#Domain| m@@12) (_System.__tuple_h2._0 ($Unbox DatatypeTypeType item)))) (= (MapType0Select (|Map#Elements| m@@12) (_System.__tuple_h2._0 ($Unbox DatatypeTypeType item))) (_System.__tuple_h2._1 ($Unbox DatatypeTypeType item)))) (U_2_bool (MapType0Select (|Map#Items| m@@12) item))))) :qid |DafnyPre.1046:15| :skolemid |545| :pattern ( (MapType0Select (|Map#Items| m@@12) item)) )))
(assert (forall ((U@@8 T@T) (V@@7 T@T) ) (! (= (type (|Map#Empty| U@@8 V@@7)) (MapType U@@8 V@@7)) :qid |funType:Map#Empty| :pattern ( (|Map#Empty| U@@8 V@@7)) )))
(assert (forall ((u@@7 T@U) (V@@8 T@T) ) (! (let ((U@@9 (type u@@7))) (not (U_2_bool (MapType0Select (|Map#Domain| (|Map#Empty| U@@9 V@@8)) u@@7)))) :qid |DafnyPre.1054:21| :skolemid |546| :pattern ( (let ((U@@9 (type u@@7))) (MapType0Select (|Map#Domain| (|Map#Empty| U@@9 V@@8)) u@@7))) )))
(assert (forall ((m@@13 T@U) ) (! (let ((V@@9 (MapTypeInv1 (type m@@13)))) (let ((U@@10 (MapTypeInv0 (type m@@13)))) (=> (= (type m@@13) (MapType U@@10 V@@9)) (and (and (=> (= (|Map#Card| m@@13) 0) (= m@@13 (|Map#Empty| U@@10 V@@9))) (=> (= m@@13 (|Map#Empty| U@@10 V@@9)) (= (|Map#Card| m@@13) 0))) (=> (not (= (|Map#Card| m@@13) 0)) (exists ((x@@39 T@U) ) (!  (and (= (type x@@39) U@@10) (U_2_bool (MapType0Select (|Map#Domain| m@@13) x@@39))) :qid |DafnyPre.1059:32| :skolemid |547| :no-pattern (type x@@39) :no-pattern (U_2_int x@@39) :no-pattern (U_2_bool x@@39) ))))))) :qid |DafnyPre.1057:21| :skolemid |548| :pattern ( (|Map#Card| m@@13)) )))
(assert (forall ((arg0@@89 T@U) (arg1@@37 T@U) (arg2@@3 T@U) ) (! (let ((V@@10 (MapType0TypeInv1 (type arg1@@37)))) (let ((U@@11 (MapType0TypeInv0 (type arg0@@89)))) (= (type (|Map#Glue| arg0@@89 arg1@@37 arg2@@3)) (MapType U@@11 V@@10)))) :qid |funType:Map#Glue| :pattern ( (|Map#Glue| arg0@@89 arg1@@37 arg2@@3)) )))
(assert (forall ((a@@71 T@U) (b@@50 T@U) (t@@29 T@U) ) (! (let ((V@@11 (MapType0TypeInv1 (type b@@50)))) (let ((U@@12 (MapType0TypeInv0 (type a@@71)))) (=> (and (and (= (type a@@71) (MapType0Type U@@12 boolType)) (= (type b@@50) (MapType0Type U@@12 V@@11))) (= (type t@@29) TyType)) (= (|Map#Domain| (|Map#Glue| a@@71 b@@50 t@@29)) a@@71)))) :qid |DafnyPre.1062:21| :skolemid |549| :pattern ( (|Map#Domain| (|Map#Glue| a@@71 b@@50 t@@29))) )))
(assert (forall ((a@@72 T@U) (b@@51 T@U) (t@@30 T@U) ) (! (let ((V@@12 (MapType0TypeInv1 (type b@@51)))) (let ((U@@13 (MapType0TypeInv0 (type a@@72)))) (=> (and (and (= (type a@@72) (MapType0Type U@@13 boolType)) (= (type b@@51) (MapType0Type U@@13 V@@12))) (= (type t@@30) TyType)) (= (|Map#Elements| (|Map#Glue| a@@72 b@@51 t@@30)) b@@51)))) :qid |DafnyPre.1065:21| :skolemid |550| :pattern ( (|Map#Elements| (|Map#Glue| a@@72 b@@51 t@@30))) )))
(assert (forall ((a@@73 T@U) (b@@52 T@U) (t@@31 T@U) ) (! (let ((V@@13 (MapType0TypeInv1 (type b@@52)))) (let ((U@@14 (MapType0TypeInv0 (type a@@73)))) (=> (and (and (= (type a@@73) (MapType0Type U@@14 boolType)) (= (type b@@52) (MapType0Type U@@14 V@@13))) (= (type t@@31) TyType)) ($Is (|Map#Glue| a@@73 b@@52 t@@31) t@@31)))) :qid |DafnyPre.1068:21| :skolemid |551| :pattern ( ($Is (|Map#Glue| a@@73 b@@52 t@@31) t@@31)) )))
(assert (forall ((arg0@@90 T@U) (arg1@@38 T@U) (arg2@@4 T@U) ) (! (let ((V@@14 (type arg2@@4))) (let ((U@@15 (type arg1@@38))) (= (type (|Map#Build| arg0@@90 arg1@@38 arg2@@4)) (MapType U@@15 V@@14)))) :qid |funType:Map#Build| :pattern ( (|Map#Build| arg0@@90 arg1@@38 arg2@@4)) )))
(assert (forall ((m@@14 T@U) (u@@8 T@U) (|u'| T@U) (v@@37 T@U) ) (! (let ((V@@15 (type v@@37))) (let ((U@@16 (type u@@8))) (=> (and (= (type m@@14) (MapType U@@16 V@@15)) (= (type |u'|) U@@16)) (and (=> (= |u'| u@@8) (and (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@14 u@@8 v@@37)) |u'|)) (= (MapType0Select (|Map#Elements| (|Map#Build| m@@14 u@@8 v@@37)) |u'|) v@@37))) (=> (not (= |u'| u@@8)) (and (and (=> (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@14 u@@8 v@@37)) |u'|)) (U_2_bool (MapType0Select (|Map#Domain| m@@14) |u'|))) (=> (U_2_bool (MapType0Select (|Map#Domain| m@@14) |u'|)) (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@14 u@@8 v@@37)) |u'|)))) (= (MapType0Select (|Map#Elements| (|Map#Build| m@@14 u@@8 v@@37)) |u'|) (MapType0Select (|Map#Elements| m@@14) |u'|)))))))) :qid |DafnyPre.1079:21| :skolemid |552| :pattern ( (MapType0Select (|Map#Domain| (|Map#Build| m@@14 u@@8 v@@37)) |u'|)) :pattern ( (MapType0Select (|Map#Elements| (|Map#Build| m@@14 u@@8 v@@37)) |u'|)) )))
(assert (forall ((m@@15 T@U) (u@@9 T@U) (v@@38 T@U) ) (! (let ((V@@16 (type v@@38))) (let ((U@@17 (type u@@9))) (=> (and (= (type m@@15) (MapType U@@17 V@@16)) (U_2_bool (MapType0Select (|Map#Domain| m@@15) u@@9))) (= (|Map#Card| (|Map#Build| m@@15 u@@9 v@@38)) (|Map#Card| m@@15))))) :qid |DafnyPre.1085:21| :skolemid |553| :pattern ( (|Map#Card| (|Map#Build| m@@15 u@@9 v@@38))) )))
(assert (forall ((m@@16 T@U) (u@@10 T@U) (v@@39 T@U) ) (! (let ((V@@17 (type v@@39))) (let ((U@@18 (type u@@10))) (=> (and (= (type m@@16) (MapType U@@18 V@@17)) (not (U_2_bool (MapType0Select (|Map#Domain| m@@16) u@@10)))) (= (|Map#Card| (|Map#Build| m@@16 u@@10 v@@39)) (+ (|Map#Card| m@@16) 1))))) :qid |DafnyPre.1087:21| :skolemid |554| :pattern ( (|Map#Card| (|Map#Build| m@@16 u@@10 v@@39))) )))
(assert (forall ((m@@17 T@U) (u@@11 T@U) (v@@40 T@U) ) (! (let ((V@@18 (type v@@40))) (let ((U@@19 (type u@@11))) (=> (= (type m@@17) (MapType U@@19 V@@18)) (= (|Map#Values| (|Map#Build| m@@17 u@@11 v@@40)) (|Set#UnionOne| (|Map#Values| m@@17) v@@40))))) :qid |DafnyPre.1089:21| :skolemid |555| :pattern ( (|Map#Values| (|Map#Build| m@@17 u@@11 v@@40))) )))
(assert (forall ((m@@18 T@U) (|m'| T@U) ) (! (let ((V@@19 (MapTypeInv1 (type m@@18)))) (let ((U@@20 (MapTypeInv0 (type m@@18)))) (=> (and (= (type m@@18) (MapType U@@20 V@@19)) (= (type |m'|) (MapType U@@20 V@@19))) (and (=> (|Map#Equal| m@@18 |m'|) (and (forall ((u@@12 T@U) ) (!  (=> (= (type u@@12) U@@20) (and (=> (U_2_bool (MapType0Select (|Map#Domain| m@@18) u@@12)) (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@12))) (=> (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@12)) (U_2_bool (MapType0Select (|Map#Domain| m@@18) u@@12))))) :qid |DafnyPre.1097:35| :skolemid |556| :no-pattern (type u@@12) :no-pattern (U_2_int u@@12) :no-pattern (U_2_bool u@@12) )) (forall ((u@@13 T@U) ) (!  (=> (and (= (type u@@13) U@@20) (U_2_bool (MapType0Select (|Map#Domain| m@@18) u@@13))) (= (MapType0Select (|Map#Elements| m@@18) u@@13) (MapType0Select (|Map#Elements| |m'|) u@@13))) :qid |DafnyPre.1098:35| :skolemid |557| :no-pattern (type u@@13) :no-pattern (U_2_int u@@13) :no-pattern (U_2_bool u@@13) )))) (=> (and (forall ((u@@14 T@U) ) (!  (=> (= (type u@@14) U@@20) (and (=> (U_2_bool (MapType0Select (|Map#Domain| m@@18) u@@14)) (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@14))) (=> (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@14)) (U_2_bool (MapType0Select (|Map#Domain| m@@18) u@@14))))) :qid |DafnyPre.1097:35| :skolemid |556| :no-pattern (type u@@14) :no-pattern (U_2_int u@@14) :no-pattern (U_2_bool u@@14) )) (forall ((u@@15 T@U) ) (!  (=> (and (= (type u@@15) U@@20) (U_2_bool (MapType0Select (|Map#Domain| m@@18) u@@15))) (= (MapType0Select (|Map#Elements| m@@18) u@@15) (MapType0Select (|Map#Elements| |m'|) u@@15))) :qid |DafnyPre.1098:35| :skolemid |557| :no-pattern (type u@@15) :no-pattern (U_2_int u@@15) :no-pattern (U_2_bool u@@15) ))) (|Map#Equal| m@@18 |m'|)))))) :qid |DafnyPre.1095:21| :skolemid |558| :pattern ( (|Map#Equal| m@@18 |m'|)) )))
(assert (forall ((m@@19 T@U) (|m'@@0| T@U) ) (! (let ((V@@20 (MapTypeInv1 (type m@@19)))) (let ((U@@21 (MapTypeInv0 (type m@@19)))) (=> (and (and (= (type m@@19) (MapType U@@21 V@@20)) (= (type |m'@@0|) (MapType U@@21 V@@20))) (|Map#Equal| m@@19 |m'@@0|)) (= m@@19 |m'@@0|)))) :qid |DafnyPre.1100:21| :skolemid |559| :pattern ( (|Map#Equal| m@@19 |m'@@0|)) )))
(assert (forall ((m@@20 T@U) (|m'@@1| T@U) ) (! (let ((V@@21 (MapTypeInv1 (type m@@20)))) (let ((U@@22 (MapTypeInv0 (type m@@20)))) (=> (and (= (type m@@20) (MapType U@@22 V@@21)) (= (type |m'@@1|) (MapType U@@22 V@@21))) (and (=> (|Map#Disjoint| m@@20 |m'@@1|) (forall ((o@@37 T@U) ) (!  (=> (= (type o@@37) U@@22) (or (not (U_2_bool (MapType0Select (|Map#Domain| m@@20) o@@37))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'@@1|) o@@37))))) :qid |DafnyPre.1107:38| :skolemid |560| :pattern ( (MapType0Select (|Map#Domain| m@@20) o@@37)) :pattern ( (MapType0Select (|Map#Domain| |m'@@1|) o@@37)) ))) (=> (forall ((o@@38 T@U) ) (!  (=> (= (type o@@38) U@@22) (or (not (U_2_bool (MapType0Select (|Map#Domain| m@@20) o@@38))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'@@1|) o@@38))))) :qid |DafnyPre.1107:38| :skolemid |560| :pattern ( (MapType0Select (|Map#Domain| m@@20) o@@38)) :pattern ( (MapType0Select (|Map#Domain| |m'@@1|) o@@38)) )) (|Map#Disjoint| m@@20 |m'@@1|)))))) :qid |DafnyPre.1105:21| :skolemid |561| :pattern ( (|Map#Disjoint| m@@20 |m'@@1|)) )))
(assert (forall ((arg0@@91 T@U) ) (! (let ((V@@22 (IMapTypeInv1 (type arg0@@91)))) (= (type (|IMap#Values| arg0@@91)) (MapType0Type V@@22 boolType))) :qid |funType:IMap#Values| :pattern ( (|IMap#Values| arg0@@91)) )))
(assert (forall ((m@@21 T@U) (v@@41 T@U) ) (! (let ((V@@23 (type v@@41))) (let ((U@@23 (IMapTypeInv0 (type m@@21)))) (=> (= (type m@@21) (IMapType U@@23 V@@23)) (and (=> (U_2_bool (MapType0Select (|IMap#Values| m@@21) v@@41)) (exists ((u@@16 T@U) ) (!  (and (= (type u@@16) U@@23) (and (U_2_bool (MapType0Select (|IMap#Domain| m@@21) u@@16)) (= v@@41 (MapType0Select (|IMap#Elements| m@@21) u@@16)))) :qid |DafnyPre.1130:10| :skolemid |562| :pattern ( (MapType0Select (|IMap#Domain| m@@21) u@@16)) :pattern ( (MapType0Select (|IMap#Elements| m@@21) u@@16)) ))) (=> (exists ((u@@17 T@U) ) (!  (and (= (type u@@17) U@@23) (and (U_2_bool (MapType0Select (|IMap#Domain| m@@21) u@@17)) (= v@@41 (MapType0Select (|IMap#Elements| m@@21) u@@17)))) :qid |DafnyPre.1130:10| :skolemid |562| :pattern ( (MapType0Select (|IMap#Domain| m@@21) u@@17)) :pattern ( (MapType0Select (|IMap#Elements| m@@21) u@@17)) )) (U_2_bool (MapType0Select (|IMap#Values| m@@21) v@@41))))))) :qid |DafnyPre.1128:20| :skolemid |563| :pattern ( (MapType0Select (|IMap#Values| m@@21) v@@41)) )))
(assert (forall ((arg0@@92 T@U) ) (! (= (type (|IMap#Items| arg0@@92)) (MapType0Type BoxType boolType)) :qid |funType:IMap#Items| :pattern ( (|IMap#Items| arg0@@92)) )))
(assert (forall ((m@@22 T@U) (item@@0 T@U) ) (!  (=> (and (= (type m@@22) (IMapType BoxType BoxType)) (= (type item@@0) BoxType)) (and (=> (U_2_bool (MapType0Select (|IMap#Items| m@@22) item@@0)) (and (U_2_bool (MapType0Select (|IMap#Domain| m@@22) (_System.__tuple_h2._0 ($Unbox DatatypeTypeType item@@0)))) (= (MapType0Select (|IMap#Elements| m@@22) (_System.__tuple_h2._0 ($Unbox DatatypeTypeType item@@0))) (_System.__tuple_h2._1 ($Unbox DatatypeTypeType item@@0))))) (=> (and (U_2_bool (MapType0Select (|IMap#Domain| m@@22) (_System.__tuple_h2._0 ($Unbox DatatypeTypeType item@@0)))) (= (MapType0Select (|IMap#Elements| m@@22) (_System.__tuple_h2._0 ($Unbox DatatypeTypeType item@@0))) (_System.__tuple_h2._1 ($Unbox DatatypeTypeType item@@0)))) (U_2_bool (MapType0Select (|IMap#Items| m@@22) item@@0))))) :qid |DafnyPre.1145:15| :skolemid |564| :pattern ( (MapType0Select (|IMap#Items| m@@22) item@@0)) )))
(assert (forall ((U@@24 T@T) (V@@24 T@T) ) (! (= (type (|IMap#Empty| U@@24 V@@24)) (IMapType U@@24 V@@24)) :qid |funType:IMap#Empty| :pattern ( (|IMap#Empty| U@@24 V@@24)) )))
(assert (forall ((u@@18 T@U) (V@@25 T@T) ) (! (let ((U@@25 (type u@@18))) (not (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Empty| U@@25 V@@25)) u@@18)))) :qid |DafnyPre.1152:21| :skolemid |565| :pattern ( (let ((U@@25 (type u@@18))) (MapType0Select (|IMap#Domain| (|IMap#Empty| U@@25 V@@25)) u@@18))) )))
(assert (forall ((arg0@@93 T@U) (arg1@@39 T@U) (arg2@@5 T@U) ) (! (let ((V@@26 (MapType0TypeInv1 (type arg1@@39)))) (let ((U@@26 (MapType0TypeInv0 (type arg0@@93)))) (= (type (|IMap#Glue| arg0@@93 arg1@@39 arg2@@5)) (IMapType U@@26 V@@26)))) :qid |funType:IMap#Glue| :pattern ( (|IMap#Glue| arg0@@93 arg1@@39 arg2@@5)) )))
(assert (forall ((a@@74 T@U) (b@@53 T@U) (t@@32 T@U) ) (! (let ((V@@27 (MapType0TypeInv1 (type b@@53)))) (let ((U@@27 (MapType0TypeInv0 (type a@@74)))) (=> (and (and (= (type a@@74) (MapType0Type U@@27 boolType)) (= (type b@@53) (MapType0Type U@@27 V@@27))) (= (type t@@32) TyType)) (= (|IMap#Domain| (|IMap#Glue| a@@74 b@@53 t@@32)) a@@74)))) :qid |DafnyPre.1157:21| :skolemid |566| :pattern ( (|IMap#Domain| (|IMap#Glue| a@@74 b@@53 t@@32))) )))
(assert (forall ((a@@75 T@U) (b@@54 T@U) (t@@33 T@U) ) (! (let ((V@@28 (MapType0TypeInv1 (type b@@54)))) (let ((U@@28 (MapType0TypeInv0 (type a@@75)))) (=> (and (and (= (type a@@75) (MapType0Type U@@28 boolType)) (= (type b@@54) (MapType0Type U@@28 V@@28))) (= (type t@@33) TyType)) (= (|IMap#Elements| (|IMap#Glue| a@@75 b@@54 t@@33)) b@@54)))) :qid |DafnyPre.1160:21| :skolemid |567| :pattern ( (|IMap#Elements| (|IMap#Glue| a@@75 b@@54 t@@33))) )))
(assert (forall ((a@@76 T@U) (b@@55 T@U) (t@@34 T@U) ) (! (let ((V@@29 (MapType0TypeInv1 (type b@@55)))) (let ((U@@29 (MapType0TypeInv0 (type a@@76)))) (=> (and (and (= (type a@@76) (MapType0Type U@@29 boolType)) (= (type b@@55) (MapType0Type U@@29 V@@29))) (= (type t@@34) TyType)) ($Is (|IMap#Glue| a@@76 b@@55 t@@34) t@@34)))) :qid |DafnyPre.1163:21| :skolemid |568| :pattern ( ($Is (|IMap#Glue| a@@76 b@@55 t@@34) t@@34)) )))
(assert (forall ((arg0@@94 T@U) (arg1@@40 T@U) (arg2@@6 T@U) ) (! (let ((V@@30 (type arg2@@6))) (let ((U@@30 (type arg1@@40))) (= (type (|IMap#Build| arg0@@94 arg1@@40 arg2@@6)) (IMapType U@@30 V@@30)))) :qid |funType:IMap#Build| :pattern ( (|IMap#Build| arg0@@94 arg1@@40 arg2@@6)) )))
(assert (forall ((m@@23 T@U) (u@@19 T@U) (|u'@@0| T@U) (v@@42 T@U) ) (! (let ((V@@31 (type v@@42))) (let ((U@@31 (type u@@19))) (=> (and (= (type m@@23) (IMapType U@@31 V@@31)) (= (type |u'@@0|) U@@31)) (and (=> (= |u'@@0| u@@19) (and (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@23 u@@19 v@@42)) |u'@@0|)) (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@23 u@@19 v@@42)) |u'@@0|) v@@42))) (=> (not (= |u'@@0| u@@19)) (and (and (=> (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@23 u@@19 v@@42)) |u'@@0|)) (U_2_bool (MapType0Select (|IMap#Domain| m@@23) |u'@@0|))) (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@23) |u'@@0|)) (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@23 u@@19 v@@42)) |u'@@0|)))) (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@23 u@@19 v@@42)) |u'@@0|) (MapType0Select (|IMap#Elements| m@@23) |u'@@0|)))))))) :qid |DafnyPre.1173:21| :skolemid |569| :pattern ( (MapType0Select (|IMap#Domain| (|IMap#Build| m@@23 u@@19 v@@42)) |u'@@0|)) :pattern ( (MapType0Select (|IMap#Elements| (|IMap#Build| m@@23 u@@19 v@@42)) |u'@@0|)) )))
(assert (forall ((m@@24 T@U) (u@@20 T@U) (v@@43 T@U) ) (! (let ((V@@32 (type v@@43))) (let ((U@@32 (type u@@20))) (=> (= (type m@@24) (IMapType U@@32 V@@32)) (= (|IMap#Values| (|IMap#Build| m@@24 u@@20 v@@43)) (|Set#UnionOne| (|IMap#Values| m@@24) v@@43))))) :qid |DafnyPre.1180:21| :skolemid |570| :pattern ( (|IMap#Values| (|IMap#Build| m@@24 u@@20 v@@43))) )))
(assert (forall ((m@@25 T@U) (|m'@@2| T@U) ) (! (let ((V@@33 (IMapTypeInv1 (type m@@25)))) (let ((U@@33 (IMapTypeInv0 (type m@@25)))) (=> (and (= (type m@@25) (IMapType U@@33 V@@33)) (= (type |m'@@2|) (IMapType U@@33 V@@33))) (and (=> (|IMap#Equal| m@@25 |m'@@2|) (and (forall ((u@@21 T@U) ) (!  (=> (= (type u@@21) U@@33) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@25) u@@21)) (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@21))) (=> (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@21)) (U_2_bool (MapType0Select (|IMap#Domain| m@@25) u@@21))))) :qid |DafnyPre.1187:36| :skolemid |571| :no-pattern (type u@@21) :no-pattern (U_2_int u@@21) :no-pattern (U_2_bool u@@21) )) (forall ((u@@22 T@U) ) (!  (=> (and (= (type u@@22) U@@33) (U_2_bool (MapType0Select (|IMap#Domain| m@@25) u@@22))) (= (MapType0Select (|IMap#Elements| m@@25) u@@22) (MapType0Select (|IMap#Elements| |m'@@2|) u@@22))) :qid |DafnyPre.1188:35| :skolemid |572| :no-pattern (type u@@22) :no-pattern (U_2_int u@@22) :no-pattern (U_2_bool u@@22) )))) (=> (and (forall ((u@@23 T@U) ) (!  (=> (= (type u@@23) U@@33) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@25) u@@23)) (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@23))) (=> (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@23)) (U_2_bool (MapType0Select (|IMap#Domain| m@@25) u@@23))))) :qid |DafnyPre.1187:36| :skolemid |571| :no-pattern (type u@@23) :no-pattern (U_2_int u@@23) :no-pattern (U_2_bool u@@23) )) (forall ((u@@24 T@U) ) (!  (=> (and (= (type u@@24) U@@33) (U_2_bool (MapType0Select (|IMap#Domain| m@@25) u@@24))) (= (MapType0Select (|IMap#Elements| m@@25) u@@24) (MapType0Select (|IMap#Elements| |m'@@2|) u@@24))) :qid |DafnyPre.1188:35| :skolemid |572| :no-pattern (type u@@24) :no-pattern (U_2_int u@@24) :no-pattern (U_2_bool u@@24) ))) (|IMap#Equal| m@@25 |m'@@2|)))))) :qid |DafnyPre.1185:21| :skolemid |573| :pattern ( (|IMap#Equal| m@@25 |m'@@2|)) )))
(assert (forall ((m@@26 T@U) (|m'@@3| T@U) ) (! (let ((V@@34 (IMapTypeInv1 (type m@@26)))) (let ((U@@34 (IMapTypeInv0 (type m@@26)))) (=> (and (and (= (type m@@26) (IMapType U@@34 V@@34)) (= (type |m'@@3|) (IMapType U@@34 V@@34))) (|IMap#Equal| m@@26 |m'@@3|)) (= m@@26 |m'@@3|)))) :qid |DafnyPre.1190:21| :skolemid |574| :pattern ( (|IMap#Equal| m@@26 |m'@@3|)) )))
(assert (forall ((x@@40 Int) (y@@12 Int) ) (! (= (INTERNAL_add_boogie x@@40 y@@12) (+ x@@40 y@@12)) :qid |DafnyPre.1198:30| :skolemid |575| :pattern ( (INTERNAL_add_boogie x@@40 y@@12)) )))
(assert (forall ((x@@41 Int) (y@@13 Int) ) (! (= (INTERNAL_sub_boogie x@@41 y@@13) (- x@@41 y@@13)) :qid |DafnyPre.1199:30| :skolemid |576| :pattern ( (INTERNAL_sub_boogie x@@41 y@@13)) )))
(assert (forall ((x@@42 Int) (y@@14 Int) ) (! (= (INTERNAL_mul_boogie x@@42 y@@14) (* x@@42 y@@14)) :qid |DafnyPre.1200:30| :skolemid |577| :pattern ( (INTERNAL_mul_boogie x@@42 y@@14)) )))
(assert (forall ((x@@43 Int) (y@@15 Int) ) (! (= (INTERNAL_div_boogie x@@43 y@@15) (div x@@43 y@@15)) :qid |DafnyPre.1201:30| :skolemid |578| :pattern ( (INTERNAL_div_boogie x@@43 y@@15)) )))
(assert (forall ((x@@44 Int) (y@@16 Int) ) (! (= (INTERNAL_mod_boogie x@@44 y@@16) (mod x@@44 y@@16)) :qid |DafnyPre.1202:30| :skolemid |579| :pattern ( (INTERNAL_mod_boogie x@@44 y@@16)) )))
(assert (forall ((x@@45 Int) (y@@17 Int) ) (!  (and (=> (INTERNAL_lt_boogie x@@45 y@@17) (< x@@45 y@@17)) (=> (< x@@45 y@@17) (INTERNAL_lt_boogie x@@45 y@@17))) :qid |DafnyPre.1203:51| :skolemid |580| :pattern ( (INTERNAL_lt_boogie x@@45 y@@17)) )))
(assert (forall ((x@@46 Int) (y@@18 Int) ) (!  (and (=> (INTERNAL_le_boogie x@@46 y@@18) (<= x@@46 y@@18)) (=> (<= x@@46 y@@18) (INTERNAL_le_boogie x@@46 y@@18))) :qid |DafnyPre.1204:51| :skolemid |581| :pattern ( (INTERNAL_le_boogie x@@46 y@@18)) )))
(assert (forall ((x@@47 Int) (y@@19 Int) ) (!  (and (=> (INTERNAL_gt_boogie x@@47 y@@19) (> x@@47 y@@19)) (=> (> x@@47 y@@19) (INTERNAL_gt_boogie x@@47 y@@19))) :qid |DafnyPre.1205:51| :skolemid |582| :pattern ( (INTERNAL_gt_boogie x@@47 y@@19)) )))
(assert (forall ((x@@48 Int) (y@@20 Int) ) (!  (and (=> (INTERNAL_ge_boogie x@@48 y@@20) (>= x@@48 y@@20)) (=> (>= x@@48 y@@20) (INTERNAL_ge_boogie x@@48 y@@20))) :qid |DafnyPre.1206:51| :skolemid |583| :pattern ( (INTERNAL_ge_boogie x@@48 y@@20)) )))
(assert (forall ((b@@56 (_ BitVec 32)) ) (!  (and (and (<= 0 (nat_from_bv32 b@@56)) (< (nat_from_bv32 b@@56) 4294967296)) (= (nat_from_bv32 b@@56) (bv2int b@@56))) :qid |unknown.0:0| :skolemid |584| :pattern ( (nat_from_bv32 b@@56)) )))
(assert (= (type Tclass._System.nat) TyType))
(assert (= (Tag Tclass._System.nat) Tagclass._System.nat))
(assert (forall ((bx@@34 T@U) ) (!  (=> (and (= (type bx@@34) BoxType) ($IsBox bx@@34 Tclass._System.nat)) (and (= ($Box ($Unbox intType bx@@34)) bx@@34) ($Is ($Unbox intType bx@@34) Tclass._System.nat))) :qid |unknown.0:0| :skolemid |585| :pattern ( ($IsBox bx@@34 Tclass._System.nat)) )))
(assert (forall ((|x#0| T@U) ) (!  (=> (= (type |x#0|) intType) (and (=> ($Is |x#0| Tclass._System.nat) (INTERNAL_le_boogie 0 (U_2_int |x#0|))) (=> (INTERNAL_le_boogie 0 (U_2_int |x#0|)) ($Is |x#0| Tclass._System.nat)))) :qid |unknown.0:0| :skolemid |586| :pattern ( ($Is |x#0| Tclass._System.nat)) )))
(assert (forall ((|x#0@@0| T@U) ($h T@U) ) (!  (=> (and (= (type |x#0@@0|) intType) (= (type $h) (MapType1Type refType))) ($IsAlloc |x#0@@0| Tclass._System.nat $h)) :qid |unknown.0:0| :skolemid |587| :pattern ( ($IsAlloc |x#0@@0| Tclass._System.nat $h)) )))
(assert (= (Tag Tclass._System.object) Tagclass._System.object))
(assert (forall ((bx@@35 T@U) ) (!  (=> (and (= (type bx@@35) BoxType) ($IsBox bx@@35 Tclass._System.object)) (and (= ($Box ($Unbox refType bx@@35)) bx@@35) ($Is ($Unbox refType bx@@35) Tclass._System.object))) :qid |unknown.0:0| :skolemid |588| :pattern ( ($IsBox bx@@35 Tclass._System.object)) )))
(assert (forall (($o T@U) ) (!  (=> (= (type $o) refType) ($Is $o Tclass._System.object)) :qid |unknown.0:0| :skolemid |589| :pattern ( ($Is $o Tclass._System.object)) )))
(assert (= (type null) refType))
(assert (forall (($o@@0 T@U) ($h@@0 T@U) ) (!  (=> (and (= (type $o@@0) refType) (= (type $h@@0) (MapType1Type refType))) (and (=> ($IsAlloc $o@@0 Tclass._System.object $h@@0) (or (= $o@@0 null) (U_2_bool (MapType1Select $h@@0 $o@@0 alloc)))) (=> (or (= $o@@0 null) (U_2_bool (MapType1Select $h@@0 $o@@0 alloc))) ($IsAlloc $o@@0 Tclass._System.object $h@@0)))) :qid |unknown.0:0| :skolemid |590| :pattern ( ($IsAlloc $o@@0 Tclass._System.object $h@@0)) )))
(assert (forall ((arg0@@95 T@U) ) (! (= (type (Tclass._System.array arg0@@95)) TyType) :qid |funType:Tclass._System.array| :pattern ( (Tclass._System.array arg0@@95)) )))
(assert (forall ((|#$arg| T@U) ) (!  (=> (= (type |#$arg|) TyType) (= (Tag (Tclass._System.array |#$arg|)) Tagclass._System.array)) :qid |unknown.0:0| :skolemid |591| :pattern ( (Tclass._System.array |#$arg|)) )))
(assert (forall ((arg0@@96 T@U) ) (! (= (type (Tclass._System.array_0 arg0@@96)) TyType) :qid |funType:Tclass._System.array_0| :pattern ( (Tclass._System.array_0 arg0@@96)) )))
(assert (forall ((|#$arg@@0| T@U) ) (!  (=> (= (type |#$arg@@0|) TyType) (= (Tclass._System.array_0 (Tclass._System.array |#$arg@@0|)) |#$arg@@0|)) :qid |unknown.0:0| :skolemid |592| :pattern ( (Tclass._System.array |#$arg@@0|)) )))
(assert (forall ((|#$arg@@1| T@U) (bx@@36 T@U) ) (!  (=> (and (and (= (type |#$arg@@1|) TyType) (= (type bx@@36) BoxType)) ($IsBox bx@@36 (Tclass._System.array |#$arg@@1|))) (and (= ($Box ($Unbox refType bx@@36)) bx@@36) ($Is ($Unbox refType bx@@36) (Tclass._System.array |#$arg@@1|)))) :qid |unknown.0:0| :skolemid |593| :pattern ( ($IsBox bx@@36 (Tclass._System.array |#$arg@@1|))) )))
(assert (forall ((arg0@@97 T@U) ) (! (= (type (dtype arg0@@97)) TyType) :qid |funType:dtype| :pattern ( (dtype arg0@@97)) )))
(assert (forall ((|#$arg@@2| T@U) ($i0 Int) ($h@@1 T@U) ($o@@1 T@U) ) (!  (=> (and (and (= (type |#$arg@@2|) TyType) (= (type $h@@1) (MapType1Type refType))) (= (type $o@@1) refType)) (=> (and (and (and ($IsGoodHeap $h@@1) (not (= $o@@1 null))) (= (dtype $o@@1) (Tclass._System.array |#$arg@@2|))) (and (<= 0 $i0) (< $i0 (_System.array.Length $o@@1)))) (and ($IsBox (MapType1Select $h@@1 $o@@1 (IndexField $i0)) |#$arg@@2|) (=> (U_2_bool (MapType1Select $h@@1 $o@@1 alloc)) ($IsAllocBox (MapType1Select $h@@1 $o@@1 (IndexField $i0)) |#$arg@@2| $h@@1))))) :qid |unknown.0:0| :skolemid |594| :pattern ( (MapType1Select $h@@1 $o@@1 (IndexField $i0)) (Tclass._System.array |#$arg@@2|)) )))
(assert (forall ((|#$arg@@3| T@U) ($o@@2 T@U) ) (!  (=> (and (= (type |#$arg@@3|) TyType) (= (type $o@@2) refType)) (and (=> ($Is $o@@2 (Tclass._System.array |#$arg@@3|)) (or (= $o@@2 null) (= (dtype $o@@2) (Tclass._System.array |#$arg@@3|)))) (=> (or (= $o@@2 null) (= (dtype $o@@2) (Tclass._System.array |#$arg@@3|))) ($Is $o@@2 (Tclass._System.array |#$arg@@3|))))) :qid |unknown.0:0| :skolemid |595| :pattern ( ($Is $o@@2 (Tclass._System.array |#$arg@@3|))) )))
(assert (forall ((|#$arg@@4| T@U) ($o@@3 T@U) ($h@@2 T@U) ) (!  (=> (and (and (= (type |#$arg@@4|) TyType) (= (type $o@@3) refType)) (= (type $h@@2) (MapType1Type refType))) (and (=> ($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@2) (or (= $o@@3 null) (U_2_bool (MapType1Select $h@@2 $o@@3 alloc)))) (=> (or (= $o@@3 null) (U_2_bool (MapType1Select $h@@2 $o@@3 alloc))) ($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@2)))) :qid |unknown.0:0| :skolemid |596| :pattern ( ($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@2)) )))
(assert (forall ((|#$arg@@5| T@U) ($h@@3 T@U) ($o@@4 T@U) ) (!  (=> (and (and (and (= (type |#$arg@@5|) TyType) (= (type $h@@3) (MapType1Type refType))) (= (type $o@@4) refType)) (and (and ($IsGoodHeap $h@@3) (not (= $o@@4 null))) (= (dtype $o@@4) (Tclass._System.array |#$arg@@5|)))) (and ($Is (int_2_U (_System.array.Length $o@@4)) TInt) (=> (U_2_bool (MapType1Select $h@@3 $o@@4 alloc)) ($IsAlloc (int_2_U (_System.array.Length $o@@4)) TInt $h@@3)))) :qid |unknown.0:0| :skolemid |597| :no-pattern (type |#$arg@@5|) :no-pattern (type $h@@3) :no-pattern (type $o@@4) :no-pattern (U_2_int |#$arg@@5|) :no-pattern (U_2_bool |#$arg@@5|) :no-pattern (U_2_int $h@@3) :no-pattern (U_2_bool $h@@3) :no-pattern (U_2_int $o@@4) :no-pattern (U_2_bool $o@@4) )))
(assert (forall ((arg0@@98 T@U) ) (! (= (type (Tclass._System.___hFunc0 arg0@@98)) TyType) :qid |funType:Tclass._System.___hFunc0| :pattern ( (Tclass._System.___hFunc0 arg0@@98)) )))
(assert (forall ((|#$T0| T@U) ) (!  (=> (= (type |#$T0|) TyType) (= (Tag (Tclass._System.___hFunc0 |#$T0|)) Tagclass._System.___hFunc0)) :qid |unknown.0:0| :skolemid |598| :pattern ( (Tclass._System.___hFunc0 |#$T0|)) )))
(assert (forall ((arg0@@99 T@U) ) (! (= (type (Tclass._System.___hFunc0_0 arg0@@99)) TyType) :qid |funType:Tclass._System.___hFunc0_0| :pattern ( (Tclass._System.___hFunc0_0 arg0@@99)) )))
(assert (forall ((|#$T0@@0| T@U) ) (!  (=> (= (type |#$T0@@0|) TyType) (= (Tclass._System.___hFunc0_0 (Tclass._System.___hFunc0 |#$T0@@0|)) |#$T0@@0|)) :qid |unknown.0:0| :skolemid |599| :pattern ( (Tclass._System.___hFunc0 |#$T0@@0|)) )))
(assert (= (Ctor HandleTypeType) 19))
(assert (forall ((|#$T0@@1| T@U) (bx@@37 T@U) ) (!  (=> (and (and (= (type |#$T0@@1|) TyType) (= (type bx@@37) BoxType)) ($IsBox bx@@37 (Tclass._System.___hFunc0 |#$T0@@1|))) (and (= ($Box ($Unbox HandleTypeType bx@@37)) bx@@37) ($Is ($Unbox HandleTypeType bx@@37) (Tclass._System.___hFunc0 |#$T0@@1|)))) :qid |unknown.0:0| :skolemid |600| :pattern ( ($IsBox bx@@37 (Tclass._System.___hFunc0 |#$T0@@1|))) )))
(assert  (and (forall ((arg0@@100 T@U) (arg1@@41 T@U) (arg2@@7 T@U) ) (! (= (type (Apply0 arg0@@100 arg1@@41 arg2@@7)) BoxType) :qid |funType:Apply0| :pattern ( (Apply0 arg0@@100 arg1@@41 arg2@@7)) )) (forall ((arg0@@101 T@U) (arg1@@42 T@U) (arg2@@8 T@U) ) (! (= (type (Handle0 arg0@@101 arg1@@42 arg2@@8)) HandleTypeType) :qid |funType:Handle0| :pattern ( (Handle0 arg0@@101 arg1@@42 arg2@@8)) ))))
(assert (forall ((t0@@12 T@U) (heap T@U) (h@@19 T@U) (r@@5 T@U) (rd T@U) ) (!  (=> (and (and (and (and (= (type t0@@12) TyType) (= (type heap) (MapType1Type refType))) (= (type h@@19) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@5) (MapType0Type (MapType1Type refType) boolType))) (= (type rd) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (= (Apply0 t0@@12 (Handle0 h@@19 r@@5 rd) heap) (MapType0Select h@@19 heap))) :qid |unknown.0:0| :skolemid |601| :pattern ( (Apply0 t0@@12 (Handle0 h@@19 r@@5 rd) heap)) )))
(assert (forall ((t0@@13 T@U) (heap@@0 T@U) (h@@20 T@U) (r@@6 T@U) (rd@@0 T@U) ) (!  (=> (and (and (and (and (and (= (type t0@@13) TyType) (= (type heap@@0) (MapType1Type refType))) (= (type h@@20) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@6) (MapType0Type (MapType1Type refType) boolType))) (= (type rd@@0) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (U_2_bool (MapType0Select r@@6 heap@@0))) (Requires0 t0@@13 (Handle0 h@@20 r@@6 rd@@0) heap@@0)) :qid |unknown.0:0| :skolemid |602| :pattern ( (Requires0 t0@@13 (Handle0 h@@20 r@@6 rd@@0) heap@@0)) )))
(assert (forall ((arg0@@102 T@U) (arg1@@43 T@U) (arg2@@9 T@U) ) (! (= (type (Reads0 arg0@@102 arg1@@43 arg2@@9)) (MapType0Type BoxType boolType)) :qid |funType:Reads0| :pattern ( (Reads0 arg0@@102 arg1@@43 arg2@@9)) )))
(assert (forall ((t0@@14 T@U) (heap@@1 T@U) (h@@21 T@U) (r@@7 T@U) (rd@@1 T@U) (bx@@38 T@U) ) (!  (=> (and (and (and (and (and (= (type t0@@14) TyType) (= (type heap@@1) (MapType1Type refType))) (= (type h@@21) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@7) (MapType0Type (MapType1Type refType) boolType))) (= (type rd@@1) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (= (type bx@@38) BoxType)) (and (=> (U_2_bool (MapType0Select (Reads0 t0@@14 (Handle0 h@@21 r@@7 rd@@1) heap@@1) bx@@38)) (U_2_bool (MapType0Select (MapType0Select rd@@1 heap@@1) bx@@38))) (=> (U_2_bool (MapType0Select (MapType0Select rd@@1 heap@@1) bx@@38)) (U_2_bool (MapType0Select (Reads0 t0@@14 (Handle0 h@@21 r@@7 rd@@1) heap@@1) bx@@38))))) :qid |unknown.0:0| :skolemid |603| :pattern ( (MapType0Select (Reads0 t0@@14 (Handle0 h@@21 r@@7 rd@@1) heap@@1) bx@@38)) )))
(assert (forall ((t0@@15 T@U) (h0@@0 T@U) (h1@@0 T@U) (f@@5 T@U) ) (!  (=> (and (and (and (and (= (type t0@@15) TyType) (= (type h0@@0) (MapType1Type refType))) (= (type h1@@0) (MapType1Type refType))) (= (type f@@5) HandleTypeType)) (and (and (and ($HeapSucc h0@@0 h1@@0) (and ($IsGoodHeap h0@@0) ($IsGoodHeap h1@@0))) ($Is f@@5 (Tclass._System.___hFunc0 t0@@15))) (forall ((o@@39 T@U) (fld T@U) ) (! (let ((a@@77 (FieldTypeInv0 (type fld)))) (=> (and (and (= (type o@@39) refType) (= (type fld) (FieldType a@@77))) (and (not (= o@@39 null)) (U_2_bool (MapType0Select (Reads0 t0@@15 f@@5 h0@@0) ($Box o@@39))))) (= (MapType1Select h0@@0 o@@39 fld) (MapType1Select h1@@0 o@@39 fld)))) :qid |unknown.0:0| :skolemid |604| :no-pattern (type o@@39) :no-pattern (type fld) :no-pattern (U_2_int o@@39) :no-pattern (U_2_bool o@@39) :no-pattern (U_2_int fld) :no-pattern (U_2_bool fld) )))) (= (Reads0 t0@@15 f@@5 h0@@0) (Reads0 t0@@15 f@@5 h1@@0))) :qid |unknown.0:0| :skolemid |605| :pattern ( ($HeapSucc h0@@0 h1@@0) (Reads0 t0@@15 f@@5 h1@@0)) )))
(assert (forall ((t0@@16 T@U) (h0@@1 T@U) (h1@@1 T@U) (f@@6 T@U) ) (!  (=> (and (and (and (and (= (type t0@@16) TyType) (= (type h0@@1) (MapType1Type refType))) (= (type h1@@1) (MapType1Type refType))) (= (type f@@6) HandleTypeType)) (and (and (and ($HeapSucc h0@@1 h1@@1) (and ($IsGoodHeap h0@@1) ($IsGoodHeap h1@@1))) ($Is f@@6 (Tclass._System.___hFunc0 t0@@16))) (forall ((o@@40 T@U) (fld@@0 T@U) ) (! (let ((a@@78 (FieldTypeInv0 (type fld@@0)))) (=> (and (and (= (type o@@40) refType) (= (type fld@@0) (FieldType a@@78))) (and (not (= o@@40 null)) (U_2_bool (MapType0Select (Reads0 t0@@16 f@@6 h1@@1) ($Box o@@40))))) (= (MapType1Select h0@@1 o@@40 fld@@0) (MapType1Select h1@@1 o@@40 fld@@0)))) :qid |unknown.0:0| :skolemid |606| :no-pattern (type o@@40) :no-pattern (type fld@@0) :no-pattern (U_2_int o@@40) :no-pattern (U_2_bool o@@40) :no-pattern (U_2_int fld@@0) :no-pattern (U_2_bool fld@@0) )))) (= (Reads0 t0@@16 f@@6 h0@@1) (Reads0 t0@@16 f@@6 h1@@1))) :qid |unknown.0:0| :skolemid |607| :pattern ( ($HeapSucc h0@@1 h1@@1) (Reads0 t0@@16 f@@6 h1@@1)) )))
(assert (forall ((t0@@17 T@U) (h0@@2 T@U) (h1@@2 T@U) (f@@7 T@U) ) (!  (=> (and (and (and (and (= (type t0@@17) TyType) (= (type h0@@2) (MapType1Type refType))) (= (type h1@@2) (MapType1Type refType))) (= (type f@@7) HandleTypeType)) (and (and (and ($HeapSucc h0@@2 h1@@2) (and ($IsGoodHeap h0@@2) ($IsGoodHeap h1@@2))) ($Is f@@7 (Tclass._System.___hFunc0 t0@@17))) (forall ((o@@41 T@U) (fld@@1 T@U) ) (! (let ((a@@79 (FieldTypeInv0 (type fld@@1)))) (=> (and (and (= (type o@@41) refType) (= (type fld@@1) (FieldType a@@79))) (and (not (= o@@41 null)) (U_2_bool (MapType0Select (Reads0 t0@@17 f@@7 h0@@2) ($Box o@@41))))) (= (MapType1Select h0@@2 o@@41 fld@@1) (MapType1Select h1@@2 o@@41 fld@@1)))) :qid |unknown.0:0| :skolemid |608| :no-pattern (type o@@41) :no-pattern (type fld@@1) :no-pattern (U_2_int o@@41) :no-pattern (U_2_bool o@@41) :no-pattern (U_2_int fld@@1) :no-pattern (U_2_bool fld@@1) )))) (and (=> (Requires0 t0@@17 f@@7 h0@@2) (Requires0 t0@@17 f@@7 h1@@2)) (=> (Requires0 t0@@17 f@@7 h1@@2) (Requires0 t0@@17 f@@7 h0@@2)))) :qid |unknown.0:0| :skolemid |609| :pattern ( ($HeapSucc h0@@2 h1@@2) (Requires0 t0@@17 f@@7 h1@@2)) )))
(assert (forall ((t0@@18 T@U) (h0@@3 T@U) (h1@@3 T@U) (f@@8 T@U) ) (!  (=> (and (and (and (and (= (type t0@@18) TyType) (= (type h0@@3) (MapType1Type refType))) (= (type h1@@3) (MapType1Type refType))) (= (type f@@8) HandleTypeType)) (and (and (and ($HeapSucc h0@@3 h1@@3) (and ($IsGoodHeap h0@@3) ($IsGoodHeap h1@@3))) ($Is f@@8 (Tclass._System.___hFunc0 t0@@18))) (forall ((o@@42 T@U) (fld@@2 T@U) ) (! (let ((a@@80 (FieldTypeInv0 (type fld@@2)))) (=> (and (and (= (type o@@42) refType) (= (type fld@@2) (FieldType a@@80))) (and (not (= o@@42 null)) (U_2_bool (MapType0Select (Reads0 t0@@18 f@@8 h1@@3) ($Box o@@42))))) (= (MapType1Select h0@@3 o@@42 fld@@2) (MapType1Select h1@@3 o@@42 fld@@2)))) :qid |unknown.0:0| :skolemid |610| :no-pattern (type o@@42) :no-pattern (type fld@@2) :no-pattern (U_2_int o@@42) :no-pattern (U_2_bool o@@42) :no-pattern (U_2_int fld@@2) :no-pattern (U_2_bool fld@@2) )))) (and (=> (Requires0 t0@@18 f@@8 h0@@3) (Requires0 t0@@18 f@@8 h1@@3)) (=> (Requires0 t0@@18 f@@8 h1@@3) (Requires0 t0@@18 f@@8 h0@@3)))) :qid |unknown.0:0| :skolemid |611| :pattern ( ($HeapSucc h0@@3 h1@@3) (Requires0 t0@@18 f@@8 h1@@3)) )))
(assert (forall ((t0@@19 T@U) (h0@@4 T@U) (h1@@4 T@U) (f@@9 T@U) ) (!  (=> (and (and (and (and (= (type t0@@19) TyType) (= (type h0@@4) (MapType1Type refType))) (= (type h1@@4) (MapType1Type refType))) (= (type f@@9) HandleTypeType)) (and (and (and ($HeapSucc h0@@4 h1@@4) (and ($IsGoodHeap h0@@4) ($IsGoodHeap h1@@4))) ($Is f@@9 (Tclass._System.___hFunc0 t0@@19))) (forall ((o@@43 T@U) (fld@@3 T@U) ) (! (let ((a@@81 (FieldTypeInv0 (type fld@@3)))) (=> (and (and (= (type o@@43) refType) (= (type fld@@3) (FieldType a@@81))) (and (not (= o@@43 null)) (U_2_bool (MapType0Select (Reads0 t0@@19 f@@9 h0@@4) ($Box o@@43))))) (= (MapType1Select h0@@4 o@@43 fld@@3) (MapType1Select h1@@4 o@@43 fld@@3)))) :qid |unknown.0:0| :skolemid |612| :no-pattern (type o@@43) :no-pattern (type fld@@3) :no-pattern (U_2_int o@@43) :no-pattern (U_2_bool o@@43) :no-pattern (U_2_int fld@@3) :no-pattern (U_2_bool fld@@3) )))) (= (Apply0 t0@@19 f@@9 h0@@4) (Apply0 t0@@19 f@@9 h1@@4))) :qid |unknown.0:0| :skolemid |613| :pattern ( ($HeapSucc h0@@4 h1@@4) (Apply0 t0@@19 f@@9 h1@@4)) )))
(assert (forall ((t0@@20 T@U) (h0@@5 T@U) (h1@@5 T@U) (f@@10 T@U) ) (!  (=> (and (and (and (and (= (type t0@@20) TyType) (= (type h0@@5) (MapType1Type refType))) (= (type h1@@5) (MapType1Type refType))) (= (type f@@10) HandleTypeType)) (and (and (and ($HeapSucc h0@@5 h1@@5) (and ($IsGoodHeap h0@@5) ($IsGoodHeap h1@@5))) ($Is f@@10 (Tclass._System.___hFunc0 t0@@20))) (forall ((o@@44 T@U) (fld@@4 T@U) ) (! (let ((a@@82 (FieldTypeInv0 (type fld@@4)))) (=> (and (and (= (type o@@44) refType) (= (type fld@@4) (FieldType a@@82))) (and (not (= o@@44 null)) (U_2_bool (MapType0Select (Reads0 t0@@20 f@@10 h1@@5) ($Box o@@44))))) (= (MapType1Select h0@@5 o@@44 fld@@4) (MapType1Select h1@@5 o@@44 fld@@4)))) :qid |unknown.0:0| :skolemid |614| :no-pattern (type o@@44) :no-pattern (type fld@@4) :no-pattern (U_2_int o@@44) :no-pattern (U_2_bool o@@44) :no-pattern (U_2_int fld@@4) :no-pattern (U_2_bool fld@@4) )))) (= (Apply0 t0@@20 f@@10 h0@@5) (Apply0 t0@@20 f@@10 h1@@5))) :qid |unknown.0:0| :skolemid |615| :pattern ( ($HeapSucc h0@@5 h1@@5) (Apply0 t0@@20 f@@10 h1@@5)) )))
(assert (forall ((f@@11 T@U) (t0@@21 T@U) ) (!  (=> (and (= (type f@@11) HandleTypeType) (= (type t0@@21) TyType)) (and (=> ($Is f@@11 (Tclass._System.___hFunc0 t0@@21)) (forall ((h@@22 T@U) ) (!  (=> (= (type h@@22) (MapType1Type refType)) (=> (and ($IsGoodHeap h@@22) (Requires0 t0@@21 f@@11 h@@22)) ($IsBox (Apply0 t0@@21 f@@11 h@@22) t0@@21))) :qid |DafnyPre.405:12| :skolemid |616| :pattern ( (Apply0 t0@@21 f@@11 h@@22)) ))) (=> (forall ((h@@23 T@U) ) (!  (=> (= (type h@@23) (MapType1Type refType)) (=> (and ($IsGoodHeap h@@23) (Requires0 t0@@21 f@@11 h@@23)) ($IsBox (Apply0 t0@@21 f@@11 h@@23) t0@@21))) :qid |DafnyPre.405:12| :skolemid |616| :pattern ( (Apply0 t0@@21 f@@11 h@@23)) )) ($Is f@@11 (Tclass._System.___hFunc0 t0@@21))))) :qid |unknown.0:0| :skolemid |617| :pattern ( ($Is f@@11 (Tclass._System.___hFunc0 t0@@21))) )))
(assert (forall ((f@@12 T@U) (t0@@22 T@U) (u0 T@U) ) (!  (=> (and (and (and (= (type f@@12) HandleTypeType) (= (type t0@@22) TyType)) (= (type u0) TyType)) (and ($Is f@@12 (Tclass._System.___hFunc0 t0@@22)) (forall ((bx@@39 T@U) ) (!  (=> (and (= (type bx@@39) BoxType) ($IsBox bx@@39 t0@@22)) ($IsBox bx@@39 u0)) :qid |unknown.0:0| :skolemid |618| :pattern ( ($IsBox bx@@39 t0@@22)) :pattern ( ($IsBox bx@@39 u0)) )))) ($Is f@@12 (Tclass._System.___hFunc0 u0))) :qid |unknown.0:0| :skolemid |619| :pattern ( ($Is f@@12 (Tclass._System.___hFunc0 t0@@22)) ($Is f@@12 (Tclass._System.___hFunc0 u0))) )))
(assert (forall ((f@@13 T@U) (t0@@23 T@U) (h@@24 T@U) ) (!  (=> (and (and (and (= (type f@@13) HandleTypeType) (= (type t0@@23) TyType)) (= (type h@@24) (MapType1Type refType))) ($IsGoodHeap h@@24)) ($IsAlloc f@@13 (Tclass._System.___hFunc0 t0@@23) h@@24)) :qid |unknown.0:0| :skolemid |621| :pattern ( ($IsAlloc f@@13 (Tclass._System.___hFunc0 t0@@23) h@@24)) )))
(assert (forall ((arg0@@103 T@U) (arg1@@44 T@U) ) (! (= (type (Tclass._System.___hFunc1 arg0@@103 arg1@@44)) TyType) :qid |funType:Tclass._System.___hFunc1| :pattern ( (Tclass._System.___hFunc1 arg0@@103 arg1@@44)) )))
(assert (forall ((|#$T0@@2| T@U) (|#$T1| T@U) ) (!  (=> (and (= (type |#$T0@@2|) TyType) (= (type |#$T1|) TyType)) (= (Tag (Tclass._System.___hFunc1 |#$T0@@2| |#$T1|)) Tagclass._System.___hFunc1)) :qid |unknown.0:0| :skolemid |622| :pattern ( (Tclass._System.___hFunc1 |#$T0@@2| |#$T1|)) )))
(assert (forall ((arg0@@104 T@U) ) (! (= (type (Tclass._System.___hFunc1_0 arg0@@104)) TyType) :qid |funType:Tclass._System.___hFunc1_0| :pattern ( (Tclass._System.___hFunc1_0 arg0@@104)) )))
(assert (forall ((|#$T0@@3| T@U) (|#$T1@@0| T@U) ) (!  (=> (and (= (type |#$T0@@3|) TyType) (= (type |#$T1@@0|) TyType)) (= (Tclass._System.___hFunc1_0 (Tclass._System.___hFunc1 |#$T0@@3| |#$T1@@0|)) |#$T0@@3|)) :qid |unknown.0:0| :skolemid |623| :pattern ( (Tclass._System.___hFunc1 |#$T0@@3| |#$T1@@0|)) )))
(assert (forall ((arg0@@105 T@U) ) (! (= (type (Tclass._System.___hFunc1_1 arg0@@105)) TyType) :qid |funType:Tclass._System.___hFunc1_1| :pattern ( (Tclass._System.___hFunc1_1 arg0@@105)) )))
(assert (forall ((|#$T0@@4| T@U) (|#$T1@@1| T@U) ) (!  (=> (and (= (type |#$T0@@4|) TyType) (= (type |#$T1@@1|) TyType)) (= (Tclass._System.___hFunc1_1 (Tclass._System.___hFunc1 |#$T0@@4| |#$T1@@1|)) |#$T1@@1|)) :qid |unknown.0:0| :skolemid |624| :pattern ( (Tclass._System.___hFunc1 |#$T0@@4| |#$T1@@1|)) )))
(assert (forall ((|#$T0@@5| T@U) (|#$T1@@2| T@U) (bx@@40 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@5|) TyType) (= (type |#$T1@@2|) TyType)) (= (type bx@@40) BoxType)) ($IsBox bx@@40 (Tclass._System.___hFunc1 |#$T0@@5| |#$T1@@2|))) (and (= ($Box ($Unbox HandleTypeType bx@@40)) bx@@40) ($Is ($Unbox HandleTypeType bx@@40) (Tclass._System.___hFunc1 |#$T0@@5| |#$T1@@2|)))) :qid |unknown.0:0| :skolemid |625| :pattern ( ($IsBox bx@@40 (Tclass._System.___hFunc1 |#$T0@@5| |#$T1@@2|))) )))
(assert  (and (and (and (and (and (and (and (and (and (forall ((arg0@@106 T@T) (arg1@@45 T@T) (arg2@@10 T@T) ) (! (= (Ctor (MapType2Type arg0@@106 arg1@@45 arg2@@10)) 20) :qid |ctor:MapType2Type| )) (forall ((arg0@@107 T@T) (arg1@@46 T@T) (arg2@@11 T@T) ) (! (= (MapType2TypeInv0 (MapType2Type arg0@@107 arg1@@46 arg2@@11)) arg0@@107) :qid |typeInv:MapType2TypeInv0| :pattern ( (MapType2Type arg0@@107 arg1@@46 arg2@@11)) ))) (forall ((arg0@@108 T@T) (arg1@@47 T@T) (arg2@@12 T@T) ) (! (= (MapType2TypeInv1 (MapType2Type arg0@@108 arg1@@47 arg2@@12)) arg1@@47) :qid |typeInv:MapType2TypeInv1| :pattern ( (MapType2Type arg0@@108 arg1@@47 arg2@@12)) ))) (forall ((arg0@@109 T@T) (arg1@@48 T@T) (arg2@@13 T@T) ) (! (= (MapType2TypeInv2 (MapType2Type arg0@@109 arg1@@48 arg2@@13)) arg2@@13) :qid |typeInv:MapType2TypeInv2| :pattern ( (MapType2Type arg0@@109 arg1@@48 arg2@@13)) ))) (forall ((arg0@@110 T@U) (arg1@@49 T@U) (arg2@@14 T@U) ) (! (let ((aVar2 (MapType2TypeInv2 (type arg0@@110)))) (= (type (MapType2Select arg0@@110 arg1@@49 arg2@@14)) aVar2)) :qid |funType:MapType2Select| :pattern ( (MapType2Select arg0@@110 arg1@@49 arg2@@14)) ))) (forall ((arg0@@111 T@U) (arg1@@50 T@U) (arg2@@15 T@U) (arg3@@0 T@U) ) (! (let ((aVar2@@0 (type arg3@@0))) (let ((aVar1@@2 (type arg2@@15))) (let ((aVar0@@1 (type arg1@@50))) (= (type (MapType2Store arg0@@111 arg1@@50 arg2@@15 arg3@@0)) (MapType2Type aVar0@@1 aVar1@@2 aVar2@@0))))) :qid |funType:MapType2Store| :pattern ( (MapType2Store arg0@@111 arg1@@50 arg2@@15 arg3@@0)) ))) (forall ((m@@27 T@U) (x0@@6 T@U) (x1@@3 T@U) (val@@7 T@U) ) (! (let ((aVar2@@1 (MapType2TypeInv2 (type m@@27)))) (=> (= (type val@@7) aVar2@@1) (= (MapType2Select (MapType2Store m@@27 x0@@6 x1@@3 val@@7) x0@@6 x1@@3) val@@7))) :qid |mapAx0:MapType2Select| :weight 0 ))) (and (and (forall ((val@@8 T@U) (m@@28 T@U) (x0@@7 T@U) (x1@@4 T@U) (y0@@4 T@U) (y1@@2 T@U) ) (!  (or (= x0@@7 y0@@4) (= (MapType2Select (MapType2Store m@@28 x0@@7 x1@@4 val@@8) y0@@4 y1@@2) (MapType2Select m@@28 y0@@4 y1@@2))) :qid |mapAx1:MapType2Select:0| :weight 0 )) (forall ((val@@9 T@U) (m@@29 T@U) (x0@@8 T@U) (x1@@5 T@U) (y0@@5 T@U) (y1@@3 T@U) ) (!  (or (= x1@@5 y1@@3) (= (MapType2Select (MapType2Store m@@29 x0@@8 x1@@5 val@@9) y0@@5 y1@@3) (MapType2Select m@@29 y0@@5 y1@@3))) :qid |mapAx1:MapType2Select:1| :weight 0 ))) (forall ((val@@10 T@U) (m@@30 T@U) (x0@@9 T@U) (x1@@6 T@U) (y0@@6 T@U) (y1@@4 T@U) ) (!  (or true (= (MapType2Select (MapType2Store m@@30 x0@@9 x1@@6 val@@10) y0@@6 y1@@4) (MapType2Select m@@30 y0@@6 y1@@4))) :qid |mapAx2:MapType2Select| :weight 0 )))) (forall ((arg0@@112 T@U) (arg1@@51 T@U) (arg2@@16 T@U) (arg3@@1 T@U) (arg4 T@U) ) (! (= (type (Apply1 arg0@@112 arg1@@51 arg2@@16 arg3@@1 arg4)) BoxType) :qid |funType:Apply1| :pattern ( (Apply1 arg0@@112 arg1@@51 arg2@@16 arg3@@1 arg4)) ))) (forall ((arg0@@113 T@U) (arg1@@52 T@U) (arg2@@17 T@U) ) (! (= (type (Handle1 arg0@@113 arg1@@52 arg2@@17)) HandleTypeType) :qid |funType:Handle1| :pattern ( (Handle1 arg0@@113 arg1@@52 arg2@@17)) ))))
(assert (forall ((t0@@24 T@U) (t1@@3 T@U) (heap@@2 T@U) (h@@25 T@U) (r@@8 T@U) (rd@@2 T@U) (bx0 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@24) TyType) (= (type t1@@3) TyType)) (= (type heap@@2) (MapType1Type refType))) (= (type h@@25) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@8) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@2) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0) BoxType)) (= (Apply1 t0@@24 t1@@3 (Handle1 h@@25 r@@8 rd@@2) heap@@2 bx0) (MapType2Select h@@25 heap@@2 bx0))) :qid |unknown.0:0| :skolemid |626| :pattern ( (Apply1 t0@@24 t1@@3 (Handle1 h@@25 r@@8 rd@@2) heap@@2 bx0)) )))
(assert (forall ((t0@@25 T@U) (t1@@4 T@U) (heap@@3 T@U) (h@@26 T@U) (r@@9 T@U) (rd@@3 T@U) (bx0@@0 T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type t0@@25) TyType) (= (type t1@@4) TyType)) (= (type heap@@3) (MapType1Type refType))) (= (type h@@26) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@9) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@3) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@0) BoxType)) (U_2_bool (MapType2Select r@@9 heap@@3 bx0@@0))) (Requires1 t0@@25 t1@@4 (Handle1 h@@26 r@@9 rd@@3) heap@@3 bx0@@0)) :qid |unknown.0:0| :skolemid |627| :pattern ( (Requires1 t0@@25 t1@@4 (Handle1 h@@26 r@@9 rd@@3) heap@@3 bx0@@0)) )))
(assert (forall ((arg0@@114 T@U) (arg1@@53 T@U) (arg2@@18 T@U) (arg3@@2 T@U) (arg4@@0 T@U) ) (! (= (type (Reads1 arg0@@114 arg1@@53 arg2@@18 arg3@@2 arg4@@0)) (MapType0Type BoxType boolType)) :qid |funType:Reads1| :pattern ( (Reads1 arg0@@114 arg1@@53 arg2@@18 arg3@@2 arg4@@0)) )))
(assert (forall ((t0@@26 T@U) (t1@@5 T@U) (heap@@4 T@U) (h@@27 T@U) (r@@10 T@U) (rd@@4 T@U) (bx0@@1 T@U) (bx@@41 T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type t0@@26) TyType) (= (type t1@@5) TyType)) (= (type heap@@4) (MapType1Type refType))) (= (type h@@27) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@10) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@4) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@1) BoxType)) (= (type bx@@41) BoxType)) (and (=> (U_2_bool (MapType0Select (Reads1 t0@@26 t1@@5 (Handle1 h@@27 r@@10 rd@@4) heap@@4 bx0@@1) bx@@41)) (U_2_bool (MapType0Select (MapType2Select rd@@4 heap@@4 bx0@@1) bx@@41))) (=> (U_2_bool (MapType0Select (MapType2Select rd@@4 heap@@4 bx0@@1) bx@@41)) (U_2_bool (MapType0Select (Reads1 t0@@26 t1@@5 (Handle1 h@@27 r@@10 rd@@4) heap@@4 bx0@@1) bx@@41))))) :qid |unknown.0:0| :skolemid |628| :pattern ( (MapType0Select (Reads1 t0@@26 t1@@5 (Handle1 h@@27 r@@10 rd@@4) heap@@4 bx0@@1) bx@@41)) )))
(assert (forall ((t0@@27 T@U) (t1@@6 T@U) (h0@@6 T@U) (h1@@6 T@U) (f@@14 T@U) (bx0@@2 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@27) TyType) (= (type t1@@6) TyType)) (= (type h0@@6) (MapType1Type refType))) (= (type h1@@6) (MapType1Type refType))) (= (type f@@14) HandleTypeType)) (= (type bx0@@2) BoxType)) (and (and (and ($HeapSucc h0@@6 h1@@6) (and ($IsGoodHeap h0@@6) ($IsGoodHeap h1@@6))) (and ($IsBox bx0@@2 t0@@27) ($Is f@@14 (Tclass._System.___hFunc1 t0@@27 t1@@6)))) (forall ((o@@45 T@U) (fld@@5 T@U) ) (! (let ((a@@83 (FieldTypeInv0 (type fld@@5)))) (=> (and (and (= (type o@@45) refType) (= (type fld@@5) (FieldType a@@83))) (and (not (= o@@45 null)) (U_2_bool (MapType0Select (Reads1 t0@@27 t1@@6 f@@14 h0@@6 bx0@@2) ($Box o@@45))))) (= (MapType1Select h0@@6 o@@45 fld@@5) (MapType1Select h1@@6 o@@45 fld@@5)))) :qid |unknown.0:0| :skolemid |629| :no-pattern (type o@@45) :no-pattern (type fld@@5) :no-pattern (U_2_int o@@45) :no-pattern (U_2_bool o@@45) :no-pattern (U_2_int fld@@5) :no-pattern (U_2_bool fld@@5) )))) (= (Reads1 t0@@27 t1@@6 f@@14 h0@@6 bx0@@2) (Reads1 t0@@27 t1@@6 f@@14 h1@@6 bx0@@2))) :qid |unknown.0:0| :skolemid |630| :pattern ( ($HeapSucc h0@@6 h1@@6) (Reads1 t0@@27 t1@@6 f@@14 h1@@6 bx0@@2)) )))
(assert (forall ((t0@@28 T@U) (t1@@7 T@U) (h0@@7 T@U) (h1@@7 T@U) (f@@15 T@U) (bx0@@3 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@28) TyType) (= (type t1@@7) TyType)) (= (type h0@@7) (MapType1Type refType))) (= (type h1@@7) (MapType1Type refType))) (= (type f@@15) HandleTypeType)) (= (type bx0@@3) BoxType)) (and (and (and ($HeapSucc h0@@7 h1@@7) (and ($IsGoodHeap h0@@7) ($IsGoodHeap h1@@7))) (and ($IsBox bx0@@3 t0@@28) ($Is f@@15 (Tclass._System.___hFunc1 t0@@28 t1@@7)))) (forall ((o@@46 T@U) (fld@@6 T@U) ) (! (let ((a@@84 (FieldTypeInv0 (type fld@@6)))) (=> (and (and (= (type o@@46) refType) (= (type fld@@6) (FieldType a@@84))) (and (not (= o@@46 null)) (U_2_bool (MapType0Select (Reads1 t0@@28 t1@@7 f@@15 h1@@7 bx0@@3) ($Box o@@46))))) (= (MapType1Select h0@@7 o@@46 fld@@6) (MapType1Select h1@@7 o@@46 fld@@6)))) :qid |unknown.0:0| :skolemid |631| :no-pattern (type o@@46) :no-pattern (type fld@@6) :no-pattern (U_2_int o@@46) :no-pattern (U_2_bool o@@46) :no-pattern (U_2_int fld@@6) :no-pattern (U_2_bool fld@@6) )))) (= (Reads1 t0@@28 t1@@7 f@@15 h0@@7 bx0@@3) (Reads1 t0@@28 t1@@7 f@@15 h1@@7 bx0@@3))) :qid |unknown.0:0| :skolemid |632| :pattern ( ($HeapSucc h0@@7 h1@@7) (Reads1 t0@@28 t1@@7 f@@15 h1@@7 bx0@@3)) )))
(assert (forall ((t0@@29 T@U) (t1@@8 T@U) (h0@@8 T@U) (h1@@8 T@U) (f@@16 T@U) (bx0@@4 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@29) TyType) (= (type t1@@8) TyType)) (= (type h0@@8) (MapType1Type refType))) (= (type h1@@8) (MapType1Type refType))) (= (type f@@16) HandleTypeType)) (= (type bx0@@4) BoxType)) (and (and (and ($HeapSucc h0@@8 h1@@8) (and ($IsGoodHeap h0@@8) ($IsGoodHeap h1@@8))) (and ($IsBox bx0@@4 t0@@29) ($Is f@@16 (Tclass._System.___hFunc1 t0@@29 t1@@8)))) (forall ((o@@47 T@U) (fld@@7 T@U) ) (! (let ((a@@85 (FieldTypeInv0 (type fld@@7)))) (=> (and (and (= (type o@@47) refType) (= (type fld@@7) (FieldType a@@85))) (and (not (= o@@47 null)) (U_2_bool (MapType0Select (Reads1 t0@@29 t1@@8 f@@16 h0@@8 bx0@@4) ($Box o@@47))))) (= (MapType1Select h0@@8 o@@47 fld@@7) (MapType1Select h1@@8 o@@47 fld@@7)))) :qid |unknown.0:0| :skolemid |633| :no-pattern (type o@@47) :no-pattern (type fld@@7) :no-pattern (U_2_int o@@47) :no-pattern (U_2_bool o@@47) :no-pattern (U_2_int fld@@7) :no-pattern (U_2_bool fld@@7) )))) (and (=> (Requires1 t0@@29 t1@@8 f@@16 h0@@8 bx0@@4) (Requires1 t0@@29 t1@@8 f@@16 h1@@8 bx0@@4)) (=> (Requires1 t0@@29 t1@@8 f@@16 h1@@8 bx0@@4) (Requires1 t0@@29 t1@@8 f@@16 h0@@8 bx0@@4)))) :qid |unknown.0:0| :skolemid |634| :pattern ( ($HeapSucc h0@@8 h1@@8) (Requires1 t0@@29 t1@@8 f@@16 h1@@8 bx0@@4)) )))
(assert (forall ((t0@@30 T@U) (t1@@9 T@U) (h0@@9 T@U) (h1@@9 T@U) (f@@17 T@U) (bx0@@5 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@30) TyType) (= (type t1@@9) TyType)) (= (type h0@@9) (MapType1Type refType))) (= (type h1@@9) (MapType1Type refType))) (= (type f@@17) HandleTypeType)) (= (type bx0@@5) BoxType)) (and (and (and ($HeapSucc h0@@9 h1@@9) (and ($IsGoodHeap h0@@9) ($IsGoodHeap h1@@9))) (and ($IsBox bx0@@5 t0@@30) ($Is f@@17 (Tclass._System.___hFunc1 t0@@30 t1@@9)))) (forall ((o@@48 T@U) (fld@@8 T@U) ) (! (let ((a@@86 (FieldTypeInv0 (type fld@@8)))) (=> (and (and (= (type o@@48) refType) (= (type fld@@8) (FieldType a@@86))) (and (not (= o@@48 null)) (U_2_bool (MapType0Select (Reads1 t0@@30 t1@@9 f@@17 h1@@9 bx0@@5) ($Box o@@48))))) (= (MapType1Select h0@@9 o@@48 fld@@8) (MapType1Select h1@@9 o@@48 fld@@8)))) :qid |unknown.0:0| :skolemid |635| :no-pattern (type o@@48) :no-pattern (type fld@@8) :no-pattern (U_2_int o@@48) :no-pattern (U_2_bool o@@48) :no-pattern (U_2_int fld@@8) :no-pattern (U_2_bool fld@@8) )))) (and (=> (Requires1 t0@@30 t1@@9 f@@17 h0@@9 bx0@@5) (Requires1 t0@@30 t1@@9 f@@17 h1@@9 bx0@@5)) (=> (Requires1 t0@@30 t1@@9 f@@17 h1@@9 bx0@@5) (Requires1 t0@@30 t1@@9 f@@17 h0@@9 bx0@@5)))) :qid |unknown.0:0| :skolemid |636| :pattern ( ($HeapSucc h0@@9 h1@@9) (Requires1 t0@@30 t1@@9 f@@17 h1@@9 bx0@@5)) )))
(assert (forall ((t0@@31 T@U) (t1@@10 T@U) (h0@@10 T@U) (h1@@10 T@U) (f@@18 T@U) (bx0@@6 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@31) TyType) (= (type t1@@10) TyType)) (= (type h0@@10) (MapType1Type refType))) (= (type h1@@10) (MapType1Type refType))) (= (type f@@18) HandleTypeType)) (= (type bx0@@6) BoxType)) (and (and (and ($HeapSucc h0@@10 h1@@10) (and ($IsGoodHeap h0@@10) ($IsGoodHeap h1@@10))) (and ($IsBox bx0@@6 t0@@31) ($Is f@@18 (Tclass._System.___hFunc1 t0@@31 t1@@10)))) (forall ((o@@49 T@U) (fld@@9 T@U) ) (! (let ((a@@87 (FieldTypeInv0 (type fld@@9)))) (=> (and (and (= (type o@@49) refType) (= (type fld@@9) (FieldType a@@87))) (and (not (= o@@49 null)) (U_2_bool (MapType0Select (Reads1 t0@@31 t1@@10 f@@18 h0@@10 bx0@@6) ($Box o@@49))))) (= (MapType1Select h0@@10 o@@49 fld@@9) (MapType1Select h1@@10 o@@49 fld@@9)))) :qid |unknown.0:0| :skolemid |637| :no-pattern (type o@@49) :no-pattern (type fld@@9) :no-pattern (U_2_int o@@49) :no-pattern (U_2_bool o@@49) :no-pattern (U_2_int fld@@9) :no-pattern (U_2_bool fld@@9) )))) (= (Apply1 t0@@31 t1@@10 f@@18 h0@@10 bx0@@6) (Apply1 t0@@31 t1@@10 f@@18 h1@@10 bx0@@6))) :qid |unknown.0:0| :skolemid |638| :pattern ( ($HeapSucc h0@@10 h1@@10) (Apply1 t0@@31 t1@@10 f@@18 h1@@10 bx0@@6)) )))
(assert (forall ((t0@@32 T@U) (t1@@11 T@U) (h0@@11 T@U) (h1@@11 T@U) (f@@19 T@U) (bx0@@7 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@32) TyType) (= (type t1@@11) TyType)) (= (type h0@@11) (MapType1Type refType))) (= (type h1@@11) (MapType1Type refType))) (= (type f@@19) HandleTypeType)) (= (type bx0@@7) BoxType)) (and (and (and ($HeapSucc h0@@11 h1@@11) (and ($IsGoodHeap h0@@11) ($IsGoodHeap h1@@11))) (and ($IsBox bx0@@7 t0@@32) ($Is f@@19 (Tclass._System.___hFunc1 t0@@32 t1@@11)))) (forall ((o@@50 T@U) (fld@@10 T@U) ) (! (let ((a@@88 (FieldTypeInv0 (type fld@@10)))) (=> (and (and (= (type o@@50) refType) (= (type fld@@10) (FieldType a@@88))) (and (not (= o@@50 null)) (U_2_bool (MapType0Select (Reads1 t0@@32 t1@@11 f@@19 h1@@11 bx0@@7) ($Box o@@50))))) (= (MapType1Select h0@@11 o@@50 fld@@10) (MapType1Select h1@@11 o@@50 fld@@10)))) :qid |unknown.0:0| :skolemid |639| :no-pattern (type o@@50) :no-pattern (type fld@@10) :no-pattern (U_2_int o@@50) :no-pattern (U_2_bool o@@50) :no-pattern (U_2_int fld@@10) :no-pattern (U_2_bool fld@@10) )))) (= (Apply1 t0@@32 t1@@11 f@@19 h0@@11 bx0@@7) (Apply1 t0@@32 t1@@11 f@@19 h1@@11 bx0@@7))) :qid |unknown.0:0| :skolemid |640| :pattern ( ($HeapSucc h0@@11 h1@@11) (Apply1 t0@@32 t1@@11 f@@19 h1@@11 bx0@@7)) )))
(assert (forall ((f@@20 T@U) (t0@@33 T@U) (t1@@12 T@U) ) (!  (=> (and (and (= (type f@@20) HandleTypeType) (= (type t0@@33) TyType)) (= (type t1@@12) TyType)) (and (=> ($Is f@@20 (Tclass._System.___hFunc1 t0@@33 t1@@12)) (forall ((h@@28 T@U) (bx0@@8 T@U) ) (!  (=> (and (= (type h@@28) (MapType1Type refType)) (= (type bx0@@8) BoxType)) (=> (and (and ($IsGoodHeap h@@28) ($IsBox bx0@@8 t0@@33)) (Requires1 t0@@33 t1@@12 f@@20 h@@28 bx0@@8)) ($IsBox (Apply1 t0@@33 t1@@12 f@@20 h@@28 bx0@@8) t1@@12))) :qid |DafnyPre.405:12| :skolemid |641| :pattern ( (Apply1 t0@@33 t1@@12 f@@20 h@@28 bx0@@8)) ))) (=> (forall ((h@@29 T@U) (bx0@@9 T@U) ) (!  (=> (and (= (type h@@29) (MapType1Type refType)) (= (type bx0@@9) BoxType)) (=> (and (and ($IsGoodHeap h@@29) ($IsBox bx0@@9 t0@@33)) (Requires1 t0@@33 t1@@12 f@@20 h@@29 bx0@@9)) ($IsBox (Apply1 t0@@33 t1@@12 f@@20 h@@29 bx0@@9) t1@@12))) :qid |DafnyPre.405:12| :skolemid |641| :pattern ( (Apply1 t0@@33 t1@@12 f@@20 h@@29 bx0@@9)) )) ($Is f@@20 (Tclass._System.___hFunc1 t0@@33 t1@@12))))) :qid |unknown.0:0| :skolemid |642| :pattern ( ($Is f@@20 (Tclass._System.___hFunc1 t0@@33 t1@@12))) )))
(assert (forall ((f@@21 T@U) (t0@@34 T@U) (t1@@13 T@U) (u0@@0 T@U) (u1 T@U) ) (!  (=> (and (and (and (and (and (= (type f@@21) HandleTypeType) (= (type t0@@34) TyType)) (= (type t1@@13) TyType)) (= (type u0@@0) TyType)) (= (type u1) TyType)) (and (and ($Is f@@21 (Tclass._System.___hFunc1 t0@@34 t1@@13)) (forall ((bx@@42 T@U) ) (!  (=> (and (= (type bx@@42) BoxType) ($IsBox bx@@42 u0@@0)) ($IsBox bx@@42 t0@@34)) :qid |unknown.0:0| :skolemid |643| :pattern ( ($IsBox bx@@42 u0@@0)) :pattern ( ($IsBox bx@@42 t0@@34)) ))) (forall ((bx@@43 T@U) ) (!  (=> (and (= (type bx@@43) BoxType) ($IsBox bx@@43 t1@@13)) ($IsBox bx@@43 u1)) :qid |unknown.0:0| :skolemid |644| :pattern ( ($IsBox bx@@43 t1@@13)) :pattern ( ($IsBox bx@@43 u1)) )))) ($Is f@@21 (Tclass._System.___hFunc1 u0@@0 u1))) :qid |unknown.0:0| :skolemid |645| :pattern ( ($Is f@@21 (Tclass._System.___hFunc1 t0@@34 t1@@13)) ($Is f@@21 (Tclass._System.___hFunc1 u0@@0 u1))) )))
(assert (forall ((f@@22 T@U) (t0@@35 T@U) (t1@@14 T@U) (h@@30 T@U) ) (!  (=> (and (and (and (and (= (type f@@22) HandleTypeType) (= (type t0@@35) TyType)) (= (type t1@@14) TyType)) (= (type h@@30) (MapType1Type refType))) ($IsGoodHeap h@@30)) ($IsAlloc f@@22 (Tclass._System.___hFunc1 t0@@35 t1@@14) h@@30)) :qid |unknown.0:0| :skolemid |647| :pattern ( ($IsAlloc f@@22 (Tclass._System.___hFunc1 t0@@35 t1@@14) h@@30)) )))
(assert (forall ((arg0@@115 T@U) (arg1@@54 T@U) (arg2@@19 T@U) ) (! (= (type (Tclass._System.___hFunc2 arg0@@115 arg1@@54 arg2@@19)) TyType) :qid |funType:Tclass._System.___hFunc2| :pattern ( (Tclass._System.___hFunc2 arg0@@115 arg1@@54 arg2@@19)) )))
(assert (forall ((|#$T0@@6| T@U) (|#$T1@@3| T@U) (|#$T2| T@U) ) (!  (=> (and (and (= (type |#$T0@@6|) TyType) (= (type |#$T1@@3|) TyType)) (= (type |#$T2|) TyType)) (= (Tag (Tclass._System.___hFunc2 |#$T0@@6| |#$T1@@3| |#$T2|)) Tagclass._System.___hFunc2)) :qid |unknown.0:0| :skolemid |648| :pattern ( (Tclass._System.___hFunc2 |#$T0@@6| |#$T1@@3| |#$T2|)) )))
(assert (forall ((arg0@@116 T@U) ) (! (= (type (Tclass._System.___hFunc2_0 arg0@@116)) TyType) :qid |funType:Tclass._System.___hFunc2_0| :pattern ( (Tclass._System.___hFunc2_0 arg0@@116)) )))
(assert (forall ((|#$T0@@7| T@U) (|#$T1@@4| T@U) (|#$T2@@0| T@U) ) (!  (=> (and (and (= (type |#$T0@@7|) TyType) (= (type |#$T1@@4|) TyType)) (= (type |#$T2@@0|) TyType)) (= (Tclass._System.___hFunc2_0 (Tclass._System.___hFunc2 |#$T0@@7| |#$T1@@4| |#$T2@@0|)) |#$T0@@7|)) :qid |unknown.0:0| :skolemid |649| :pattern ( (Tclass._System.___hFunc2 |#$T0@@7| |#$T1@@4| |#$T2@@0|)) )))
(assert (forall ((arg0@@117 T@U) ) (! (= (type (Tclass._System.___hFunc2_1 arg0@@117)) TyType) :qid |funType:Tclass._System.___hFunc2_1| :pattern ( (Tclass._System.___hFunc2_1 arg0@@117)) )))
(assert (forall ((|#$T0@@8| T@U) (|#$T1@@5| T@U) (|#$T2@@1| T@U) ) (!  (=> (and (and (= (type |#$T0@@8|) TyType) (= (type |#$T1@@5|) TyType)) (= (type |#$T2@@1|) TyType)) (= (Tclass._System.___hFunc2_1 (Tclass._System.___hFunc2 |#$T0@@8| |#$T1@@5| |#$T2@@1|)) |#$T1@@5|)) :qid |unknown.0:0| :skolemid |650| :pattern ( (Tclass._System.___hFunc2 |#$T0@@8| |#$T1@@5| |#$T2@@1|)) )))
(assert (forall ((arg0@@118 T@U) ) (! (= (type (Tclass._System.___hFunc2_2 arg0@@118)) TyType) :qid |funType:Tclass._System.___hFunc2_2| :pattern ( (Tclass._System.___hFunc2_2 arg0@@118)) )))
(assert (forall ((|#$T0@@9| T@U) (|#$T1@@6| T@U) (|#$T2@@2| T@U) ) (!  (=> (and (and (= (type |#$T0@@9|) TyType) (= (type |#$T1@@6|) TyType)) (= (type |#$T2@@2|) TyType)) (= (Tclass._System.___hFunc2_2 (Tclass._System.___hFunc2 |#$T0@@9| |#$T1@@6| |#$T2@@2|)) |#$T2@@2|)) :qid |unknown.0:0| :skolemid |651| :pattern ( (Tclass._System.___hFunc2 |#$T0@@9| |#$T1@@6| |#$T2@@2|)) )))
(assert (forall ((|#$T0@@10| T@U) (|#$T1@@7| T@U) (|#$T2@@3| T@U) (bx@@44 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@10|) TyType) (= (type |#$T1@@7|) TyType)) (= (type |#$T2@@3|) TyType)) (= (type bx@@44) BoxType)) ($IsBox bx@@44 (Tclass._System.___hFunc2 |#$T0@@10| |#$T1@@7| |#$T2@@3|))) (and (= ($Box ($Unbox HandleTypeType bx@@44)) bx@@44) ($Is ($Unbox HandleTypeType bx@@44) (Tclass._System.___hFunc2 |#$T0@@10| |#$T1@@7| |#$T2@@3|)))) :qid |unknown.0:0| :skolemid |652| :pattern ( ($IsBox bx@@44 (Tclass._System.___hFunc2 |#$T0@@10| |#$T1@@7| |#$T2@@3|))) )))
(assert  (and (and (and (and (and (and (and (and (and (and (forall ((arg0@@119 T@T) (arg1@@55 T@T) (arg2@@20 T@T) (arg3@@3 T@T) ) (! (= (Ctor (MapType3Type arg0@@119 arg1@@55 arg2@@20 arg3@@3)) 21) :qid |ctor:MapType3Type| )) (forall ((arg0@@120 T@T) (arg1@@56 T@T) (arg2@@21 T@T) (arg3@@4 T@T) ) (! (= (MapType3TypeInv0 (MapType3Type arg0@@120 arg1@@56 arg2@@21 arg3@@4)) arg0@@120) :qid |typeInv:MapType3TypeInv0| :pattern ( (MapType3Type arg0@@120 arg1@@56 arg2@@21 arg3@@4)) ))) (forall ((arg0@@121 T@T) (arg1@@57 T@T) (arg2@@22 T@T) (arg3@@5 T@T) ) (! (= (MapType3TypeInv1 (MapType3Type arg0@@121 arg1@@57 arg2@@22 arg3@@5)) arg1@@57) :qid |typeInv:MapType3TypeInv1| :pattern ( (MapType3Type arg0@@121 arg1@@57 arg2@@22 arg3@@5)) ))) (forall ((arg0@@122 T@T) (arg1@@58 T@T) (arg2@@23 T@T) (arg3@@6 T@T) ) (! (= (MapType3TypeInv2 (MapType3Type arg0@@122 arg1@@58 arg2@@23 arg3@@6)) arg2@@23) :qid |typeInv:MapType3TypeInv2| :pattern ( (MapType3Type arg0@@122 arg1@@58 arg2@@23 arg3@@6)) ))) (forall ((arg0@@123 T@T) (arg1@@59 T@T) (arg2@@24 T@T) (arg3@@7 T@T) ) (! (= (MapType3TypeInv3 (MapType3Type arg0@@123 arg1@@59 arg2@@24 arg3@@7)) arg3@@7) :qid |typeInv:MapType3TypeInv3| :pattern ( (MapType3Type arg0@@123 arg1@@59 arg2@@24 arg3@@7)) ))) (forall ((arg0@@124 T@U) (arg1@@60 T@U) (arg2@@25 T@U) (arg3@@8 T@U) ) (! (let ((aVar3 (MapType3TypeInv3 (type arg0@@124)))) (= (type (MapType3Select arg0@@124 arg1@@60 arg2@@25 arg3@@8)) aVar3)) :qid |funType:MapType3Select| :pattern ( (MapType3Select arg0@@124 arg1@@60 arg2@@25 arg3@@8)) ))) (forall ((arg0@@125 T@U) (arg1@@61 T@U) (arg2@@26 T@U) (arg3@@9 T@U) (arg4@@1 T@U) ) (! (let ((aVar3@@0 (type arg4@@1))) (let ((aVar2@@2 (type arg3@@9))) (let ((aVar1@@3 (type arg2@@26))) (let ((aVar0@@2 (type arg1@@61))) (= (type (MapType3Store arg0@@125 arg1@@61 arg2@@26 arg3@@9 arg4@@1)) (MapType3Type aVar0@@2 aVar1@@3 aVar2@@2 aVar3@@0)))))) :qid |funType:MapType3Store| :pattern ( (MapType3Store arg0@@125 arg1@@61 arg2@@26 arg3@@9 arg4@@1)) ))) (forall ((m@@31 T@U) (x0@@10 T@U) (x1@@7 T@U) (x2 T@U) (val@@11 T@U) ) (! (let ((aVar3@@1 (MapType3TypeInv3 (type m@@31)))) (=> (= (type val@@11) aVar3@@1) (= (MapType3Select (MapType3Store m@@31 x0@@10 x1@@7 x2 val@@11) x0@@10 x1@@7 x2) val@@11))) :qid |mapAx0:MapType3Select| :weight 0 ))) (and (and (and (forall ((val@@12 T@U) (m@@32 T@U) (x0@@11 T@U) (x1@@8 T@U) (x2@@0 T@U) (y0@@7 T@U) (y1@@5 T@U) (y2 T@U) ) (!  (or (= x0@@11 y0@@7) (= (MapType3Select (MapType3Store m@@32 x0@@11 x1@@8 x2@@0 val@@12) y0@@7 y1@@5 y2) (MapType3Select m@@32 y0@@7 y1@@5 y2))) :qid |mapAx1:MapType3Select:0| :weight 0 )) (forall ((val@@13 T@U) (m@@33 T@U) (x0@@12 T@U) (x1@@9 T@U) (x2@@1 T@U) (y0@@8 T@U) (y1@@6 T@U) (y2@@0 T@U) ) (!  (or (= x1@@9 y1@@6) (= (MapType3Select (MapType3Store m@@33 x0@@12 x1@@9 x2@@1 val@@13) y0@@8 y1@@6 y2@@0) (MapType3Select m@@33 y0@@8 y1@@6 y2@@0))) :qid |mapAx1:MapType3Select:1| :weight 0 ))) (forall ((val@@14 T@U) (m@@34 T@U) (x0@@13 T@U) (x1@@10 T@U) (x2@@2 T@U) (y0@@9 T@U) (y1@@7 T@U) (y2@@1 T@U) ) (!  (or (= x2@@2 y2@@1) (= (MapType3Select (MapType3Store m@@34 x0@@13 x1@@10 x2@@2 val@@14) y0@@9 y1@@7 y2@@1) (MapType3Select m@@34 y0@@9 y1@@7 y2@@1))) :qid |mapAx1:MapType3Select:2| :weight 0 ))) (forall ((val@@15 T@U) (m@@35 T@U) (x0@@14 T@U) (x1@@11 T@U) (x2@@3 T@U) (y0@@10 T@U) (y1@@8 T@U) (y2@@2 T@U) ) (!  (or true (= (MapType3Select (MapType3Store m@@35 x0@@14 x1@@11 x2@@3 val@@15) y0@@10 y1@@8 y2@@2) (MapType3Select m@@35 y0@@10 y1@@8 y2@@2))) :qid |mapAx2:MapType3Select| :weight 0 )))) (forall ((arg0@@126 T@U) (arg1@@62 T@U) (arg2@@27 T@U) (arg3@@10 T@U) (arg4@@2 T@U) (arg5 T@U) (arg6 T@U) ) (! (= (type (Apply2 arg0@@126 arg1@@62 arg2@@27 arg3@@10 arg4@@2 arg5 arg6)) BoxType) :qid |funType:Apply2| :pattern ( (Apply2 arg0@@126 arg1@@62 arg2@@27 arg3@@10 arg4@@2 arg5 arg6)) ))) (forall ((arg0@@127 T@U) (arg1@@63 T@U) (arg2@@28 T@U) ) (! (= (type (Handle2 arg0@@127 arg1@@63 arg2@@28)) HandleTypeType) :qid |funType:Handle2| :pattern ( (Handle2 arg0@@127 arg1@@63 arg2@@28)) ))))
(assert (forall ((t0@@36 T@U) (t1@@15 T@U) (t2 T@U) (heap@@5 T@U) (h@@31 T@U) (r@@11 T@U) (rd@@5 T@U) (bx0@@10 T@U) (bx1 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@36) TyType) (= (type t1@@15) TyType)) (= (type t2) TyType)) (= (type heap@@5) (MapType1Type refType))) (= (type h@@31) (MapType3Type (MapType1Type refType) BoxType BoxType BoxType))) (= (type r@@11) (MapType3Type (MapType1Type refType) BoxType BoxType boolType))) (= (type rd@@5) (MapType3Type (MapType1Type refType) BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@10) BoxType)) (= (type bx1) BoxType)) (= (Apply2 t0@@36 t1@@15 t2 (Handle2 h@@31 r@@11 rd@@5) heap@@5 bx0@@10 bx1) (MapType3Select h@@31 heap@@5 bx0@@10 bx1))) :qid |unknown.0:0| :skolemid |653| :pattern ( (Apply2 t0@@36 t1@@15 t2 (Handle2 h@@31 r@@11 rd@@5) heap@@5 bx0@@10 bx1)) )))
(assert (forall ((t0@@37 T@U) (t1@@16 T@U) (t2@@0 T@U) (heap@@6 T@U) (h@@32 T@U) (r@@12 T@U) (rd@@6 T@U) (bx0@@11 T@U) (bx1@@0 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (= (type t0@@37) TyType) (= (type t1@@16) TyType)) (= (type t2@@0) TyType)) (= (type heap@@6) (MapType1Type refType))) (= (type h@@32) (MapType3Type (MapType1Type refType) BoxType BoxType BoxType))) (= (type r@@12) (MapType3Type (MapType1Type refType) BoxType BoxType boolType))) (= (type rd@@6) (MapType3Type (MapType1Type refType) BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@11) BoxType)) (= (type bx1@@0) BoxType)) (U_2_bool (MapType3Select r@@12 heap@@6 bx0@@11 bx1@@0))) (Requires2 t0@@37 t1@@16 t2@@0 (Handle2 h@@32 r@@12 rd@@6) heap@@6 bx0@@11 bx1@@0)) :qid |unknown.0:0| :skolemid |654| :pattern ( (Requires2 t0@@37 t1@@16 t2@@0 (Handle2 h@@32 r@@12 rd@@6) heap@@6 bx0@@11 bx1@@0)) )))
(assert (forall ((arg0@@128 T@U) (arg1@@64 T@U) (arg2@@29 T@U) (arg3@@11 T@U) (arg4@@3 T@U) (arg5@@0 T@U) (arg6@@0 T@U) ) (! (= (type (Reads2 arg0@@128 arg1@@64 arg2@@29 arg3@@11 arg4@@3 arg5@@0 arg6@@0)) (MapType0Type BoxType boolType)) :qid |funType:Reads2| :pattern ( (Reads2 arg0@@128 arg1@@64 arg2@@29 arg3@@11 arg4@@3 arg5@@0 arg6@@0)) )))
(assert (forall ((t0@@38 T@U) (t1@@17 T@U) (t2@@1 T@U) (heap@@7 T@U) (h@@33 T@U) (r@@13 T@U) (rd@@7 T@U) (bx0@@12 T@U) (bx1@@1 T@U) (bx@@45 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (= (type t0@@38) TyType) (= (type t1@@17) TyType)) (= (type t2@@1) TyType)) (= (type heap@@7) (MapType1Type refType))) (= (type h@@33) (MapType3Type (MapType1Type refType) BoxType BoxType BoxType))) (= (type r@@13) (MapType3Type (MapType1Type refType) BoxType BoxType boolType))) (= (type rd@@7) (MapType3Type (MapType1Type refType) BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@12) BoxType)) (= (type bx1@@1) BoxType)) (= (type bx@@45) BoxType)) (and (=> (U_2_bool (MapType0Select (Reads2 t0@@38 t1@@17 t2@@1 (Handle2 h@@33 r@@13 rd@@7) heap@@7 bx0@@12 bx1@@1) bx@@45)) (U_2_bool (MapType0Select (MapType3Select rd@@7 heap@@7 bx0@@12 bx1@@1) bx@@45))) (=> (U_2_bool (MapType0Select (MapType3Select rd@@7 heap@@7 bx0@@12 bx1@@1) bx@@45)) (U_2_bool (MapType0Select (Reads2 t0@@38 t1@@17 t2@@1 (Handle2 h@@33 r@@13 rd@@7) heap@@7 bx0@@12 bx1@@1) bx@@45))))) :qid |unknown.0:0| :skolemid |655| :pattern ( (MapType0Select (Reads2 t0@@38 t1@@17 t2@@1 (Handle2 h@@33 r@@13 rd@@7) heap@@7 bx0@@12 bx1@@1) bx@@45)) )))
(assert (forall ((t0@@39 T@U) (t1@@18 T@U) (t2@@2 T@U) (h0@@12 T@U) (h1@@12 T@U) (f@@23 T@U) (bx0@@13 T@U) (bx1@@2 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@39) TyType) (= (type t1@@18) TyType)) (= (type t2@@2) TyType)) (= (type h0@@12) (MapType1Type refType))) (= (type h1@@12) (MapType1Type refType))) (= (type f@@23) HandleTypeType)) (= (type bx0@@13) BoxType)) (= (type bx1@@2) BoxType)) (and (and (and ($HeapSucc h0@@12 h1@@12) (and ($IsGoodHeap h0@@12) ($IsGoodHeap h1@@12))) (and (and ($IsBox bx0@@13 t0@@39) ($IsBox bx1@@2 t1@@18)) ($Is f@@23 (Tclass._System.___hFunc2 t0@@39 t1@@18 t2@@2)))) (forall ((o@@51 T@U) (fld@@11 T@U) ) (! (let ((a@@89 (FieldTypeInv0 (type fld@@11)))) (=> (and (and (= (type o@@51) refType) (= (type fld@@11) (FieldType a@@89))) (and (not (= o@@51 null)) (U_2_bool (MapType0Select (Reads2 t0@@39 t1@@18 t2@@2 f@@23 h0@@12 bx0@@13 bx1@@2) ($Box o@@51))))) (= (MapType1Select h0@@12 o@@51 fld@@11) (MapType1Select h1@@12 o@@51 fld@@11)))) :qid |unknown.0:0| :skolemid |656| :no-pattern (type o@@51) :no-pattern (type fld@@11) :no-pattern (U_2_int o@@51) :no-pattern (U_2_bool o@@51) :no-pattern (U_2_int fld@@11) :no-pattern (U_2_bool fld@@11) )))) (= (Reads2 t0@@39 t1@@18 t2@@2 f@@23 h0@@12 bx0@@13 bx1@@2) (Reads2 t0@@39 t1@@18 t2@@2 f@@23 h1@@12 bx0@@13 bx1@@2))) :qid |unknown.0:0| :skolemid |657| :pattern ( ($HeapSucc h0@@12 h1@@12) (Reads2 t0@@39 t1@@18 t2@@2 f@@23 h1@@12 bx0@@13 bx1@@2)) )))
(assert (forall ((t0@@40 T@U) (t1@@19 T@U) (t2@@3 T@U) (h0@@13 T@U) (h1@@13 T@U) (f@@24 T@U) (bx0@@14 T@U) (bx1@@3 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@40) TyType) (= (type t1@@19) TyType)) (= (type t2@@3) TyType)) (= (type h0@@13) (MapType1Type refType))) (= (type h1@@13) (MapType1Type refType))) (= (type f@@24) HandleTypeType)) (= (type bx0@@14) BoxType)) (= (type bx1@@3) BoxType)) (and (and (and ($HeapSucc h0@@13 h1@@13) (and ($IsGoodHeap h0@@13) ($IsGoodHeap h1@@13))) (and (and ($IsBox bx0@@14 t0@@40) ($IsBox bx1@@3 t1@@19)) ($Is f@@24 (Tclass._System.___hFunc2 t0@@40 t1@@19 t2@@3)))) (forall ((o@@52 T@U) (fld@@12 T@U) ) (! (let ((a@@90 (FieldTypeInv0 (type fld@@12)))) (=> (and (and (= (type o@@52) refType) (= (type fld@@12) (FieldType a@@90))) (and (not (= o@@52 null)) (U_2_bool (MapType0Select (Reads2 t0@@40 t1@@19 t2@@3 f@@24 h1@@13 bx0@@14 bx1@@3) ($Box o@@52))))) (= (MapType1Select h0@@13 o@@52 fld@@12) (MapType1Select h1@@13 o@@52 fld@@12)))) :qid |unknown.0:0| :skolemid |658| :no-pattern (type o@@52) :no-pattern (type fld@@12) :no-pattern (U_2_int o@@52) :no-pattern (U_2_bool o@@52) :no-pattern (U_2_int fld@@12) :no-pattern (U_2_bool fld@@12) )))) (= (Reads2 t0@@40 t1@@19 t2@@3 f@@24 h0@@13 bx0@@14 bx1@@3) (Reads2 t0@@40 t1@@19 t2@@3 f@@24 h1@@13 bx0@@14 bx1@@3))) :qid |unknown.0:0| :skolemid |659| :pattern ( ($HeapSucc h0@@13 h1@@13) (Reads2 t0@@40 t1@@19 t2@@3 f@@24 h1@@13 bx0@@14 bx1@@3)) )))
(assert (forall ((t0@@41 T@U) (t1@@20 T@U) (t2@@4 T@U) (h0@@14 T@U) (h1@@14 T@U) (f@@25 T@U) (bx0@@15 T@U) (bx1@@4 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@41) TyType) (= (type t1@@20) TyType)) (= (type t2@@4) TyType)) (= (type h0@@14) (MapType1Type refType))) (= (type h1@@14) (MapType1Type refType))) (= (type f@@25) HandleTypeType)) (= (type bx0@@15) BoxType)) (= (type bx1@@4) BoxType)) (and (and (and ($HeapSucc h0@@14 h1@@14) (and ($IsGoodHeap h0@@14) ($IsGoodHeap h1@@14))) (and (and ($IsBox bx0@@15 t0@@41) ($IsBox bx1@@4 t1@@20)) ($Is f@@25 (Tclass._System.___hFunc2 t0@@41 t1@@20 t2@@4)))) (forall ((o@@53 T@U) (fld@@13 T@U) ) (! (let ((a@@91 (FieldTypeInv0 (type fld@@13)))) (=> (and (and (= (type o@@53) refType) (= (type fld@@13) (FieldType a@@91))) (and (not (= o@@53 null)) (U_2_bool (MapType0Select (Reads2 t0@@41 t1@@20 t2@@4 f@@25 h0@@14 bx0@@15 bx1@@4) ($Box o@@53))))) (= (MapType1Select h0@@14 o@@53 fld@@13) (MapType1Select h1@@14 o@@53 fld@@13)))) :qid |unknown.0:0| :skolemid |660| :no-pattern (type o@@53) :no-pattern (type fld@@13) :no-pattern (U_2_int o@@53) :no-pattern (U_2_bool o@@53) :no-pattern (U_2_int fld@@13) :no-pattern (U_2_bool fld@@13) )))) (and (=> (Requires2 t0@@41 t1@@20 t2@@4 f@@25 h0@@14 bx0@@15 bx1@@4) (Requires2 t0@@41 t1@@20 t2@@4 f@@25 h1@@14 bx0@@15 bx1@@4)) (=> (Requires2 t0@@41 t1@@20 t2@@4 f@@25 h1@@14 bx0@@15 bx1@@4) (Requires2 t0@@41 t1@@20 t2@@4 f@@25 h0@@14 bx0@@15 bx1@@4)))) :qid |unknown.0:0| :skolemid |661| :pattern ( ($HeapSucc h0@@14 h1@@14) (Requires2 t0@@41 t1@@20 t2@@4 f@@25 h1@@14 bx0@@15 bx1@@4)) )))
(assert (forall ((t0@@42 T@U) (t1@@21 T@U) (t2@@5 T@U) (h0@@15 T@U) (h1@@15 T@U) (f@@26 T@U) (bx0@@16 T@U) (bx1@@5 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@42) TyType) (= (type t1@@21) TyType)) (= (type t2@@5) TyType)) (= (type h0@@15) (MapType1Type refType))) (= (type h1@@15) (MapType1Type refType))) (= (type f@@26) HandleTypeType)) (= (type bx0@@16) BoxType)) (= (type bx1@@5) BoxType)) (and (and (and ($HeapSucc h0@@15 h1@@15) (and ($IsGoodHeap h0@@15) ($IsGoodHeap h1@@15))) (and (and ($IsBox bx0@@16 t0@@42) ($IsBox bx1@@5 t1@@21)) ($Is f@@26 (Tclass._System.___hFunc2 t0@@42 t1@@21 t2@@5)))) (forall ((o@@54 T@U) (fld@@14 T@U) ) (! (let ((a@@92 (FieldTypeInv0 (type fld@@14)))) (=> (and (and (= (type o@@54) refType) (= (type fld@@14) (FieldType a@@92))) (and (not (= o@@54 null)) (U_2_bool (MapType0Select (Reads2 t0@@42 t1@@21 t2@@5 f@@26 h1@@15 bx0@@16 bx1@@5) ($Box o@@54))))) (= (MapType1Select h0@@15 o@@54 fld@@14) (MapType1Select h1@@15 o@@54 fld@@14)))) :qid |unknown.0:0| :skolemid |662| :no-pattern (type o@@54) :no-pattern (type fld@@14) :no-pattern (U_2_int o@@54) :no-pattern (U_2_bool o@@54) :no-pattern (U_2_int fld@@14) :no-pattern (U_2_bool fld@@14) )))) (and (=> (Requires2 t0@@42 t1@@21 t2@@5 f@@26 h0@@15 bx0@@16 bx1@@5) (Requires2 t0@@42 t1@@21 t2@@5 f@@26 h1@@15 bx0@@16 bx1@@5)) (=> (Requires2 t0@@42 t1@@21 t2@@5 f@@26 h1@@15 bx0@@16 bx1@@5) (Requires2 t0@@42 t1@@21 t2@@5 f@@26 h0@@15 bx0@@16 bx1@@5)))) :qid |unknown.0:0| :skolemid |663| :pattern ( ($HeapSucc h0@@15 h1@@15) (Requires2 t0@@42 t1@@21 t2@@5 f@@26 h1@@15 bx0@@16 bx1@@5)) )))
(assert (forall ((t0@@43 T@U) (t1@@22 T@U) (t2@@6 T@U) (h0@@16 T@U) (h1@@16 T@U) (f@@27 T@U) (bx0@@17 T@U) (bx1@@6 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@43) TyType) (= (type t1@@22) TyType)) (= (type t2@@6) TyType)) (= (type h0@@16) (MapType1Type refType))) (= (type h1@@16) (MapType1Type refType))) (= (type f@@27) HandleTypeType)) (= (type bx0@@17) BoxType)) (= (type bx1@@6) BoxType)) (and (and (and ($HeapSucc h0@@16 h1@@16) (and ($IsGoodHeap h0@@16) ($IsGoodHeap h1@@16))) (and (and ($IsBox bx0@@17 t0@@43) ($IsBox bx1@@6 t1@@22)) ($Is f@@27 (Tclass._System.___hFunc2 t0@@43 t1@@22 t2@@6)))) (forall ((o@@55 T@U) (fld@@15 T@U) ) (! (let ((a@@93 (FieldTypeInv0 (type fld@@15)))) (=> (and (and (= (type o@@55) refType) (= (type fld@@15) (FieldType a@@93))) (and (not (= o@@55 null)) (U_2_bool (MapType0Select (Reads2 t0@@43 t1@@22 t2@@6 f@@27 h0@@16 bx0@@17 bx1@@6) ($Box o@@55))))) (= (MapType1Select h0@@16 o@@55 fld@@15) (MapType1Select h1@@16 o@@55 fld@@15)))) :qid |unknown.0:0| :skolemid |664| :no-pattern (type o@@55) :no-pattern (type fld@@15) :no-pattern (U_2_int o@@55) :no-pattern (U_2_bool o@@55) :no-pattern (U_2_int fld@@15) :no-pattern (U_2_bool fld@@15) )))) (= (Apply2 t0@@43 t1@@22 t2@@6 f@@27 h0@@16 bx0@@17 bx1@@6) (Apply2 t0@@43 t1@@22 t2@@6 f@@27 h1@@16 bx0@@17 bx1@@6))) :qid |unknown.0:0| :skolemid |665| :pattern ( ($HeapSucc h0@@16 h1@@16) (Apply2 t0@@43 t1@@22 t2@@6 f@@27 h1@@16 bx0@@17 bx1@@6)) )))
(assert (forall ((t0@@44 T@U) (t1@@23 T@U) (t2@@7 T@U) (h0@@17 T@U) (h1@@17 T@U) (f@@28 T@U) (bx0@@18 T@U) (bx1@@7 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@44) TyType) (= (type t1@@23) TyType)) (= (type t2@@7) TyType)) (= (type h0@@17) (MapType1Type refType))) (= (type h1@@17) (MapType1Type refType))) (= (type f@@28) HandleTypeType)) (= (type bx0@@18) BoxType)) (= (type bx1@@7) BoxType)) (and (and (and ($HeapSucc h0@@17 h1@@17) (and ($IsGoodHeap h0@@17) ($IsGoodHeap h1@@17))) (and (and ($IsBox bx0@@18 t0@@44) ($IsBox bx1@@7 t1@@23)) ($Is f@@28 (Tclass._System.___hFunc2 t0@@44 t1@@23 t2@@7)))) (forall ((o@@56 T@U) (fld@@16 T@U) ) (! (let ((a@@94 (FieldTypeInv0 (type fld@@16)))) (=> (and (and (= (type o@@56) refType) (= (type fld@@16) (FieldType a@@94))) (and (not (= o@@56 null)) (U_2_bool (MapType0Select (Reads2 t0@@44 t1@@23 t2@@7 f@@28 h1@@17 bx0@@18 bx1@@7) ($Box o@@56))))) (= (MapType1Select h0@@17 o@@56 fld@@16) (MapType1Select h1@@17 o@@56 fld@@16)))) :qid |unknown.0:0| :skolemid |666| :no-pattern (type o@@56) :no-pattern (type fld@@16) :no-pattern (U_2_int o@@56) :no-pattern (U_2_bool o@@56) :no-pattern (U_2_int fld@@16) :no-pattern (U_2_bool fld@@16) )))) (= (Apply2 t0@@44 t1@@23 t2@@7 f@@28 h0@@17 bx0@@18 bx1@@7) (Apply2 t0@@44 t1@@23 t2@@7 f@@28 h1@@17 bx0@@18 bx1@@7))) :qid |unknown.0:0| :skolemid |667| :pattern ( ($HeapSucc h0@@17 h1@@17) (Apply2 t0@@44 t1@@23 t2@@7 f@@28 h1@@17 bx0@@18 bx1@@7)) )))
(assert (forall ((f@@29 T@U) (t0@@45 T@U) (t1@@24 T@U) (t2@@8 T@U) ) (!  (=> (and (and (and (= (type f@@29) HandleTypeType) (= (type t0@@45) TyType)) (= (type t1@@24) TyType)) (= (type t2@@8) TyType)) (and (=> ($Is f@@29 (Tclass._System.___hFunc2 t0@@45 t1@@24 t2@@8)) (forall ((h@@34 T@U) (bx0@@19 T@U) (bx1@@8 T@U) ) (!  (=> (and (and (and (= (type h@@34) (MapType1Type refType)) (= (type bx0@@19) BoxType)) (= (type bx1@@8) BoxType)) (and (and ($IsGoodHeap h@@34) (and ($IsBox bx0@@19 t0@@45) ($IsBox bx1@@8 t1@@24))) (Requires2 t0@@45 t1@@24 t2@@8 f@@29 h@@34 bx0@@19 bx1@@8))) ($IsBox (Apply2 t0@@45 t1@@24 t2@@8 f@@29 h@@34 bx0@@19 bx1@@8) t2@@8)) :qid |DafnyPre.405:12| :skolemid |668| :pattern ( (Apply2 t0@@45 t1@@24 t2@@8 f@@29 h@@34 bx0@@19 bx1@@8)) ))) (=> (forall ((h@@35 T@U) (bx0@@20 T@U) (bx1@@9 T@U) ) (!  (=> (and (and (and (= (type h@@35) (MapType1Type refType)) (= (type bx0@@20) BoxType)) (= (type bx1@@9) BoxType)) (and (and ($IsGoodHeap h@@35) (and ($IsBox bx0@@20 t0@@45) ($IsBox bx1@@9 t1@@24))) (Requires2 t0@@45 t1@@24 t2@@8 f@@29 h@@35 bx0@@20 bx1@@9))) ($IsBox (Apply2 t0@@45 t1@@24 t2@@8 f@@29 h@@35 bx0@@20 bx1@@9) t2@@8)) :qid |DafnyPre.405:12| :skolemid |668| :pattern ( (Apply2 t0@@45 t1@@24 t2@@8 f@@29 h@@35 bx0@@20 bx1@@9)) )) ($Is f@@29 (Tclass._System.___hFunc2 t0@@45 t1@@24 t2@@8))))) :qid |unknown.0:0| :skolemid |669| :pattern ( ($Is f@@29 (Tclass._System.___hFunc2 t0@@45 t1@@24 t2@@8))) )))
(assert (forall ((f@@30 T@U) (t0@@46 T@U) (t1@@25 T@U) (t2@@9 T@U) (u0@@1 T@U) (u1@@0 T@U) (u2 T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type f@@30) HandleTypeType) (= (type t0@@46) TyType)) (= (type t1@@25) TyType)) (= (type t2@@9) TyType)) (= (type u0@@1) TyType)) (= (type u1@@0) TyType)) (= (type u2) TyType)) (and (and (and ($Is f@@30 (Tclass._System.___hFunc2 t0@@46 t1@@25 t2@@9)) (forall ((bx@@46 T@U) ) (!  (=> (and (= (type bx@@46) BoxType) ($IsBox bx@@46 u0@@1)) ($IsBox bx@@46 t0@@46)) :qid |unknown.0:0| :skolemid |670| :pattern ( ($IsBox bx@@46 u0@@1)) :pattern ( ($IsBox bx@@46 t0@@46)) ))) (forall ((bx@@47 T@U) ) (!  (=> (and (= (type bx@@47) BoxType) ($IsBox bx@@47 u1@@0)) ($IsBox bx@@47 t1@@25)) :qid |unknown.0:0| :skolemid |671| :pattern ( ($IsBox bx@@47 u1@@0)) :pattern ( ($IsBox bx@@47 t1@@25)) ))) (forall ((bx@@48 T@U) ) (!  (=> (and (= (type bx@@48) BoxType) ($IsBox bx@@48 t2@@9)) ($IsBox bx@@48 u2)) :qid |unknown.0:0| :skolemid |672| :pattern ( ($IsBox bx@@48 t2@@9)) :pattern ( ($IsBox bx@@48 u2)) )))) ($Is f@@30 (Tclass._System.___hFunc2 u0@@1 u1@@0 u2))) :qid |unknown.0:0| :skolemid |673| :pattern ( ($Is f@@30 (Tclass._System.___hFunc2 t0@@46 t1@@25 t2@@9)) ($Is f@@30 (Tclass._System.___hFunc2 u0@@1 u1@@0 u2))) )))
(assert (forall ((f@@31 T@U) (t0@@47 T@U) (t1@@26 T@U) (t2@@10 T@U) (h@@36 T@U) ) (!  (=> (and (and (and (and (and (= (type f@@31) HandleTypeType) (= (type t0@@47) TyType)) (= (type t1@@26) TyType)) (= (type t2@@10) TyType)) (= (type h@@36) (MapType1Type refType))) ($IsGoodHeap h@@36)) ($IsAlloc f@@31 (Tclass._System.___hFunc2 t0@@47 t1@@26 t2@@10) h@@36)) :qid |unknown.0:0| :skolemid |675| :pattern ( ($IsAlloc f@@31 (Tclass._System.___hFunc2 t0@@47 t1@@26 t2@@10) h@@36)) )))
(assert  (and (forall ((arg0@@129 T@U) (arg1@@65 T@U) ) (! (= (type (|#_System._tuple#2._#Make2| arg0@@129 arg1@@65)) DatatypeTypeType) :qid |funType:#_System._tuple#2._#Make2| :pattern ( (|#_System._tuple#2._#Make2| arg0@@129 arg1@@65)) )) (forall ((arg0@@130 T@U) ) (! (= (type (DatatypeCtorId arg0@@130)) DtCtorIdType) :qid |funType:DatatypeCtorId| :pattern ( (DatatypeCtorId arg0@@130)) ))))
(assert (forall ((|a#0#0#0| T@U) (|a#0#1#0| T@U) ) (!  (=> (and (= (type |a#0#0#0|) BoxType) (= (type |a#0#1#0|) BoxType)) (= (DatatypeCtorId (|#_System._tuple#2._#Make2| |a#0#0#0| |a#0#1#0|)) |##_System._tuple#2._#Make2|)) :qid |unknown.0:0| :skolemid |676| :pattern ( (|#_System._tuple#2._#Make2| |a#0#0#0| |a#0#1#0|)) )))
(assert (forall ((d@@0 T@U) ) (!  (=> (= (type d@@0) DatatypeTypeType) (and (=> (_System.__tuple_h2.___hMake2_q d@@0) (= (DatatypeCtorId d@@0) |##_System._tuple#2._#Make2|)) (=> (= (DatatypeCtorId d@@0) |##_System._tuple#2._#Make2|) (_System.__tuple_h2.___hMake2_q d@@0)))) :qid |unknown.0:0| :skolemid |677| :pattern ( (_System.__tuple_h2.___hMake2_q d@@0)) )))
(assert (forall ((d@@1 T@U) ) (!  (=> (and (= (type d@@1) DatatypeTypeType) (_System.__tuple_h2.___hMake2_q d@@1)) (exists ((|a#1#0#0| T@U) (|a#1#1#0| T@U) ) (!  (and (and (= (type |a#1#0#0|) BoxType) (= (type |a#1#1#0|) BoxType)) (= d@@1 (|#_System._tuple#2._#Make2| |a#1#0#0| |a#1#1#0|))) :qid |unknown.0:0| :skolemid |678| :no-pattern (type |a#1#0#0|) :no-pattern (type |a#1#1#0|) :no-pattern (U_2_int |a#1#0#0|) :no-pattern (U_2_bool |a#1#0#0|) :no-pattern (U_2_int |a#1#1#0|) :no-pattern (U_2_bool |a#1#1#0|) ))) :qid |unknown.0:0| :skolemid |679| :pattern ( (_System.__tuple_h2.___hMake2_q d@@1)) )))
(assert (forall ((arg0@@131 T@U) (arg1@@66 T@U) ) (! (= (type (Tclass._System.__tuple_h2 arg0@@131 arg1@@66)) TyType) :qid |funType:Tclass._System.__tuple_h2| :pattern ( (Tclass._System.__tuple_h2 arg0@@131 arg1@@66)) )))
(assert (forall ((|#$T0@@11| T@U) (|#$T1@@8| T@U) ) (!  (=> (and (= (type |#$T0@@11|) TyType) (= (type |#$T1@@8|) TyType)) (= (Tag (Tclass._System.__tuple_h2 |#$T0@@11| |#$T1@@8|)) Tagclass._System.__tuple_h2)) :qid |unknown.0:0| :skolemid |680| :pattern ( (Tclass._System.__tuple_h2 |#$T0@@11| |#$T1@@8|)) )))
(assert (forall ((arg0@@132 T@U) ) (! (= (type (Tclass._System.__tuple_h2_0 arg0@@132)) TyType) :qid |funType:Tclass._System.__tuple_h2_0| :pattern ( (Tclass._System.__tuple_h2_0 arg0@@132)) )))
(assert (forall ((|#$T0@@12| T@U) (|#$T1@@9| T@U) ) (!  (=> (and (= (type |#$T0@@12|) TyType) (= (type |#$T1@@9|) TyType)) (= (Tclass._System.__tuple_h2_0 (Tclass._System.__tuple_h2 |#$T0@@12| |#$T1@@9|)) |#$T0@@12|)) :qid |unknown.0:0| :skolemid |681| :pattern ( (Tclass._System.__tuple_h2 |#$T0@@12| |#$T1@@9|)) )))
(assert (forall ((arg0@@133 T@U) ) (! (= (type (Tclass._System.__tuple_h2_1 arg0@@133)) TyType) :qid |funType:Tclass._System.__tuple_h2_1| :pattern ( (Tclass._System.__tuple_h2_1 arg0@@133)) )))
(assert (forall ((|#$T0@@13| T@U) (|#$T1@@10| T@U) ) (!  (=> (and (= (type |#$T0@@13|) TyType) (= (type |#$T1@@10|) TyType)) (= (Tclass._System.__tuple_h2_1 (Tclass._System.__tuple_h2 |#$T0@@13| |#$T1@@10|)) |#$T1@@10|)) :qid |unknown.0:0| :skolemid |682| :pattern ( (Tclass._System.__tuple_h2 |#$T0@@13| |#$T1@@10|)) )))
(assert (forall ((|#$T0@@14| T@U) (|#$T1@@11| T@U) (bx@@49 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@14|) TyType) (= (type |#$T1@@11|) TyType)) (= (type bx@@49) BoxType)) ($IsBox bx@@49 (Tclass._System.__tuple_h2 |#$T0@@14| |#$T1@@11|))) (and (= ($Box ($Unbox DatatypeTypeType bx@@49)) bx@@49) ($Is ($Unbox DatatypeTypeType bx@@49) (Tclass._System.__tuple_h2 |#$T0@@14| |#$T1@@11|)))) :qid |unknown.0:0| :skolemid |683| :pattern ( ($IsBox bx@@49 (Tclass._System.__tuple_h2 |#$T0@@14| |#$T1@@11|))) )))
(assert (forall ((|#$T0@@15| T@U) (|#$T1@@12| T@U) (|a#2#0#0| T@U) (|a#2#1#0| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@15|) TyType) (= (type |#$T1@@12|) TyType)) (= (type |a#2#0#0|) BoxType)) (= (type |a#2#1#0|) BoxType)) (and (=> ($Is (|#_System._tuple#2._#Make2| |a#2#0#0| |a#2#1#0|) (Tclass._System.__tuple_h2 |#$T0@@15| |#$T1@@12|)) (and ($IsBox |a#2#0#0| |#$T0@@15|) ($IsBox |a#2#1#0| |#$T1@@12|))) (=> (and ($IsBox |a#2#0#0| |#$T0@@15|) ($IsBox |a#2#1#0| |#$T1@@12|)) ($Is (|#_System._tuple#2._#Make2| |a#2#0#0| |a#2#1#0|) (Tclass._System.__tuple_h2 |#$T0@@15| |#$T1@@12|))))) :qid |unknown.0:0| :skolemid |684| :pattern ( ($Is (|#_System._tuple#2._#Make2| |a#2#0#0| |a#2#1#0|) (Tclass._System.__tuple_h2 |#$T0@@15| |#$T1@@12|))) )))
(assert (forall ((|#$T0@@16| T@U) (|#$T1@@13| T@U) (|a#3#0#0| T@U) (|a#3#1#0| T@U) ($h@@4 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@16|) TyType) (= (type |#$T1@@13|) TyType)) (= (type |a#3#0#0|) BoxType)) (= (type |a#3#1#0|) BoxType)) (= (type $h@@4) (MapType1Type refType))) ($IsGoodHeap $h@@4)) (and (=> ($IsAlloc (|#_System._tuple#2._#Make2| |a#3#0#0| |a#3#1#0|) (Tclass._System.__tuple_h2 |#$T0@@16| |#$T1@@13|) $h@@4) (and ($IsAllocBox |a#3#0#0| |#$T0@@16| $h@@4) ($IsAllocBox |a#3#1#0| |#$T1@@13| $h@@4))) (=> (and ($IsAllocBox |a#3#0#0| |#$T0@@16| $h@@4) ($IsAllocBox |a#3#1#0| |#$T1@@13| $h@@4)) ($IsAlloc (|#_System._tuple#2._#Make2| |a#3#0#0| |a#3#1#0|) (Tclass._System.__tuple_h2 |#$T0@@16| |#$T1@@13|) $h@@4)))) :qid |unknown.0:0| :skolemid |685| :pattern ( ($IsAlloc (|#_System._tuple#2._#Make2| |a#3#0#0| |a#3#1#0|) (Tclass._System.__tuple_h2 |#$T0@@16| |#$T1@@13|) $h@@4)) )))
(assert (forall ((|a#4#0#0| T@U) (|a#4#1#0| T@U) ) (!  (=> (and (= (type |a#4#0#0|) BoxType) (= (type |a#4#1#0|) BoxType)) (= (|#_System._tuple#2._#Make2| (Lit |a#4#0#0|) (Lit |a#4#1#0|)) (Lit (|#_System._tuple#2._#Make2| |a#4#0#0| |a#4#1#0|)))) :qid |unknown.0:0| :skolemid |686| :pattern ( (|#_System._tuple#2._#Make2| (Lit |a#4#0#0|) (Lit |a#4#1#0|))) )))
(assert (forall ((|a#5#0#0| T@U) (|a#5#1#0| T@U) ) (!  (=> (and (= (type |a#5#0#0|) BoxType) (= (type |a#5#1#0|) BoxType)) (= (_System.__tuple_h2._0 (|#_System._tuple#2._#Make2| |a#5#0#0| |a#5#1#0|)) |a#5#0#0|)) :qid |unknown.0:0| :skolemid |687| :pattern ( (|#_System._tuple#2._#Make2| |a#5#0#0| |a#5#1#0|)) )))
(assert (forall ((|a#6#0#0| T@U) (|a#6#1#0| T@U) ) (!  (=> (and (= (type |a#6#0#0|) BoxType) (= (type |a#6#1#0|) BoxType)) (< (BoxRank |a#6#0#0|) (DtRank (|#_System._tuple#2._#Make2| |a#6#0#0| |a#6#1#0|)))) :qid |unknown.0:0| :skolemid |688| :pattern ( (|#_System._tuple#2._#Make2| |a#6#0#0| |a#6#1#0|)) )))
(assert (forall ((|a#7#0#0| T@U) (|a#7#1#0| T@U) ) (!  (=> (and (= (type |a#7#0#0|) BoxType) (= (type |a#7#1#0|) BoxType)) (= (_System.__tuple_h2._1 (|#_System._tuple#2._#Make2| |a#7#0#0| |a#7#1#0|)) |a#7#1#0|)) :qid |unknown.0:0| :skolemid |689| :pattern ( (|#_System._tuple#2._#Make2| |a#7#0#0| |a#7#1#0|)) )))
(assert (forall ((|a#8#0#0| T@U) (|a#8#1#0| T@U) ) (!  (=> (and (= (type |a#8#0#0|) BoxType) (= (type |a#8#1#0|) BoxType)) (< (BoxRank |a#8#1#0|) (DtRank (|#_System._tuple#2._#Make2| |a#8#0#0| |a#8#1#0|)))) :qid |unknown.0:0| :skolemid |690| :pattern ( (|#_System._tuple#2._#Make2| |a#8#0#0| |a#8#1#0|)) )))
(assert (forall ((d@@2 T@U) ) (!  (=> (and (= (type d@@2) DatatypeTypeType) (|$IsA#_System.__tuple_h2| d@@2)) (_System.__tuple_h2.___hMake2_q d@@2)) :qid |unknown.0:0| :skolemid |691| :pattern ( (|$IsA#_System.__tuple_h2| d@@2)) )))
(assert (forall ((|#$T0@@17| T@U) (|#$T1@@14| T@U) (d@@3 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@17|) TyType) (= (type |#$T1@@14|) TyType)) (= (type d@@3) DatatypeTypeType)) ($Is d@@3 (Tclass._System.__tuple_h2 |#$T0@@17| |#$T1@@14|))) (_System.__tuple_h2.___hMake2_q d@@3)) :qid |unknown.0:0| :skolemid |692| :pattern ( (_System.__tuple_h2.___hMake2_q d@@3) ($Is d@@3 (Tclass._System.__tuple_h2 |#$T0@@17| |#$T1@@14|))) )))
(assert (= (type Tclass._module.__default) TyType))
(assert (= (Tag Tclass._module.__default) Tagclass._module.__default))
(assert (forall ((bx@@50 T@U) ) (!  (=> (and (= (type bx@@50) BoxType) ($IsBox bx@@50 Tclass._module.__default)) (and (= ($Box ($Unbox refType bx@@50)) bx@@50) ($Is ($Unbox refType bx@@50) Tclass._module.__default))) :qid |unknown.0:0| :skolemid |693| :pattern ( ($IsBox bx@@50 Tclass._module.__default)) )))
(assert (forall (($o@@5 T@U) ) (!  (=> (= (type $o@@5) refType) (and (=> ($Is $o@@5 Tclass._module.__default) (or (= $o@@5 null) (= (dtype $o@@5) Tclass._module.__default))) (=> (or (= $o@@5 null) (= (dtype $o@@5) Tclass._module.__default)) ($Is $o@@5 Tclass._module.__default)))) :qid |unknown.0:0| :skolemid |694| :pattern ( ($Is $o@@5 Tclass._module.__default)) )))
(assert (forall (($o@@6 T@U) ($h@@5 T@U) ) (!  (=> (and (= (type $o@@6) refType) (= (type $h@@5) (MapType1Type refType))) (and (=> ($IsAlloc $o@@6 Tclass._module.__default $h@@5) (or (= $o@@6 null) (U_2_bool (MapType1Select $h@@5 $o@@6 alloc)))) (=> (or (= $o@@6 null) (U_2_bool (MapType1Select $h@@5 $o@@6 alloc))) ($IsAlloc $o@@6 Tclass._module.__default $h@@5)))) :qid |unknown.0:0| :skolemid |695| :pattern ( ($IsAlloc $o@@6 Tclass._module.__default $h@@5)) )))
(assert (= (type Tclass._module.word) TyType))
(assert (= (Tag Tclass._module.word) Tagclass._module.word))
(assert (forall ((bx@@51 T@U) ) (!  (=> (and (= (type bx@@51) BoxType) ($IsBox bx@@51 Tclass._module.word)) (and (= ($Box ($Unbox intType bx@@51)) bx@@51) ($Is ($Unbox intType bx@@51) Tclass._module.word))) :qid |unknown.0:0| :skolemid |711| :pattern ( ($IsBox bx@@51 Tclass._module.word)) )))
(assert (forall (($ly T@U) (|i#0| Int) ) (!  (=> (= (type $ly) LayerTypeType) (= (_module.__default.WordAsBits ($LS $ly) |i#0|) (_module.__default.WordAsBits $ly |i#0|))) :qid |bitvecto.15:27| :skolemid |801| :pattern ( (_module.__default.WordAsBits ($LS $ly) |i#0|)) )))
(assert  (and (forall ((arg0@@134 T@U) ) (! (= (type (AsFuelBottom arg0@@134)) LayerTypeType) :qid |funType:AsFuelBottom| :pattern ( (AsFuelBottom arg0@@134)) )) (= (type $LZ) LayerTypeType)))
(assert (forall (($ly@@0 T@U) (|i#0@@0| Int) ) (!  (=> (= (type $ly@@0) LayerTypeType) (= (_module.__default.WordAsBits $ly@@0 |i#0@@0|) (_module.__default.WordAsBits $LZ |i#0@@0|))) :qid |bitvecto.15:27| :skolemid |802| :pattern ( (_module.__default.WordAsBits (AsFuelBottom $ly@@0) |i#0@@0|)) )))
(assert  (and (and (and (forall ((arg0@@135 (_ BitVec 32)) ) (! (= (U_2_bv32 (bv32_2_U arg0@@135)) arg0@@135) :qid |typeInv:U_2_bv32| :pattern ( (bv32_2_U arg0@@135)) )) (= (Ctor bv32Type) 22)) (forall ((x@@49 T@U) ) (!  (=> (= (type x@@49) bv32Type) (= (bv32_2_U (U_2_bv32 x@@49)) x@@49)) :qid |cast:U_2_bv32| :pattern ( (U_2_bv32 x@@49)) ))) (forall ((arg0@@136 (_ BitVec 32)) ) (! (= (type (bv32_2_U arg0@@136)) bv32Type) :qid |funType:bv32_2_U| :pattern ( (bv32_2_U arg0@@136)) ))))
(assert  (=> true (forall (($ly@@1 T@U) (|i#0@@1| Int) ) (!  (=> (and (= (type $ly@@1) LayerTypeType) (or (|_module.__default.WordAsBits#canCall| |i#0@@1|) (_module.__default.isUInt32 |i#0@@1|))) (and (=> (= |i#0@@1| (LitInt 0)) (= (_module.__default.WordAsBits $ly@@1 |i#0@@1|) (U_2_bv32 (Lit (bv32_2_U #x00000000))))) (=> (= (_module.__default.WordAsBits $ly@@1 |i#0@@1|) (U_2_bv32 (Lit (bv32_2_U #x00000000)))) (= |i#0@@1| (LitInt 0))))) :qid |bitvecto.15:27| :skolemid |803| :pattern ( (_module.__default.WordAsBits $ly@@1 |i#0@@1|)) ))))
(assert (forall (($ly@@2 T@U) (|i#0@@2| Int) ) (!  (=> (and (= (type $ly@@2) LayerTypeType) (_module.__default.isUInt32 |i#0@@2|)) (and (=> (|_module.__default.WordAsBits#requires| $ly@@2 |i#0@@2|) true) (=> true (|_module.__default.WordAsBits#requires| $ly@@2 |i#0@@2|)))) :qid |bitvecto.15:27| :skolemid |804| :pattern ( (|_module.__default.WordAsBits#requires| $ly@@2 |i#0@@2|)) )))
(assert  (=> true (forall (($ly@@3 T@U) (|i#0@@3| Int) ) (!  (=> (and (= (type $ly@@3) LayerTypeType) (or (|_module.__default.WordAsBits#canCall| |i#0@@3|) (_module.__default.isUInt32 |i#0@@3|))) (= (_module.__default.WordAsBits ($LS $ly@@3) |i#0@@3|) ((_ int2bv 32) |i#0@@3|))) :qid |bitvecto.15:27| :skolemid |805| :pattern ( (_module.__default.WordAsBits ($LS $ly@@3) |i#0@@3|)) ))))
(assert  (=> true (forall (($ly@@4 T@U) (|i#0@@4| Int) ) (!  (=> (and (= (type $ly@@4) LayerTypeType) (or (|_module.__default.WordAsBits#canCall| (LitInt |i#0@@4|)) (_module.__default.isUInt32 |i#0@@4|))) (= (_module.__default.WordAsBits ($LS $ly@@4) (LitInt |i#0@@4|)) ((_ int2bv 32) (LitInt |i#0@@4|)))) :qid |bitvecto.15:27| :weight 3 :skolemid |806| :pattern ( (_module.__default.WordAsBits ($LS $ly@@4) (LitInt |i#0@@4|))) ))))
(assert (forall (($ly@@5 T@U) (|b#0| (_ BitVec 32)) ) (!  (=> (= (type $ly@@5) LayerTypeType) (= (_module.__default.BitsAsWord ($LS $ly@@5) |b#0|) (_module.__default.BitsAsWord $ly@@5 |b#0|))) :qid |bitvecto.26:27| :skolemid |807| :pattern ( (_module.__default.BitsAsWord ($LS $ly@@5) |b#0|)) )))
(assert (forall (($ly@@6 T@U) (|b#0@@0| (_ BitVec 32)) ) (!  (=> (= (type $ly@@6) LayerTypeType) (= (_module.__default.BitsAsWord $ly@@6 |b#0@@0|) (_module.__default.BitsAsWord $LZ |b#0@@0|))) :qid |bitvecto.26:27| :skolemid |808| :pattern ( (_module.__default.BitsAsWord (AsFuelBottom $ly@@6) |b#0@@0|)) )))
(assert  (=> true (forall (($ly@@7 T@U) (|b#0@@1| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@7) LayerTypeType) true) (and (and (=> (= |b#0@@1| (U_2_bv32 (Lit (bv32_2_U #x00000000)))) (= (_module.__default.BitsAsWord $ly@@7 |b#0@@1|) (LitInt 0))) (=> (= (_module.__default.BitsAsWord $ly@@7 |b#0@@1|) (LitInt 0)) (= |b#0@@1| (U_2_bv32 (Lit (bv32_2_U #x00000000)))))) (_module.__default.isUInt32 (_module.__default.BitsAsWord $ly@@7 |b#0@@1|)))) :qid |bitvecto.26:27| :skolemid |809| :pattern ( (_module.__default.BitsAsWord $ly@@7 |b#0@@1|)) ))))
(assert (forall (($ly@@8 T@U) (|b#0@@2| (_ BitVec 32)) ) (!  (=> (= (type $ly@@8) LayerTypeType) (and (=> (|_module.__default.BitsAsWord#requires| $ly@@8 |b#0@@2|) true) (=> true (|_module.__default.BitsAsWord#requires| $ly@@8 |b#0@@2|)))) :qid |bitvecto.26:27| :skolemid |810| :pattern ( (|_module.__default.BitsAsWord#requires| $ly@@8 |b#0@@2|)) )))
(assert  (=> true (forall (($ly@@9 T@U) (|b#0@@3| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@9) LayerTypeType) true) (= (_module.__default.BitsAsWord ($LS $ly@@9) |b#0@@3|) (nat_from_bv32 |b#0@@3|))) :qid |bitvecto.26:27| :skolemid |811| :pattern ( (_module.__default.BitsAsWord ($LS $ly@@9) |b#0@@3|)) ))))
(assert  (=> true (forall (($ly@@10 T@U) (|b#0@@4| T@U) ) (!  (=> (and (and (= (type $ly@@10) LayerTypeType) (= (type |b#0@@4|) bv32Type)) true) (= (_module.__default.BitsAsWord ($LS $ly@@10) (U_2_bv32 (Lit |b#0@@4|))) (nat_from_bv32 (U_2_bv32 (Lit |b#0@@4|))))) :qid |bitvecto.26:27| :weight 3 :skolemid |812| :pattern ( (_module.__default.BitsAsWord ($LS $ly@@10) (U_2_bv32 (Lit |b#0@@4|)))) ))))
(assert (forall (($ly@@11 T@U) (|x#0@@1| (_ BitVec 32)) (|y#0| (_ BitVec 32)) ) (!  (=> (= (type $ly@@11) LayerTypeType) (= (_module.__default.BitAdd ($LS $ly@@11) |x#0@@1| |y#0|) (_module.__default.BitAdd $ly@@11 |x#0@@1| |y#0|))) :qid |bitvecto.53:20| :skolemid |813| :pattern ( (_module.__default.BitAdd ($LS $ly@@11) |x#0@@1| |y#0|)) )))
(assert (forall (($ly@@12 T@U) (|x#0@@2| (_ BitVec 32)) (|y#0@@0| (_ BitVec 32)) ) (!  (=> (= (type $ly@@12) LayerTypeType) (= (_module.__default.BitAdd $ly@@12 |x#0@@2| |y#0@@0|) (_module.__default.BitAdd $LZ |x#0@@2| |y#0@@0|))) :qid |bitvecto.53:20| :skolemid |814| :pattern ( (_module.__default.BitAdd (AsFuelBottom $ly@@12) |x#0@@2| |y#0@@0|)) )))
(assert  (=> true (forall (($ly@@13 T@U) (|x#0@@3| (_ BitVec 32)) (|y#0@@1| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@13) LayerTypeType) true) true) :qid |bitvecto.53:20| :skolemid |815| :pattern ( (_module.__default.BitAdd $ly@@13 |x#0@@3| |y#0@@1|)) ))))
(assert (forall (($ly@@14 T@U) (|x#0@@4| (_ BitVec 32)) (|y#0@@2| (_ BitVec 32)) ) (!  (=> (= (type $ly@@14) LayerTypeType) (and (=> (|_module.__default.BitAdd#requires| $ly@@14 |x#0@@4| |y#0@@2|) true) (=> true (|_module.__default.BitAdd#requires| $ly@@14 |x#0@@4| |y#0@@2|)))) :qid |bitvecto.53:20| :skolemid |816| :pattern ( (|_module.__default.BitAdd#requires| $ly@@14 |x#0@@4| |y#0@@2|)) )))
(assert  (=> true (forall (($ly@@15 T@U) (|x#0@@5| (_ BitVec 32)) (|y#0@@3| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@15) LayerTypeType) true) (= (_module.__default.BitAdd ($LS $ly@@15) |x#0@@5| |y#0@@3|) (bvadd |x#0@@5| |y#0@@3|))) :qid |bitvecto.53:20| :skolemid |817| :pattern ( (_module.__default.BitAdd ($LS $ly@@15) |x#0@@5| |y#0@@3|)) ))))
(assert  (=> true (forall (($ly@@16 T@U) (|x#0@@6| T@U) (|y#0@@4| T@U) ) (!  (=> (and (and (and (= (type $ly@@16) LayerTypeType) (= (type |x#0@@6|) bv32Type)) (= (type |y#0@@4|) bv32Type)) true) (= (_module.__default.BitAdd ($LS $ly@@16) (U_2_bv32 (Lit |x#0@@6|)) (U_2_bv32 (Lit |y#0@@4|))) (U_2_bv32 (Lit (bv32_2_U (bvadd (U_2_bv32 |x#0@@6|) (U_2_bv32 |y#0@@4|))))))) :qid |bitvecto.53:20| :weight 3 :skolemid |818| :pattern ( (_module.__default.BitAdd ($LS $ly@@16) (U_2_bv32 (Lit |x#0@@6|)) (U_2_bv32 (Lit |y#0@@4|)))) ))))
(assert (forall (($ly@@17 T@U) (|x#0@@7| (_ BitVec 32)) (|y#0@@5| (_ BitVec 32)) ) (!  (=> (= (type $ly@@17) LayerTypeType) (= (_module.__default.BitSub ($LS $ly@@17) |x#0@@7| |y#0@@5|) (_module.__default.BitSub $ly@@17 |x#0@@7| |y#0@@5|))) :qid |bitvecto.58:20| :skolemid |819| :pattern ( (_module.__default.BitSub ($LS $ly@@17) |x#0@@7| |y#0@@5|)) )))
(assert (forall (($ly@@18 T@U) (|x#0@@8| (_ BitVec 32)) (|y#0@@6| (_ BitVec 32)) ) (!  (=> (= (type $ly@@18) LayerTypeType) (= (_module.__default.BitSub $ly@@18 |x#0@@8| |y#0@@6|) (_module.__default.BitSub $LZ |x#0@@8| |y#0@@6|))) :qid |bitvecto.58:20| :skolemid |820| :pattern ( (_module.__default.BitSub (AsFuelBottom $ly@@18) |x#0@@8| |y#0@@6|)) )))
(assert  (=> true (forall (($ly@@19 T@U) (|x#0@@9| (_ BitVec 32)) (|y#0@@7| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@19) LayerTypeType) true) true) :qid |bitvecto.58:20| :skolemid |821| :pattern ( (_module.__default.BitSub $ly@@19 |x#0@@9| |y#0@@7|)) ))))
(assert (forall (($ly@@20 T@U) (|x#0@@10| (_ BitVec 32)) (|y#0@@8| (_ BitVec 32)) ) (!  (=> (= (type $ly@@20) LayerTypeType) (and (=> (|_module.__default.BitSub#requires| $ly@@20 |x#0@@10| |y#0@@8|) true) (=> true (|_module.__default.BitSub#requires| $ly@@20 |x#0@@10| |y#0@@8|)))) :qid |bitvecto.58:20| :skolemid |822| :pattern ( (|_module.__default.BitSub#requires| $ly@@20 |x#0@@10| |y#0@@8|)) )))
(assert  (=> true (forall (($ly@@21 T@U) (|x#0@@11| (_ BitVec 32)) (|y#0@@9| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@21) LayerTypeType) true) (= (_module.__default.BitSub ($LS $ly@@21) |x#0@@11| |y#0@@9|) (bvsub |x#0@@11| |y#0@@9|))) :qid |bitvecto.58:20| :skolemid |823| :pattern ( (_module.__default.BitSub ($LS $ly@@21) |x#0@@11| |y#0@@9|)) ))))
(assert  (=> true (forall (($ly@@22 T@U) (|x#0@@12| T@U) (|y#0@@10| T@U) ) (!  (=> (and (and (and (= (type $ly@@22) LayerTypeType) (= (type |x#0@@12|) bv32Type)) (= (type |y#0@@10|) bv32Type)) true) (= (_module.__default.BitSub ($LS $ly@@22) (U_2_bv32 (Lit |x#0@@12|)) (U_2_bv32 (Lit |y#0@@10|))) (U_2_bv32 (Lit (bv32_2_U (bvsub (U_2_bv32 |x#0@@12|) (U_2_bv32 |y#0@@10|))))))) :qid |bitvecto.58:20| :weight 3 :skolemid |824| :pattern ( (_module.__default.BitSub ($LS $ly@@22) (U_2_bv32 (Lit |x#0@@12|)) (U_2_bv32 (Lit |y#0@@10|)))) ))))
(assert (forall (($ly@@23 T@U) (|x#0@@13| (_ BitVec 32)) (|y#0@@11| (_ BitVec 32)) ) (!  (=> (= (type $ly@@23) LayerTypeType) (= (_module.__default.BitAnd ($LS $ly@@23) |x#0@@13| |y#0@@11|) (_module.__default.BitAnd $ly@@23 |x#0@@13| |y#0@@11|))) :qid |bitvecto.63:20| :skolemid |825| :pattern ( (_module.__default.BitAnd ($LS $ly@@23) |x#0@@13| |y#0@@11|)) )))
(assert (forall (($ly@@24 T@U) (|x#0@@14| (_ BitVec 32)) (|y#0@@12| (_ BitVec 32)) ) (!  (=> (= (type $ly@@24) LayerTypeType) (= (_module.__default.BitAnd $ly@@24 |x#0@@14| |y#0@@12|) (_module.__default.BitAnd $LZ |x#0@@14| |y#0@@12|))) :qid |bitvecto.63:20| :skolemid |826| :pattern ( (_module.__default.BitAnd (AsFuelBottom $ly@@24) |x#0@@14| |y#0@@12|)) )))
(assert  (=> true (forall (($ly@@25 T@U) (|x#0@@15| (_ BitVec 32)) (|y#0@@13| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@25) LayerTypeType) true) true) :qid |bitvecto.63:20| :skolemid |827| :pattern ( (_module.__default.BitAnd $ly@@25 |x#0@@15| |y#0@@13|)) ))))
(assert (forall (($ly@@26 T@U) (|x#0@@16| (_ BitVec 32)) (|y#0@@14| (_ BitVec 32)) ) (!  (=> (= (type $ly@@26) LayerTypeType) (and (=> (|_module.__default.BitAnd#requires| $ly@@26 |x#0@@16| |y#0@@14|) true) (=> true (|_module.__default.BitAnd#requires| $ly@@26 |x#0@@16| |y#0@@14|)))) :qid |bitvecto.63:20| :skolemid |828| :pattern ( (|_module.__default.BitAnd#requires| $ly@@26 |x#0@@16| |y#0@@14|)) )))
(assert  (=> true (forall (($ly@@27 T@U) (|x#0@@17| (_ BitVec 32)) (|y#0@@15| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@27) LayerTypeType) true) (= (_module.__default.BitAnd ($LS $ly@@27) |x#0@@17| |y#0@@15|) (bvand |x#0@@17| |y#0@@15|))) :qid |bitvecto.63:20| :skolemid |829| :pattern ( (_module.__default.BitAnd ($LS $ly@@27) |x#0@@17| |y#0@@15|)) ))))
(assert  (=> true (forall (($ly@@28 T@U) (|x#0@@18| T@U) (|y#0@@16| T@U) ) (!  (=> (and (and (and (= (type $ly@@28) LayerTypeType) (= (type |x#0@@18|) bv32Type)) (= (type |y#0@@16|) bv32Type)) true) (= (_module.__default.BitAnd ($LS $ly@@28) (U_2_bv32 (Lit |x#0@@18|)) (U_2_bv32 (Lit |y#0@@16|))) (U_2_bv32 (Lit (bv32_2_U (bvand (U_2_bv32 |x#0@@18|) (U_2_bv32 |y#0@@16|))))))) :qid |bitvecto.63:20| :weight 3 :skolemid |830| :pattern ( (_module.__default.BitAnd ($LS $ly@@28) (U_2_bv32 (Lit |x#0@@18|)) (U_2_bv32 (Lit |y#0@@16|)))) ))))
(assert (forall (($ly@@29 T@U) (|x#0@@19| (_ BitVec 32)) (|y#0@@17| (_ BitVec 32)) ) (!  (=> (= (type $ly@@29) LayerTypeType) (= (_module.__default.BitOr ($LS $ly@@29) |x#0@@19| |y#0@@17|) (_module.__default.BitOr $ly@@29 |x#0@@19| |y#0@@17|))) :qid |bitvecto.68:20| :skolemid |831| :pattern ( (_module.__default.BitOr ($LS $ly@@29) |x#0@@19| |y#0@@17|)) )))
(assert (forall (($ly@@30 T@U) (|x#0@@20| (_ BitVec 32)) (|y#0@@18| (_ BitVec 32)) ) (!  (=> (= (type $ly@@30) LayerTypeType) (= (_module.__default.BitOr $ly@@30 |x#0@@20| |y#0@@18|) (_module.__default.BitOr $LZ |x#0@@20| |y#0@@18|))) :qid |bitvecto.68:20| :skolemid |832| :pattern ( (_module.__default.BitOr (AsFuelBottom $ly@@30) |x#0@@20| |y#0@@18|)) )))
(assert  (=> true (forall (($ly@@31 T@U) (|x#0@@21| (_ BitVec 32)) (|y#0@@19| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@31) LayerTypeType) true) true) :qid |bitvecto.68:20| :skolemid |833| :pattern ( (_module.__default.BitOr $ly@@31 |x#0@@21| |y#0@@19|)) ))))
(assert (forall (($ly@@32 T@U) (|x#0@@22| (_ BitVec 32)) (|y#0@@20| (_ BitVec 32)) ) (!  (=> (= (type $ly@@32) LayerTypeType) (and (=> (|_module.__default.BitOr#requires| $ly@@32 |x#0@@22| |y#0@@20|) true) (=> true (|_module.__default.BitOr#requires| $ly@@32 |x#0@@22| |y#0@@20|)))) :qid |bitvecto.68:20| :skolemid |834| :pattern ( (|_module.__default.BitOr#requires| $ly@@32 |x#0@@22| |y#0@@20|)) )))
(assert  (=> true (forall (($ly@@33 T@U) (|x#0@@23| (_ BitVec 32)) (|y#0@@21| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@33) LayerTypeType) true) (= (_module.__default.BitOr ($LS $ly@@33) |x#0@@23| |y#0@@21|) (bvor |x#0@@23| |y#0@@21|))) :qid |bitvecto.68:20| :skolemid |835| :pattern ( (_module.__default.BitOr ($LS $ly@@33) |x#0@@23| |y#0@@21|)) ))))
(assert  (=> true (forall (($ly@@34 T@U) (|x#0@@24| T@U) (|y#0@@22| T@U) ) (!  (=> (and (and (and (= (type $ly@@34) LayerTypeType) (= (type |x#0@@24|) bv32Type)) (= (type |y#0@@22|) bv32Type)) true) (= (_module.__default.BitOr ($LS $ly@@34) (U_2_bv32 (Lit |x#0@@24|)) (U_2_bv32 (Lit |y#0@@22|))) (U_2_bv32 (Lit (bv32_2_U (bvor (U_2_bv32 |x#0@@24|) (U_2_bv32 |y#0@@22|))))))) :qid |bitvecto.68:20| :weight 3 :skolemid |836| :pattern ( (_module.__default.BitOr ($LS $ly@@34) (U_2_bv32 (Lit |x#0@@24|)) (U_2_bv32 (Lit |y#0@@22|)))) ))))
(assert (forall (($ly@@35 T@U) (|x#0@@25| (_ BitVec 32)) (|y#0@@23| (_ BitVec 32)) ) (!  (=> (= (type $ly@@35) LayerTypeType) (= (_module.__default.BitXor ($LS $ly@@35) |x#0@@25| |y#0@@23|) (_module.__default.BitXor $ly@@35 |x#0@@25| |y#0@@23|))) :qid |bitvecto.73:20| :skolemid |837| :pattern ( (_module.__default.BitXor ($LS $ly@@35) |x#0@@25| |y#0@@23|)) )))
(assert (forall (($ly@@36 T@U) (|x#0@@26| (_ BitVec 32)) (|y#0@@24| (_ BitVec 32)) ) (!  (=> (= (type $ly@@36) LayerTypeType) (= (_module.__default.BitXor $ly@@36 |x#0@@26| |y#0@@24|) (_module.__default.BitXor $LZ |x#0@@26| |y#0@@24|))) :qid |bitvecto.73:20| :skolemid |838| :pattern ( (_module.__default.BitXor (AsFuelBottom $ly@@36) |x#0@@26| |y#0@@24|)) )))
(assert  (=> true (forall (($ly@@37 T@U) (|x#0@@27| (_ BitVec 32)) (|y#0@@25| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@37) LayerTypeType) true) true) :qid |bitvecto.73:20| :skolemid |839| :pattern ( (_module.__default.BitXor $ly@@37 |x#0@@27| |y#0@@25|)) ))))
(assert (forall (($ly@@38 T@U) (|x#0@@28| (_ BitVec 32)) (|y#0@@26| (_ BitVec 32)) ) (!  (=> (= (type $ly@@38) LayerTypeType) (and (=> (|_module.__default.BitXor#requires| $ly@@38 |x#0@@28| |y#0@@26|) true) (=> true (|_module.__default.BitXor#requires| $ly@@38 |x#0@@28| |y#0@@26|)))) :qid |bitvecto.73:20| :skolemid |840| :pattern ( (|_module.__default.BitXor#requires| $ly@@38 |x#0@@28| |y#0@@26|)) )))
(assert  (=> true (forall (($ly@@39 T@U) (|x#0@@29| (_ BitVec 32)) (|y#0@@27| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@39) LayerTypeType) true) (= (_module.__default.BitXor ($LS $ly@@39) |x#0@@29| |y#0@@27|) (bvxor |x#0@@29| |y#0@@27|))) :qid |bitvecto.73:20| :skolemid |841| :pattern ( (_module.__default.BitXor ($LS $ly@@39) |x#0@@29| |y#0@@27|)) ))))
(assert  (=> true (forall (($ly@@40 T@U) (|x#0@@30| T@U) (|y#0@@28| T@U) ) (!  (=> (and (and (and (= (type $ly@@40) LayerTypeType) (= (type |x#0@@30|) bv32Type)) (= (type |y#0@@28|) bv32Type)) true) (= (_module.__default.BitXor ($LS $ly@@40) (U_2_bv32 (Lit |x#0@@30|)) (U_2_bv32 (Lit |y#0@@28|))) (U_2_bv32 (Lit (bv32_2_U (bvxor (U_2_bv32 |x#0@@30|) (U_2_bv32 |y#0@@28|))))))) :qid |bitvecto.73:20| :weight 3 :skolemid |842| :pattern ( (_module.__default.BitXor ($LS $ly@@40) (U_2_bv32 (Lit |x#0@@30|)) (U_2_bv32 (Lit |y#0@@28|)))) ))))
(assert (forall (($ly@@41 T@U) (|x#0@@31| (_ BitVec 32)) (|y#0@@29| (_ BitVec 32)) ) (!  (=> (= (type $ly@@41) LayerTypeType) (= (_module.__default.BitMod ($LS $ly@@41) |x#0@@31| |y#0@@29|) (_module.__default.BitMod $ly@@41 |x#0@@31| |y#0@@29|))) :qid |bitvecto.78:20| :skolemid |843| :pattern ( (_module.__default.BitMod ($LS $ly@@41) |x#0@@31| |y#0@@29|)) )))
(assert (forall (($ly@@42 T@U) (|x#0@@32| (_ BitVec 32)) (|y#0@@30| (_ BitVec 32)) ) (!  (=> (= (type $ly@@42) LayerTypeType) (= (_module.__default.BitMod $ly@@42 |x#0@@32| |y#0@@30|) (_module.__default.BitMod $LZ |x#0@@32| |y#0@@30|))) :qid |bitvecto.78:20| :skolemid |844| :pattern ( (_module.__default.BitMod (AsFuelBottom $ly@@42) |x#0@@32| |y#0@@30|)) )))
(assert  (=> true (forall (($ly@@43 T@U) (|x#0@@33| (_ BitVec 32)) (|y#0@@31| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@43) LayerTypeType) (or (|_module.__default.BitMod#canCall| |x#0@@33| |y#0@@31|) (not (= |y#0@@31| #x00000000)))) true) :qid |bitvecto.78:20| :skolemid |845| :pattern ( (_module.__default.BitMod $ly@@43 |x#0@@33| |y#0@@31|)) ))))
(assert (forall (($ly@@44 T@U) (|x#0@@34| (_ BitVec 32)) (|y#0@@32| (_ BitVec 32)) ) (!  (=> (= (type $ly@@44) LayerTypeType) (and (=> (|_module.__default.BitMod#requires| $ly@@44 |x#0@@34| |y#0@@32|) (not (= |y#0@@32| #x00000000))) (=> (not (= |y#0@@32| #x00000000)) (|_module.__default.BitMod#requires| $ly@@44 |x#0@@34| |y#0@@32|)))) :qid |bitvecto.78:20| :skolemid |846| :pattern ( (|_module.__default.BitMod#requires| $ly@@44 |x#0@@34| |y#0@@32|)) )))
(assert  (=> true (forall (($ly@@45 T@U) (|x#0@@35| (_ BitVec 32)) (|y#0@@33| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@45) LayerTypeType) (or (|_module.__default.BitMod#canCall| |x#0@@35| |y#0@@33|) (not (= |y#0@@33| #x00000000)))) (= (_module.__default.BitMod ($LS $ly@@45) |x#0@@35| |y#0@@33|) (bvurem |x#0@@35| |y#0@@33|))) :qid |bitvecto.78:20| :skolemid |847| :pattern ( (_module.__default.BitMod ($LS $ly@@45) |x#0@@35| |y#0@@33|)) ))))
(assert  (=> true (forall (($ly@@46 T@U) (|x#0@@36| T@U) (|y#0@@34| T@U) ) (!  (=> (and (and (and (= (type $ly@@46) LayerTypeType) (= (type |x#0@@36|) bv32Type)) (= (type |y#0@@34|) bv32Type)) (or (|_module.__default.BitMod#canCall| (U_2_bv32 (Lit |x#0@@36|)) (U_2_bv32 (Lit |y#0@@34|))) (U_2_bool (Lit (bool_2_U (not (= (U_2_bv32 |y#0@@34|) #x00000000))))))) (= (_module.__default.BitMod ($LS $ly@@46) (U_2_bv32 (Lit |x#0@@36|)) (U_2_bv32 (Lit |y#0@@34|))) (U_2_bv32 (Lit (bv32_2_U (bvurem (U_2_bv32 |x#0@@36|) (U_2_bv32 |y#0@@34|))))))) :qid |bitvecto.78:20| :weight 3 :skolemid |848| :pattern ( (_module.__default.BitMod ($LS $ly@@46) (U_2_bv32 (Lit |x#0@@36|)) (U_2_bv32 (Lit |y#0@@34|)))) ))))
(assert (forall (($ly@@47 T@U) (|x#0@@37| (_ BitVec 32)) (|y#0@@35| (_ BitVec 32)) ) (!  (=> (= (type $ly@@47) LayerTypeType) (= (_module.__default.BitDiv ($LS $ly@@47) |x#0@@37| |y#0@@35|) (_module.__default.BitDiv $ly@@47 |x#0@@37| |y#0@@35|))) :qid |bitvecto.84:20| :skolemid |849| :pattern ( (_module.__default.BitDiv ($LS $ly@@47) |x#0@@37| |y#0@@35|)) )))
(assert (forall (($ly@@48 T@U) (|x#0@@38| (_ BitVec 32)) (|y#0@@36| (_ BitVec 32)) ) (!  (=> (= (type $ly@@48) LayerTypeType) (= (_module.__default.BitDiv $ly@@48 |x#0@@38| |y#0@@36|) (_module.__default.BitDiv $LZ |x#0@@38| |y#0@@36|))) :qid |bitvecto.84:20| :skolemid |850| :pattern ( (_module.__default.BitDiv (AsFuelBottom $ly@@48) |x#0@@38| |y#0@@36|)) )))
(assert  (=> true (forall (($ly@@49 T@U) (|x#0@@39| (_ BitVec 32)) (|y#0@@37| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@49) LayerTypeType) (or (|_module.__default.BitDiv#canCall| |x#0@@39| |y#0@@37|) (not (= |y#0@@37| #x00000000)))) true) :qid |bitvecto.84:20| :skolemid |851| :pattern ( (_module.__default.BitDiv $ly@@49 |x#0@@39| |y#0@@37|)) ))))
(assert (forall (($ly@@50 T@U) (|x#0@@40| (_ BitVec 32)) (|y#0@@38| (_ BitVec 32)) ) (!  (=> (= (type $ly@@50) LayerTypeType) (and (=> (|_module.__default.BitDiv#requires| $ly@@50 |x#0@@40| |y#0@@38|) (not (= |y#0@@38| #x00000000))) (=> (not (= |y#0@@38| #x00000000)) (|_module.__default.BitDiv#requires| $ly@@50 |x#0@@40| |y#0@@38|)))) :qid |bitvecto.84:20| :skolemid |852| :pattern ( (|_module.__default.BitDiv#requires| $ly@@50 |x#0@@40| |y#0@@38|)) )))
(assert  (=> true (forall (($ly@@51 T@U) (|x#0@@41| (_ BitVec 32)) (|y#0@@39| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@51) LayerTypeType) (or (|_module.__default.BitDiv#canCall| |x#0@@41| |y#0@@39|) (not (= |y#0@@39| #x00000000)))) (= (_module.__default.BitDiv ($LS $ly@@51) |x#0@@41| |y#0@@39|) (bvudiv |x#0@@41| |y#0@@39|))) :qid |bitvecto.84:20| :skolemid |853| :pattern ( (_module.__default.BitDiv ($LS $ly@@51) |x#0@@41| |y#0@@39|)) ))))
(assert  (=> true (forall (($ly@@52 T@U) (|x#0@@42| T@U) (|y#0@@40| T@U) ) (!  (=> (and (and (and (= (type $ly@@52) LayerTypeType) (= (type |x#0@@42|) bv32Type)) (= (type |y#0@@40|) bv32Type)) (or (|_module.__default.BitDiv#canCall| (U_2_bv32 (Lit |x#0@@42|)) (U_2_bv32 (Lit |y#0@@40|))) (U_2_bool (Lit (bool_2_U (not (= (U_2_bv32 |y#0@@40|) #x00000000))))))) (= (_module.__default.BitDiv ($LS $ly@@52) (U_2_bv32 (Lit |x#0@@42|)) (U_2_bv32 (Lit |y#0@@40|))) (U_2_bv32 (Lit (bv32_2_U (bvudiv (U_2_bv32 |x#0@@42|) (U_2_bv32 |y#0@@40|))))))) :qid |bitvecto.84:20| :weight 3 :skolemid |854| :pattern ( (_module.__default.BitDiv ($LS $ly@@52) (U_2_bv32 (Lit |x#0@@42|)) (U_2_bv32 (Lit |y#0@@40|)))) ))))
(assert (forall (($ly@@53 T@U) (|x#0@@43| (_ BitVec 32)) (|y#0@@41| (_ BitVec 32)) ) (!  (=> (= (type $ly@@53) LayerTypeType) (= (_module.__default.BitMul ($LS $ly@@53) |x#0@@43| |y#0@@41|) (_module.__default.BitMul $ly@@53 |x#0@@43| |y#0@@41|))) :qid |bitvecto.90:20| :skolemid |855| :pattern ( (_module.__default.BitMul ($LS $ly@@53) |x#0@@43| |y#0@@41|)) )))
(assert (forall (($ly@@54 T@U) (|x#0@@44| (_ BitVec 32)) (|y#0@@42| (_ BitVec 32)) ) (!  (=> (= (type $ly@@54) LayerTypeType) (= (_module.__default.BitMul $ly@@54 |x#0@@44| |y#0@@42|) (_module.__default.BitMul $LZ |x#0@@44| |y#0@@42|))) :qid |bitvecto.90:20| :skolemid |856| :pattern ( (_module.__default.BitMul (AsFuelBottom $ly@@54) |x#0@@44| |y#0@@42|)) )))
(assert  (=> true (forall (($ly@@55 T@U) (|x#0@@45| (_ BitVec 32)) (|y#0@@43| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@55) LayerTypeType) true) true) :qid |bitvecto.90:20| :skolemid |857| :pattern ( (_module.__default.BitMul $ly@@55 |x#0@@45| |y#0@@43|)) ))))
(assert (forall (($ly@@56 T@U) (|x#0@@46| (_ BitVec 32)) (|y#0@@44| (_ BitVec 32)) ) (!  (=> (= (type $ly@@56) LayerTypeType) (and (=> (|_module.__default.BitMul#requires| $ly@@56 |x#0@@46| |y#0@@44|) true) (=> true (|_module.__default.BitMul#requires| $ly@@56 |x#0@@46| |y#0@@44|)))) :qid |bitvecto.90:20| :skolemid |858| :pattern ( (|_module.__default.BitMul#requires| $ly@@56 |x#0@@46| |y#0@@44|)) )))
(assert  (=> true (forall (($ly@@57 T@U) (|x#0@@47| (_ BitVec 32)) (|y#0@@45| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@57) LayerTypeType) true) (= (_module.__default.BitMul ($LS $ly@@57) |x#0@@47| |y#0@@45|) (bvmul |x#0@@47| |y#0@@45|))) :qid |bitvecto.90:20| :skolemid |859| :pattern ( (_module.__default.BitMul ($LS $ly@@57) |x#0@@47| |y#0@@45|)) ))))
(assert  (=> true (forall (($ly@@58 T@U) (|x#0@@48| T@U) (|y#0@@46| T@U) ) (!  (=> (and (and (and (= (type $ly@@58) LayerTypeType) (= (type |x#0@@48|) bv32Type)) (= (type |y#0@@46|) bv32Type)) true) (= (_module.__default.BitMul ($LS $ly@@58) (U_2_bv32 (Lit |x#0@@48|)) (U_2_bv32 (Lit |y#0@@46|))) (U_2_bv32 (Lit (bv32_2_U (bvmul (U_2_bv32 |x#0@@48|) (U_2_bv32 |y#0@@46|))))))) :qid |bitvecto.90:20| :weight 3 :skolemid |860| :pattern ( (_module.__default.BitMul ($LS $ly@@58) (U_2_bv32 (Lit |x#0@@48|)) (U_2_bv32 (Lit |y#0@@46|)))) ))))
(assert (forall (($ly@@59 T@U) (|x#0@@49| (_ BitVec 32)) ) (!  (=> (= (type $ly@@59) LayerTypeType) (= (_module.__default.BitNot ($LS $ly@@59) |x#0@@49|) (_module.__default.BitNot $ly@@59 |x#0@@49|))) :qid |bitvecto.95:20| :skolemid |861| :pattern ( (_module.__default.BitNot ($LS $ly@@59) |x#0@@49|)) )))
(assert (forall (($ly@@60 T@U) (|x#0@@50| (_ BitVec 32)) ) (!  (=> (= (type $ly@@60) LayerTypeType) (= (_module.__default.BitNot $ly@@60 |x#0@@50|) (_module.__default.BitNot $LZ |x#0@@50|))) :qid |bitvecto.95:20| :skolemid |862| :pattern ( (_module.__default.BitNot (AsFuelBottom $ly@@60) |x#0@@50|)) )))
(assert  (=> true (forall (($ly@@61 T@U) (|x#0@@51| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@61) LayerTypeType) true) true) :qid |bitvecto.95:20| :skolemid |863| :pattern ( (_module.__default.BitNot $ly@@61 |x#0@@51|)) ))))
(assert (forall (($ly@@62 T@U) (|x#0@@52| (_ BitVec 32)) ) (!  (=> (= (type $ly@@62) LayerTypeType) (and (=> (|_module.__default.BitNot#requires| $ly@@62 |x#0@@52|) true) (=> true (|_module.__default.BitNot#requires| $ly@@62 |x#0@@52|)))) :qid |bitvecto.95:20| :skolemid |864| :pattern ( (|_module.__default.BitNot#requires| $ly@@62 |x#0@@52|)) )))
(assert  (=> true (forall (($ly@@63 T@U) (|x#0@@53| (_ BitVec 32)) ) (!  (=> (and (= (type $ly@@63) LayerTypeType) true) (= (_module.__default.BitNot ($LS $ly@@63) |x#0@@53|) (bvnot |x#0@@53|))) :qid |bitvecto.95:20| :skolemid |865| :pattern ( (_module.__default.BitNot ($LS $ly@@63) |x#0@@53|)) ))))
(assert  (=> true (forall (($ly@@64 T@U) (|x#0@@54| T@U) ) (!  (=> (and (and (= (type $ly@@64) LayerTypeType) (= (type |x#0@@54|) bv32Type)) true) (= (_module.__default.BitNot ($LS $ly@@64) (U_2_bv32 (Lit |x#0@@54|))) (U_2_bv32 (Lit (bv32_2_U (bvnot (U_2_bv32 (Lit |x#0@@54|)))))))) :qid |bitvecto.95:20| :weight 3 :skolemid |866| :pattern ( (_module.__default.BitNot ($LS $ly@@64) (U_2_bv32 (Lit |x#0@@54|)))) ))))
(assert (forall (($ly@@65 T@U) (|x#0@@55| (_ BitVec 32)) (|amount#0| Int) ) (!  (=> (= (type $ly@@65) LayerTypeType) (= (_module.__default.BitShiftLeft ($LS $ly@@65) |x#0@@55| |amount#0|) (_module.__default.BitShiftLeft $ly@@65 |x#0@@55| |amount#0|))) :qid |bitvecto.100:20| :skolemid |867| :pattern ( (_module.__default.BitShiftLeft ($LS $ly@@65) |x#0@@55| |amount#0|)) )))
(assert (forall (($ly@@66 T@U) (|x#0@@56| (_ BitVec 32)) (|amount#0@@0| Int) ) (!  (=> (= (type $ly@@66) LayerTypeType) (= (_module.__default.BitShiftLeft $ly@@66 |x#0@@56| |amount#0@@0|) (_module.__default.BitShiftLeft $LZ |x#0@@56| |amount#0@@0|))) :qid |bitvecto.100:20| :skolemid |868| :pattern ( (_module.__default.BitShiftLeft (AsFuelBottom $ly@@66) |x#0@@56| |amount#0@@0|)) )))
(assert  (=> true (forall (($ly@@67 T@U) (|x#0@@57| (_ BitVec 32)) (|amount#0@@1| Int) ) (!  (=> (and (= (type $ly@@67) LayerTypeType) (or (|_module.__default.BitShiftLeft#canCall| |x#0@@57| |amount#0@@1|) (and (INTERNAL_le_boogie 0 |amount#0@@1|) (INTERNAL_lt_boogie |amount#0@@1| 32)))) true) :qid |bitvecto.100:20| :skolemid |869| :pattern ( (_module.__default.BitShiftLeft $ly@@67 |x#0@@57| |amount#0@@1|)) ))))
(assert (forall (($ly@@68 T@U) (|x#0@@58| (_ BitVec 32)) (|amount#0@@2| Int) ) (!  (=> (= (type $ly@@68) LayerTypeType) (and (=> (|_module.__default.BitShiftLeft#requires| $ly@@68 |x#0@@58| |amount#0@@2|) (and (INTERNAL_le_boogie 0 |amount#0@@2|) (INTERNAL_lt_boogie |amount#0@@2| 32))) (=> (and (INTERNAL_le_boogie 0 |amount#0@@2|) (INTERNAL_lt_boogie |amount#0@@2| 32)) (|_module.__default.BitShiftLeft#requires| $ly@@68 |x#0@@58| |amount#0@@2|)))) :qid |bitvecto.100:20| :skolemid |870| :pattern ( (|_module.__default.BitShiftLeft#requires| $ly@@68 |x#0@@58| |amount#0@@2|)) )))
(assert  (=> true (forall (($ly@@69 T@U) (|x#0@@59| (_ BitVec 32)) (|amount#0@@3| Int) ) (!  (=> (and (= (type $ly@@69) LayerTypeType) (or (|_module.__default.BitShiftLeft#canCall| |x#0@@59| |amount#0@@3|) (and (INTERNAL_le_boogie 0 |amount#0@@3|) (INTERNAL_lt_boogie |amount#0@@3| 32)))) (= (_module.__default.BitShiftLeft ($LS $ly@@69) |x#0@@59| |amount#0@@3|) (bvshl |x#0@@59| ((_ int2bv 32) |amount#0@@3|)))) :qid |bitvecto.100:20| :skolemid |871| :pattern ( (_module.__default.BitShiftLeft ($LS $ly@@69) |x#0@@59| |amount#0@@3|)) ))))
(assert  (=> true (forall (($ly@@70 T@U) (|x#0@@60| T@U) (|amount#0@@4| Int) ) (!  (=> (and (and (= (type $ly@@70) LayerTypeType) (= (type |x#0@@60|) bv32Type)) (or (|_module.__default.BitShiftLeft#canCall| (U_2_bv32 (Lit |x#0@@60|)) (LitInt |amount#0@@4|)) (and (INTERNAL_le_boogie 0 |amount#0@@4|) (INTERNAL_lt_boogie |amount#0@@4| 32)))) (= (_module.__default.BitShiftLeft ($LS $ly@@70) (U_2_bv32 (Lit |x#0@@60|)) (LitInt |amount#0@@4|)) (U_2_bv32 (Lit (bv32_2_U (bvshl (U_2_bv32 |x#0@@60|) ((_ int2bv 32) |amount#0@@4|))))))) :qid |bitvecto.100:20| :weight 3 :skolemid |872| :pattern ( (_module.__default.BitShiftLeft ($LS $ly@@70) (U_2_bv32 (Lit |x#0@@60|)) (LitInt |amount#0@@4|))) ))))
(assert (forall (($ly@@71 T@U) (|x#0@@61| (_ BitVec 32)) (|amount#0@@5| Int) ) (!  (=> (= (type $ly@@71) LayerTypeType) (= (_module.__default.BitShiftRight ($LS $ly@@71) |x#0@@61| |amount#0@@5|) (_module.__default.BitShiftRight $ly@@71 |x#0@@61| |amount#0@@5|))) :qid |bitvecto.106:20| :skolemid |873| :pattern ( (_module.__default.BitShiftRight ($LS $ly@@71) |x#0@@61| |amount#0@@5|)) )))
(assert (forall (($ly@@72 T@U) (|x#0@@62| (_ BitVec 32)) (|amount#0@@6| Int) ) (!  (=> (= (type $ly@@72) LayerTypeType) (= (_module.__default.BitShiftRight $ly@@72 |x#0@@62| |amount#0@@6|) (_module.__default.BitShiftRight $LZ |x#0@@62| |amount#0@@6|))) :qid |bitvecto.106:20| :skolemid |874| :pattern ( (_module.__default.BitShiftRight (AsFuelBottom $ly@@72) |x#0@@62| |amount#0@@6|)) )))
(assert  (=> true (forall (($ly@@73 T@U) (|x#0@@63| (_ BitVec 32)) (|amount#0@@7| Int) ) (!  (=> (and (= (type $ly@@73) LayerTypeType) (or (|_module.__default.BitShiftRight#canCall| |x#0@@63| |amount#0@@7|) (and (INTERNAL_le_boogie 0 |amount#0@@7|) (INTERNAL_lt_boogie |amount#0@@7| 32)))) true) :qid |bitvecto.106:20| :skolemid |875| :pattern ( (_module.__default.BitShiftRight $ly@@73 |x#0@@63| |amount#0@@7|)) ))))
(assert (forall (($ly@@74 T@U) (|x#0@@64| (_ BitVec 32)) (|amount#0@@8| Int) ) (!  (=> (= (type $ly@@74) LayerTypeType) (and (=> (|_module.__default.BitShiftRight#requires| $ly@@74 |x#0@@64| |amount#0@@8|) (and (INTERNAL_le_boogie 0 |amount#0@@8|) (INTERNAL_lt_boogie |amount#0@@8| 32))) (=> (and (INTERNAL_le_boogie 0 |amount#0@@8|) (INTERNAL_lt_boogie |amount#0@@8| 32)) (|_module.__default.BitShiftRight#requires| $ly@@74 |x#0@@64| |amount#0@@8|)))) :qid |bitvecto.106:20| :skolemid |876| :pattern ( (|_module.__default.BitShiftRight#requires| $ly@@74 |x#0@@64| |amount#0@@8|)) )))
(assert  (=> true (forall (($ly@@75 T@U) (|x#0@@65| (_ BitVec 32)) (|amount#0@@9| Int) ) (!  (=> (and (= (type $ly@@75) LayerTypeType) (or (|_module.__default.BitShiftRight#canCall| |x#0@@65| |amount#0@@9|) (and (INTERNAL_le_boogie 0 |amount#0@@9|) (INTERNAL_lt_boogie |amount#0@@9| 32)))) (= (_module.__default.BitShiftRight ($LS $ly@@75) |x#0@@65| |amount#0@@9|) (bvlshr |x#0@@65| ((_ int2bv 32) |amount#0@@9|)))) :qid |bitvecto.106:20| :skolemid |877| :pattern ( (_module.__default.BitShiftRight ($LS $ly@@75) |x#0@@65| |amount#0@@9|)) ))))
(assert  (=> true (forall (($ly@@76 T@U) (|x#0@@66| T@U) (|amount#0@@10| Int) ) (!  (=> (and (and (= (type $ly@@76) LayerTypeType) (= (type |x#0@@66|) bv32Type)) (or (|_module.__default.BitShiftRight#canCall| (U_2_bv32 (Lit |x#0@@66|)) (LitInt |amount#0@@10|)) (and (INTERNAL_le_boogie 0 |amount#0@@10|) (INTERNAL_lt_boogie |amount#0@@10| 32)))) (= (_module.__default.BitShiftRight ($LS $ly@@76) (U_2_bv32 (Lit |x#0@@66|)) (LitInt |amount#0@@10|)) (U_2_bv32 (Lit (bv32_2_U (bvlshr (U_2_bv32 |x#0@@66|) ((_ int2bv 32) |amount#0@@10|))))))) :qid |bitvecto.106:20| :weight 3 :skolemid |878| :pattern ( (_module.__default.BitShiftRight ($LS $ly@@76) (U_2_bv32 (Lit |x#0@@66|)) (LitInt |amount#0@@10|))) ))))
(assert (forall (($ly@@77 T@U) (|x#0@@67| (_ BitVec 32)) (|amount#0@@11| Int) ) (!  (=> (= (type $ly@@77) LayerTypeType) (= (_module.__default.BitRotateRight ($LS $ly@@77) |x#0@@67| |amount#0@@11|) (_module.__default.BitRotateRight $ly@@77 |x#0@@67| |amount#0@@11|))) :qid |bitvecto.112:20| :skolemid |879| :pattern ( (_module.__default.BitRotateRight ($LS $ly@@77) |x#0@@67| |amount#0@@11|)) )))
(assert (forall (($ly@@78 T@U) (|x#0@@68| (_ BitVec 32)) (|amount#0@@12| Int) ) (!  (=> (= (type $ly@@78) LayerTypeType) (= (_module.__default.BitRotateRight $ly@@78 |x#0@@68| |amount#0@@12|) (_module.__default.BitRotateRight $LZ |x#0@@68| |amount#0@@12|))) :qid |bitvecto.112:20| :skolemid |880| :pattern ( (_module.__default.BitRotateRight (AsFuelBottom $ly@@78) |x#0@@68| |amount#0@@12|)) )))
(assert  (=> true (forall (($ly@@79 T@U) (|x#0@@69| (_ BitVec 32)) (|amount#0@@13| Int) ) (!  (=> (and (= (type $ly@@79) LayerTypeType) (or (|_module.__default.BitRotateRight#canCall| |x#0@@69| |amount#0@@13|) (and (INTERNAL_le_boogie 0 |amount#0@@13|) (INTERNAL_lt_boogie |amount#0@@13| 32)))) true) :qid |bitvecto.112:20| :skolemid |881| :pattern ( (_module.__default.BitRotateRight $ly@@79 |x#0@@69| |amount#0@@13|)) ))))
(assert (forall (($ly@@80 T@U) (|x#0@@70| (_ BitVec 32)) (|amount#0@@14| Int) ) (!  (=> (= (type $ly@@80) LayerTypeType) (and (=> (|_module.__default.BitRotateRight#requires| $ly@@80 |x#0@@70| |amount#0@@14|) (and (INTERNAL_le_boogie 0 |amount#0@@14|) (INTERNAL_lt_boogie |amount#0@@14| 32))) (=> (and (INTERNAL_le_boogie 0 |amount#0@@14|) (INTERNAL_lt_boogie |amount#0@@14| 32)) (|_module.__default.BitRotateRight#requires| $ly@@80 |x#0@@70| |amount#0@@14|)))) :qid |bitvecto.112:20| :skolemid |882| :pattern ( (|_module.__default.BitRotateRight#requires| $ly@@80 |x#0@@70| |amount#0@@14|)) )))
(assert (forall (($ly@@81 T@U) (|n#0| Int) ) (!  (=> (= (type $ly@@81) LayerTypeType) (= (_module.__default.pow2 ($LS $ly@@81) |n#0|) (_module.__default.pow2 $ly@@81 |n#0|))) :qid |bitvecto.149:20| :skolemid |883| :pattern ( (_module.__default.pow2 ($LS $ly@@81) |n#0|)) )))
(assert (forall (($ly@@82 T@U) (|n#0@@0| Int) ) (!  (=> (= (type $ly@@82) LayerTypeType) (= (_module.__default.pow2 $ly@@82 |n#0@@0|) (_module.__default.pow2 $LZ |n#0@@0|))) :qid |bitvecto.149:20| :skolemid |884| :pattern ( (_module.__default.pow2 (AsFuelBottom $ly@@82) |n#0@@0|)) )))
(assert  (=> true (forall (($ly@@83 T@U) (|n#0@@1| Int) ) (!  (=> (and (= (type $ly@@83) LayerTypeType) (or (|_module.__default.pow2#canCall| |n#0@@1|) (INTERNAL_le_boogie 0 |n#0@@1|))) (and (INTERNAL_gt_boogie (_module.__default.pow2 $ly@@83 |n#0@@1|) 0) (INTERNAL_le_boogie 0 (_module.__default.pow2 $ly@@83 |n#0@@1|)))) :qid |bitvecto.149:20| :skolemid |885| :pattern ( (_module.__default.pow2 $ly@@83 |n#0@@1|)) ))))
(assert (forall (($ly@@84 T@U) (|n#0@@2| Int) ) (!  (=> (and (= (type $ly@@84) LayerTypeType) (INTERNAL_le_boogie 0 |n#0@@2|)) (and (=> (|_module.__default.pow2#requires| $ly@@84 |n#0@@2|) true) (=> true (|_module.__default.pow2#requires| $ly@@84 |n#0@@2|)))) :qid |bitvecto.149:20| :skolemid |886| :pattern ( (|_module.__default.pow2#requires| $ly@@84 |n#0@@2|)) )))
(assert  (=> true (forall (($ly@@85 T@U) (|n#0@@3| Int) ) (!  (=> (and (= (type $ly@@85) LayerTypeType) (or (|_module.__default.pow2#canCall| |n#0@@3|) (INTERNAL_le_boogie 0 |n#0@@3|))) (and (=> (not (= |n#0@@3| (LitInt 0))) (|_module.__default.pow2#canCall| (INTERNAL_sub_boogie |n#0@@3| 1))) (= (_module.__default.pow2 ($LS $ly@@85) |n#0@@3|) (ite (= |n#0@@3| (LitInt 0)) 1 (INTERNAL_mul_boogie 2 (_module.__default.pow2 $ly@@85 (INTERNAL_sub_boogie |n#0@@3| 1))))))) :qid |bitvecto.149:20| :skolemid |887| :pattern ( (_module.__default.pow2 ($LS $ly@@85) |n#0@@3|)) ))))
(assert  (=> true (forall (($ly@@86 T@U) (|n#0@@4| Int) ) (!  (=> (and (= (type $ly@@86) LayerTypeType) (or (|_module.__default.pow2#canCall| (LitInt |n#0@@4|)) (INTERNAL_le_boogie 0 |n#0@@4|))) (and (=> (not (= (LitInt |n#0@@4|) (LitInt 0))) (|_module.__default.pow2#canCall| (LitInt (INTERNAL_sub_boogie |n#0@@4| 1)))) (= (_module.__default.pow2 ($LS $ly@@86) (LitInt |n#0@@4|)) (ite (= (LitInt |n#0@@4|) (LitInt 0)) 1 (INTERNAL_mul_boogie 2 (_module.__default.pow2 ($LS $ly@@86) (LitInt (INTERNAL_sub_boogie |n#0@@4| 1)))))))) :qid |bitvecto.149:20| :weight 3 :skolemid |888| :pattern ( (_module.__default.pow2 ($LS $ly@@86) (LitInt |n#0@@4|))) ))))
(assert  (=> true (forall ((|bitpos#0| Int) ) (!  (=> (or (|_module.__default.BitAtPos_k#canCall| |bitpos#0|) (and (INTERNAL_le_boogie 0 |bitpos#0|) (INTERNAL_lt_boogie |bitpos#0| 32))) true) :qid |bitvecto.155:20| :skolemid |889| :pattern ( (_module.__default.BitAtPos_k |bitpos#0|)) ))))
(assert (forall ((|bitpos#0@@0| Int) ) (!  (and (=> (|_module.__default.BitAtPos_k#requires| |bitpos#0@@0|) (and (INTERNAL_le_boogie 0 |bitpos#0@@0|) (INTERNAL_lt_boogie |bitpos#0@@0| 32))) (=> (and (INTERNAL_le_boogie 0 |bitpos#0@@0|) (INTERNAL_lt_boogie |bitpos#0@@0| 32)) (|_module.__default.BitAtPos_k#requires| |bitpos#0@@0|))) :qid |bitvecto.155:20| :skolemid |890| :pattern ( (|_module.__default.BitAtPos_k#requires| |bitpos#0@@0|)) )))
(assert  (=> true (forall ((|bitpos#0@@1| Int) ) (!  (=> (or (|_module.__default.BitAtPos_k#canCall| |bitpos#0@@1|) (and (INTERNAL_le_boogie 0 |bitpos#0@@1|) (INTERNAL_lt_boogie |bitpos#0@@1| 32))) (= (_module.__default.BitAtPos_k |bitpos#0@@1|) (bvshl #x00000001 ((_ int2bv 32) |bitpos#0@@1|)))) :qid |bitvecto.155:20| :skolemid |891| :pattern ( (_module.__default.BitAtPos_k |bitpos#0@@1|)) ))))
(assert  (=> true (forall ((|bitpos#0@@2| Int) ) (!  (=> (or (|_module.__default.BitAtPos_k#canCall| (LitInt |bitpos#0@@2|)) (and (INTERNAL_le_boogie 0 |bitpos#0@@2|) (INTERNAL_lt_boogie |bitpos#0@@2| 32))) (= (_module.__default.BitAtPos_k (LitInt |bitpos#0@@2|)) (bvshl #x00000001 ((_ int2bv 32) |bitpos#0@@2|)))) :qid |bitvecto.155:20| :weight 3 :skolemid |892| :pattern ( (_module.__default.BitAtPos_k (LitInt |bitpos#0@@2|))) ))))
(assert (forall (($ly@@87 T@U) (|bitpos#0@@3| Int) ) (!  (=> (= (type $ly@@87) LayerTypeType) (= (_module.__default.BitAtPos ($LS $ly@@87) |bitpos#0@@3|) (_module.__default.BitAtPos $ly@@87 |bitpos#0@@3|))) :qid |bitvecto.165:20| :skolemid |893| :pattern ( (_module.__default.BitAtPos ($LS $ly@@87) |bitpos#0@@3|)) )))
(assert (forall (($ly@@88 T@U) (|bitpos#0@@4| Int) ) (!  (=> (= (type $ly@@88) LayerTypeType) (= (_module.__default.BitAtPos $ly@@88 |bitpos#0@@4|) (_module.__default.BitAtPos $LZ |bitpos#0@@4|))) :qid |bitvecto.165:20| :skolemid |894| :pattern ( (_module.__default.BitAtPos (AsFuelBottom $ly@@88) |bitpos#0@@4|)) )))
(assert  (and (= (type StartFuel__module._default.BitsAsWord) LayerTypeType) (= (type StartFuel__module._default.pow2) LayerTypeType)))
(assert  (=> true (forall (($ly@@89 T@U) (|bitpos#0@@5| Int) ) (!  (=> (and (= (type $ly@@89) LayerTypeType) (or (|_module.__default.BitAtPos#canCall| |bitpos#0@@5|) (and (INTERNAL_le_boogie 0 |bitpos#0@@5|) (INTERNAL_lt_boogie |bitpos#0@@5| 32)))) (and (not (= (_module.__default.BitAtPos $ly@@89 |bitpos#0@@5|) #x00000000)) (= (_module.__default.BitsAsWord StartFuel__module._default.BitsAsWord (_module.__default.BitAtPos $ly@@89 |bitpos#0@@5|)) (_module.__default.pow2 StartFuel__module._default.pow2 |bitpos#0@@5|)))) :qid |bitvecto.165:20| :skolemid |895| :pattern ( (_module.__default.BitAtPos $ly@@89 |bitpos#0@@5|)) ))))
(assert (forall (($ly@@90 T@U) (|bitpos#0@@6| Int) ) (!  (=> (= (type $ly@@90) LayerTypeType) (and (=> (|_module.__default.BitAtPos#requires| $ly@@90 |bitpos#0@@6|) (and (INTERNAL_le_boogie 0 |bitpos#0@@6|) (INTERNAL_lt_boogie |bitpos#0@@6| 32))) (=> (and (INTERNAL_le_boogie 0 |bitpos#0@@6|) (INTERNAL_lt_boogie |bitpos#0@@6| 32)) (|_module.__default.BitAtPos#requires| $ly@@90 |bitpos#0@@6|)))) :qid |bitvecto.165:20| :skolemid |896| :pattern ( (|_module.__default.BitAtPos#requires| $ly@@90 |bitpos#0@@6|)) )))
(assert  (=> true (forall (($ly@@91 T@U) (|bitpos#0@@7| Int) ) (!  (=> (and (= (type $ly@@91) LayerTypeType) (or (|_module.__default.BitAtPos#canCall| |bitpos#0@@7|) (and (INTERNAL_le_boogie 0 |bitpos#0@@7|) (INTERNAL_lt_boogie |bitpos#0@@7| 32)))) (and (|_module.__default.BitAtPos_k#canCall| |bitpos#0@@7|) (= (_module.__default.BitAtPos ($LS $ly@@91) |bitpos#0@@7|) (_module.__default.BitAtPos_k |bitpos#0@@7|)))) :qid |bitvecto.165:20| :skolemid |897| :pattern ( (_module.__default.BitAtPos ($LS $ly@@91) |bitpos#0@@7|)) ))))
(assert  (=> true (forall (($ly@@92 T@U) (|bitpos#0@@8| Int) ) (!  (=> (and (= (type $ly@@92) LayerTypeType) (or (|_module.__default.BitAtPos#canCall| (LitInt |bitpos#0@@8|)) (and (INTERNAL_le_boogie 0 |bitpos#0@@8|) (INTERNAL_lt_boogie |bitpos#0@@8| 32)))) (and (|_module.__default.BitAtPos_k#canCall| (LitInt |bitpos#0@@8|)) (= (_module.__default.BitAtPos ($LS $ly@@92) (LitInt |bitpos#0@@8|)) (U_2_bv32 (Lit (bv32_2_U (_module.__default.BitAtPos_k (LitInt |bitpos#0@@8|)))))))) :qid |bitvecto.165:20| :weight 3 :skolemid |898| :pattern ( (_module.__default.BitAtPos ($LS $ly@@92) (LitInt |bitpos#0@@8|))) ))))
(assert  (=> true (forall ((|bitpos#0@@9| Int) ) (!  (=> (or (|_module.__default.BitmaskLow#canCall| |bitpos#0@@9|) (and (INTERNAL_le_boogie 0 |bitpos#0@@9|) (INTERNAL_lt_boogie |bitpos#0@@9| 32))) true) :qid |bitvecto.173:21| :skolemid |899| :pattern ( (_module.__default.BitmaskLow |bitpos#0@@9|)) ))))
(assert (forall ((|bitpos#0@@10| Int) ) (!  (and (=> (|_module.__default.BitmaskLow#requires| |bitpos#0@@10|) (and (INTERNAL_le_boogie 0 |bitpos#0@@10|) (INTERNAL_lt_boogie |bitpos#0@@10| 32))) (=> (and (INTERNAL_le_boogie 0 |bitpos#0@@10|) (INTERNAL_lt_boogie |bitpos#0@@10| 32)) (|_module.__default.BitmaskLow#requires| |bitpos#0@@10|))) :qid |bitvecto.173:21| :skolemid |900| :pattern ( (|_module.__default.BitmaskLow#requires| |bitpos#0@@10|)) )))
(assert (= (type StartFuel__module._default.BitAtPos) LayerTypeType))
(assert  (=> true (forall ((|bitpos#0@@11| Int) ) (!  (=> (or (|_module.__default.BitmaskLow#canCall| |bitpos#0@@11|) (and (INTERNAL_le_boogie 0 |bitpos#0@@11|) (INTERNAL_lt_boogie |bitpos#0@@11| 32))) (and (|_module.__default.BitAtPos#canCall| |bitpos#0@@11|) (= (_module.__default.BitmaskLow |bitpos#0@@11|) (bvsub (_module.__default.BitAtPos StartFuel__module._default.BitAtPos |bitpos#0@@11|) #x00000001)))) :qid |bitvecto.173:21| :skolemid |901| :pattern ( (_module.__default.BitmaskLow |bitpos#0@@11|)) ))))
(assert  (=> true (forall ((|bitpos#0@@12| Int) ) (!  (=> (or (|_module.__default.BitmaskLow#canCall| (LitInt |bitpos#0@@12|)) (and (INTERNAL_le_boogie 0 |bitpos#0@@12|) (INTERNAL_lt_boogie |bitpos#0@@12| 32))) (and (|_module.__default.BitAtPos#canCall| (LitInt |bitpos#0@@12|)) (= (_module.__default.BitmaskLow (LitInt |bitpos#0@@12|)) (bvsub (_module.__default.BitAtPos StartFuel__module._default.BitAtPos (LitInt |bitpos#0@@12|)) #x00000001)))) :qid |bitvecto.173:21| :weight 3 :skolemid |902| :pattern ( (_module.__default.BitmaskLow (LitInt |bitpos#0@@12|))) ))))
(assert  (=> true (forall ((|bitpos#0@@13| Int) ) (!  (=> (or (|_module.__default.BitmaskHigh#canCall| |bitpos#0@@13|) (and (INTERNAL_le_boogie 0 |bitpos#0@@13|) (INTERNAL_lt_boogie |bitpos#0@@13| 32))) true) :qid |bitvecto.179:22| :skolemid |903| :pattern ( (_module.__default.BitmaskHigh |bitpos#0@@13|)) ))))
(assert (forall ((|bitpos#0@@14| Int) ) (!  (and (=> (|_module.__default.BitmaskHigh#requires| |bitpos#0@@14|) (and (INTERNAL_le_boogie 0 |bitpos#0@@14|) (INTERNAL_lt_boogie |bitpos#0@@14| 32))) (=> (and (INTERNAL_le_boogie 0 |bitpos#0@@14|) (INTERNAL_lt_boogie |bitpos#0@@14| 32)) (|_module.__default.BitmaskHigh#requires| |bitpos#0@@14|))) :qid |bitvecto.179:22| :skolemid |904| :pattern ( (|_module.__default.BitmaskHigh#requires| |bitpos#0@@14|)) )))
(assert (= (type StartFuel__module._default.BitNot) LayerTypeType))
(assert  (=> true (forall ((|bitpos#0@@15| Int) ) (!  (=> (or (|_module.__default.BitmaskHigh#canCall| |bitpos#0@@15|) (and (INTERNAL_le_boogie 0 |bitpos#0@@15|) (INTERNAL_lt_boogie |bitpos#0@@15| 32))) (and (and (|_module.__default.BitmaskLow#canCall| |bitpos#0@@15|) (|_module.__default.BitNot#canCall| (_module.__default.BitmaskLow |bitpos#0@@15|))) (= (_module.__default.BitmaskHigh |bitpos#0@@15|) (_module.__default.BitNot StartFuel__module._default.BitNot (_module.__default.BitmaskLow |bitpos#0@@15|))))) :qid |bitvecto.179:22| :skolemid |905| :pattern ( (_module.__default.BitmaskHigh |bitpos#0@@15|)) ))))
(assert  (=> true (forall ((|bitpos#0@@16| Int) ) (!  (=> (or (|_module.__default.BitmaskHigh#canCall| (LitInt |bitpos#0@@16|)) (and (INTERNAL_le_boogie 0 |bitpos#0@@16|) (INTERNAL_lt_boogie |bitpos#0@@16| 32))) (and (and (|_module.__default.BitmaskLow#canCall| (LitInt |bitpos#0@@16|)) (|_module.__default.BitNot#canCall| (U_2_bv32 (Lit (bv32_2_U (_module.__default.BitmaskLow (LitInt |bitpos#0@@16|))))))) (= (_module.__default.BitmaskHigh (LitInt |bitpos#0@@16|)) (_module.__default.BitNot StartFuel__module._default.BitNot (U_2_bv32 (Lit (bv32_2_U (_module.__default.BitmaskLow (LitInt |bitpos#0@@16|))))))))) :qid |bitvecto.179:22| :weight 3 :skolemid |906| :pattern ( (_module.__default.BitmaskHigh (LitInt |bitpos#0@@16|))) ))))
(assert  (=> true (forall ((|n#0@@5| Int) ) (!  (=> (or (|_module.__default.pow2__properties#canCall| |n#0@@5|) (INTERNAL_le_boogie 0 |n#0@@5|)) true) :qid |bitvecto.240:27| :skolemid |907| :pattern ( (_module.__default.pow2__properties |n#0@@5|)) ))))
(assert (forall ((|n#0@@6| Int) ) (!  (=> (INTERNAL_le_boogie 0 |n#0@@6|) (and (=> (|_module.__default.pow2__properties#requires| |n#0@@6|) true) (=> true (|_module.__default.pow2__properties#requires| |n#0@@6|)))) :qid |bitvecto.240:27| :skolemid |908| :pattern ( (|_module.__default.pow2__properties#requires| |n#0@@6|)) )))
(assert  (=> true (forall ((|n#0@@7| Int) ) (!  (=> (or (|_module.__default.pow2__properties#canCall| |n#0@@7|) (INTERNAL_le_boogie 0 |n#0@@7|)) (and (and (and (=> (INTERNAL_ge_boogie |n#0@@7| 2) (|_module.__default.pow2#canCall| |n#0@@7|)) (=> (and (|_module.__default.pow2#canCall| |n#0@@7|) (= (INTERNAL_mod_boogie (_module.__default.pow2 StartFuel__module._default.pow2 |n#0@@7|) 4) (LitInt 0))) (|_module.__default.pow2#canCall| (LitInt 10)))) (=> (and (|_module.__default.pow2#canCall| (LitInt 10)) (= (_module.__default.pow2 StartFuel__module._default.pow2 (LitInt 10)) (LitInt 1024))) (|_module.__default.pow2#canCall| (LitInt 12)))) (and (=> (_module.__default.pow2__properties |n#0@@7|) (and (and (=> (INTERNAL_ge_boogie |n#0@@7| 2) (= (INTERNAL_mod_boogie (_module.__default.pow2 StartFuel__module._default.pow2 |n#0@@7|) 4) (LitInt 0))) (= (_module.__default.pow2 StartFuel__module._default.pow2 (LitInt 10)) (LitInt 1024))) (= (_module.__default.pow2 StartFuel__module._default.pow2 (LitInt 12)) (LitInt 4096)))) (=> (and (and (=> (INTERNAL_ge_boogie |n#0@@7| 2) (= (INTERNAL_mod_boogie (_module.__default.pow2 StartFuel__module._default.pow2 |n#0@@7|) 4) (LitInt 0))) (= (_module.__default.pow2 StartFuel__module._default.pow2 (LitInt 10)) (LitInt 1024))) (= (_module.__default.pow2 StartFuel__module._default.pow2 (LitInt 12)) (LitInt 4096))) (_module.__default.pow2__properties |n#0@@7|))))) :qid |bitvecto.240:27| :skolemid |909| :pattern ( (_module.__default.pow2__properties |n#0@@7|)) ))))
(assert  (=> true (forall ((|n#0@@8| Int) ) (!  (=> (or (|_module.__default.pow2__properties#canCall| (LitInt |n#0@@8|)) (INTERNAL_le_boogie 0 |n#0@@8|)) (and (and (and (=> (INTERNAL_ge_boogie |n#0@@8| 2) (|_module.__default.pow2#canCall| (LitInt |n#0@@8|))) (=> (and (|_module.__default.pow2#canCall| (LitInt |n#0@@8|)) (= (INTERNAL_mod_boogie (_module.__default.pow2 StartFuel__module._default.pow2 (LitInt |n#0@@8|)) 4) (LitInt 0))) (|_module.__default.pow2#canCall| (LitInt 10)))) (=> (and (|_module.__default.pow2#canCall| (LitInt 10)) (= (_module.__default.pow2 StartFuel__module._default.pow2 (LitInt 10)) (LitInt 1024))) (|_module.__default.pow2#canCall| (LitInt 12)))) (and (=> (_module.__default.pow2__properties (LitInt |n#0@@8|)) (and (and (=> (INTERNAL_ge_boogie |n#0@@8| 2) (= (INTERNAL_mod_boogie (_module.__default.pow2 StartFuel__module._default.pow2 (LitInt |n#0@@8|)) 4) (LitInt 0))) (= (_module.__default.pow2 StartFuel__module._default.pow2 (LitInt 10)) (LitInt 1024))) (= (_module.__default.pow2 StartFuel__module._default.pow2 (LitInt 12)) (LitInt 4096)))) (=> (and (and (=> (INTERNAL_ge_boogie |n#0@@8| 2) (= (INTERNAL_mod_boogie (_module.__default.pow2 StartFuel__module._default.pow2 (LitInt |n#0@@8|)) 4) (LitInt 0))) (= (_module.__default.pow2 StartFuel__module._default.pow2 (LitInt 10)) (LitInt 1024))) (= (_module.__default.pow2 StartFuel__module._default.pow2 (LitInt 12)) (LitInt 4096))) (_module.__default.pow2__properties (LitInt |n#0@@8|)))))) :qid |bitvecto.240:27| :weight 3 :skolemid |910| :pattern ( (_module.__default.pow2__properties (LitInt |n#0@@8|))) ))))
(assert (forall (($ly@@93 T@U) (|i#0@@5| Int) (|bitpos#0@@17| Int) ) (!  (=> (= (type $ly@@93) LayerTypeType) (= (_module.__default.BitwiseMaskHigh ($LS $ly@@93) |i#0@@5| |bitpos#0@@17|) (_module.__default.BitwiseMaskHigh $ly@@93 |i#0@@5| |bitpos#0@@17|))) :qid |bitvecto.253:20| :skolemid |911| :pattern ( (_module.__default.BitwiseMaskHigh ($LS $ly@@93) |i#0@@5| |bitpos#0@@17|)) )))
(assert (forall (($ly@@94 T@U) (|i#0@@6| Int) (|bitpos#0@@18| Int) ) (!  (=> (= (type $ly@@94) LayerTypeType) (= (_module.__default.BitwiseMaskHigh $ly@@94 |i#0@@6| |bitpos#0@@18|) (_module.__default.BitwiseMaskHigh $LZ |i#0@@6| |bitpos#0@@18|))) :qid |bitvecto.253:20| :skolemid |912| :pattern ( (_module.__default.BitwiseMaskHigh (AsFuelBottom $ly@@94) |i#0@@6| |bitpos#0@@18|)) )))
(assert  (=> true (forall (($ly@@95 T@U) (|i#0@@7| Int) (|bitpos#0@@19| Int) ) (!  (=> (and (= (type $ly@@95) LayerTypeType) (or (|_module.__default.BitwiseMaskHigh#canCall| |i#0@@7| |bitpos#0@@19|) (and (_module.__default.isUInt32 |i#0@@7|) (and (INTERNAL_le_boogie 0 |bitpos#0@@19|) (INTERNAL_lt_boogie |bitpos#0@@19| 32))))) (and (and (and (= (_module.__default.BitwiseMaskHigh $ly@@95 |i#0@@7| |bitpos#0@@19|) (INTERNAL_mul_boogie (INTERNAL_div_boogie |i#0@@7| (_module.__default.pow2 StartFuel__module._default.pow2 |bitpos#0@@19|)) (_module.__default.pow2 StartFuel__module._default.pow2 |bitpos#0@@19|))) (= (INTERNAL_mod_boogie (_module.__default.BitwiseMaskHigh $ly@@95 |i#0@@7| |bitpos#0@@19|) (_module.__default.pow2 StartFuel__module._default.pow2 |bitpos#0@@19|)) (LitInt 0))) (_module.__default.pow2__properties |bitpos#0@@19|)) (_module.__default.isUInt32 (_module.__default.BitwiseMaskHigh $ly@@95 |i#0@@7| |bitpos#0@@19|)))) :qid |bitvecto.253:20| :skolemid |913| :pattern ( (_module.__default.BitwiseMaskHigh $ly@@95 |i#0@@7| |bitpos#0@@19|)) ))))
(assert (forall (($ly@@96 T@U) (|i#0@@8| Int) (|bitpos#0@@20| Int) ) (!  (=> (and (= (type $ly@@96) LayerTypeType) (_module.__default.isUInt32 |i#0@@8|)) (and (=> (|_module.__default.BitwiseMaskHigh#requires| $ly@@96 |i#0@@8| |bitpos#0@@20|) (and (INTERNAL_le_boogie 0 |bitpos#0@@20|) (INTERNAL_lt_boogie |bitpos#0@@20| 32))) (=> (and (INTERNAL_le_boogie 0 |bitpos#0@@20|) (INTERNAL_lt_boogie |bitpos#0@@20| 32)) (|_module.__default.BitwiseMaskHigh#requires| $ly@@96 |i#0@@8| |bitpos#0@@20|)))) :qid |bitvecto.253:20| :skolemid |914| :pattern ( (|_module.__default.BitwiseMaskHigh#requires| $ly@@96 |i#0@@8| |bitpos#0@@20|)) )))
(assert  (and (= (type StartFuel__module._default.WordAsBits) LayerTypeType) (= (type StartFuel__module._default.BitAnd) LayerTypeType)))
(assert  (=> true (forall (($ly@@97 T@U) (|i#0@@9| Int) (|bitpos#0@@21| Int) ) (!  (=> (and (= (type $ly@@97) LayerTypeType) (or (|_module.__default.BitwiseMaskHigh#canCall| |i#0@@9| |bitpos#0@@21|) (and (_module.__default.isUInt32 |i#0@@9|) (and (INTERNAL_le_boogie 0 |bitpos#0@@21|) (INTERNAL_lt_boogie |bitpos#0@@21| 32))))) (and (and (and (and (|_module.__default.WordAsBits#canCall| |i#0@@9|) (|_module.__default.BitmaskHigh#canCall| |bitpos#0@@21|)) (|_module.__default.BitAnd#canCall| (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |i#0@@9|) (_module.__default.BitmaskHigh |bitpos#0@@21|))) (|_module.__default.BitsAsWord#canCall| (_module.__default.BitAnd StartFuel__module._default.BitAnd (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |i#0@@9|) (_module.__default.BitmaskHigh |bitpos#0@@21|)))) (= (_module.__default.BitwiseMaskHigh ($LS $ly@@97) |i#0@@9| |bitpos#0@@21|) (_module.__default.BitsAsWord StartFuel__module._default.BitsAsWord (_module.__default.BitAnd StartFuel__module._default.BitAnd (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |i#0@@9|) (_module.__default.BitmaskHigh |bitpos#0@@21|)))))) :qid |bitvecto.253:20| :skolemid |915| :pattern ( (_module.__default.BitwiseMaskHigh ($LS $ly@@97) |i#0@@9| |bitpos#0@@21|)) ))))
(assert  (=> true (forall (($ly@@98 T@U) (|i#0@@10| Int) (|bitpos#0@@22| Int) ) (!  (=> (and (= (type $ly@@98) LayerTypeType) (or (|_module.__default.BitwiseMaskHigh#canCall| (LitInt |i#0@@10|) (LitInt |bitpos#0@@22|)) (and (_module.__default.isUInt32 |i#0@@10|) (and (INTERNAL_le_boogie 0 |bitpos#0@@22|) (INTERNAL_lt_boogie |bitpos#0@@22| 32))))) (and (and (and (and (|_module.__default.WordAsBits#canCall| (LitInt |i#0@@10|)) (|_module.__default.BitmaskHigh#canCall| (LitInt |bitpos#0@@22|))) (|_module.__default.BitAnd#canCall| (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |i#0@@10|)) (U_2_bv32 (Lit (bv32_2_U (_module.__default.BitmaskHigh (LitInt |bitpos#0@@22|))))))) (|_module.__default.BitsAsWord#canCall| (_module.__default.BitAnd StartFuel__module._default.BitAnd (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |i#0@@10|)) (U_2_bv32 (Lit (bv32_2_U (_module.__default.BitmaskHigh (LitInt |bitpos#0@@22|)))))))) (= (_module.__default.BitwiseMaskHigh ($LS $ly@@98) (LitInt |i#0@@10|) (LitInt |bitpos#0@@22|)) (_module.__default.BitsAsWord StartFuel__module._default.BitsAsWord (_module.__default.BitAnd StartFuel__module._default.BitAnd (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |i#0@@10|)) (U_2_bv32 (Lit (bv32_2_U (_module.__default.BitmaskHigh (LitInt |bitpos#0@@22|)))))))))) :qid |bitvecto.253:20| :weight 3 :skolemid |916| :pattern ( (_module.__default.BitwiseMaskHigh ($LS $ly@@98) (LitInt |i#0@@10|) (LitInt |bitpos#0@@22|))) ))))
(assert (forall (($ly@@99 T@U) (|i#0@@11| Int) (|bitpos#0@@23| Int) ) (!  (=> (= (type $ly@@99) LayerTypeType) (= (_module.__default.BitwiseMaskLow ($LS $ly@@99) |i#0@@11| |bitpos#0@@23|) (_module.__default.BitwiseMaskLow $ly@@99 |i#0@@11| |bitpos#0@@23|))) :qid |bitvecto.264:20| :skolemid |917| :pattern ( (_module.__default.BitwiseMaskLow ($LS $ly@@99) |i#0@@11| |bitpos#0@@23|)) )))
(assert (forall (($ly@@100 T@U) (|i#0@@12| Int) (|bitpos#0@@24| Int) ) (!  (=> (= (type $ly@@100) LayerTypeType) (= (_module.__default.BitwiseMaskLow $ly@@100 |i#0@@12| |bitpos#0@@24|) (_module.__default.BitwiseMaskLow $LZ |i#0@@12| |bitpos#0@@24|))) :qid |bitvecto.264:20| :skolemid |918| :pattern ( (_module.__default.BitwiseMaskLow (AsFuelBottom $ly@@100) |i#0@@12| |bitpos#0@@24|)) )))
(assert  (=> true (forall (($ly@@101 T@U) (|i#0@@13| Int) (|bitpos#0@@25| Int) ) (!  (=> (and (= (type $ly@@101) LayerTypeType) (or (|_module.__default.BitwiseMaskLow#canCall| |i#0@@13| |bitpos#0@@25|) (and (_module.__default.isUInt32 |i#0@@13|) (and (INTERNAL_le_boogie 0 |bitpos#0@@25|) (INTERNAL_lt_boogie |bitpos#0@@25| 32))))) (and (and (= (_module.__default.BitwiseMaskLow $ly@@101 |i#0@@13| |bitpos#0@@25|) (INTERNAL_mod_boogie |i#0@@13| (_module.__default.pow2 StartFuel__module._default.pow2 |bitpos#0@@25|))) (_module.__default.pow2__properties |bitpos#0@@25|)) (_module.__default.isUInt32 (_module.__default.BitwiseMaskLow $ly@@101 |i#0@@13| |bitpos#0@@25|)))) :qid |bitvecto.264:20| :skolemid |919| :pattern ( (_module.__default.BitwiseMaskLow $ly@@101 |i#0@@13| |bitpos#0@@25|)) ))))
(assert (forall (($ly@@102 T@U) (|i#0@@14| Int) (|bitpos#0@@26| Int) ) (!  (=> (and (= (type $ly@@102) LayerTypeType) (_module.__default.isUInt32 |i#0@@14|)) (and (=> (|_module.__default.BitwiseMaskLow#requires| $ly@@102 |i#0@@14| |bitpos#0@@26|) (and (INTERNAL_le_boogie 0 |bitpos#0@@26|) (INTERNAL_lt_boogie |bitpos#0@@26| 32))) (=> (and (INTERNAL_le_boogie 0 |bitpos#0@@26|) (INTERNAL_lt_boogie |bitpos#0@@26| 32)) (|_module.__default.BitwiseMaskLow#requires| $ly@@102 |i#0@@14| |bitpos#0@@26|)))) :qid |bitvecto.264:20| :skolemid |920| :pattern ( (|_module.__default.BitwiseMaskLow#requires| $ly@@102 |i#0@@14| |bitpos#0@@26|)) )))
(assert  (=> true (forall (($ly@@103 T@U) (|i#0@@15| Int) (|bitpos#0@@27| Int) ) (!  (=> (and (= (type $ly@@103) LayerTypeType) (or (|_module.__default.BitwiseMaskLow#canCall| |i#0@@15| |bitpos#0@@27|) (and (_module.__default.isUInt32 |i#0@@15|) (and (INTERNAL_le_boogie 0 |bitpos#0@@27|) (INTERNAL_lt_boogie |bitpos#0@@27| 32))))) (and (and (and (and (|_module.__default.WordAsBits#canCall| |i#0@@15|) (|_module.__default.BitmaskLow#canCall| |bitpos#0@@27|)) (|_module.__default.BitAnd#canCall| (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |i#0@@15|) (_module.__default.BitmaskLow |bitpos#0@@27|))) (|_module.__default.BitsAsWord#canCall| (_module.__default.BitAnd StartFuel__module._default.BitAnd (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |i#0@@15|) (_module.__default.BitmaskLow |bitpos#0@@27|)))) (= (_module.__default.BitwiseMaskLow ($LS $ly@@103) |i#0@@15| |bitpos#0@@27|) (_module.__default.BitsAsWord StartFuel__module._default.BitsAsWord (_module.__default.BitAnd StartFuel__module._default.BitAnd (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |i#0@@15|) (_module.__default.BitmaskLow |bitpos#0@@27|)))))) :qid |bitvecto.264:20| :skolemid |921| :pattern ( (_module.__default.BitwiseMaskLow ($LS $ly@@103) |i#0@@15| |bitpos#0@@27|)) ))))
(assert  (=> true (forall (($ly@@104 T@U) (|i#0@@16| Int) (|bitpos#0@@28| Int) ) (!  (=> (and (= (type $ly@@104) LayerTypeType) (or (|_module.__default.BitwiseMaskLow#canCall| (LitInt |i#0@@16|) (LitInt |bitpos#0@@28|)) (and (_module.__default.isUInt32 |i#0@@16|) (and (INTERNAL_le_boogie 0 |bitpos#0@@28|) (INTERNAL_lt_boogie |bitpos#0@@28| 32))))) (and (and (and (and (|_module.__default.WordAsBits#canCall| (LitInt |i#0@@16|)) (|_module.__default.BitmaskLow#canCall| (LitInt |bitpos#0@@28|))) (|_module.__default.BitAnd#canCall| (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |i#0@@16|)) (U_2_bv32 (Lit (bv32_2_U (_module.__default.BitmaskLow (LitInt |bitpos#0@@28|))))))) (|_module.__default.BitsAsWord#canCall| (_module.__default.BitAnd StartFuel__module._default.BitAnd (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |i#0@@16|)) (U_2_bv32 (Lit (bv32_2_U (_module.__default.BitmaskLow (LitInt |bitpos#0@@28|)))))))) (= (_module.__default.BitwiseMaskLow ($LS $ly@@104) (LitInt |i#0@@16|) (LitInt |bitpos#0@@28|)) (_module.__default.BitsAsWord StartFuel__module._default.BitsAsWord (_module.__default.BitAnd StartFuel__module._default.BitAnd (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |i#0@@16|)) (U_2_bv32 (Lit (bv32_2_U (_module.__default.BitmaskLow (LitInt |bitpos#0@@28|)))))))))) :qid |bitvecto.264:20| :weight 3 :skolemid |922| :pattern ( (_module.__default.BitwiseMaskLow ($LS $ly@@104) (LitInt |i#0@@16|) (LitInt |bitpos#0@@28|))) ))))
(assert  (=> true (forall ((|x#0@@71| Int) (|y#0@@47| Int) ) (!  (=> (or (|_module.__default.BitwiseXor#canCall| |x#0@@71| |y#0@@47|) (and (_module.__default.isUInt32 |x#0@@71|) (_module.__default.isUInt32 |y#0@@47|))) (_module.__default.isUInt32 (_module.__default.BitwiseXor |x#0@@71| |y#0@@47|))) :qid |bitvecto.10:21| :skolemid |923| :pattern ( (_module.__default.BitwiseXor |x#0@@71| |y#0@@47|)) ))))
(assert (forall ((|x#0@@72| Int) (|y#0@@48| Int) ) (!  (=> (and (_module.__default.isUInt32 |x#0@@72|) (_module.__default.isUInt32 |y#0@@48|)) (and (=> (|_module.__default.BitwiseXor#requires| |x#0@@72| |y#0@@48|) true) (=> true (|_module.__default.BitwiseXor#requires| |x#0@@72| |y#0@@48|)))) :qid |bitvecto.10:21| :skolemid |924| :pattern ( (|_module.__default.BitwiseXor#requires| |x#0@@72| |y#0@@48|)) )))
(assert (= (type StartFuel__module._default.BitXor) LayerTypeType))
(assert  (=> true (forall ((|x#0@@73| Int) (|y#0@@49| Int) ) (!  (=> (or (|_module.__default.BitwiseXor#canCall| |x#0@@73| |y#0@@49|) (and (_module.__default.isUInt32 |x#0@@73|) (_module.__default.isUInt32 |y#0@@49|))) (and (and (and (and (|_module.__default.WordAsBits#canCall| |x#0@@73|) (|_module.__default.WordAsBits#canCall| |y#0@@49|)) (|_module.__default.BitXor#canCall| (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@73|) (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |y#0@@49|))) (|_module.__default.BitsAsWord#canCall| (_module.__default.BitXor StartFuel__module._default.BitXor (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@73|) (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |y#0@@49|)))) (= (_module.__default.BitwiseXor |x#0@@73| |y#0@@49|) (_module.__default.BitsAsWord StartFuel__module._default.BitsAsWord (_module.__default.BitXor StartFuel__module._default.BitXor (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@73|) (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |y#0@@49|)))))) :qid |bitvecto.10:21| :skolemid |925| :pattern ( (_module.__default.BitwiseXor |x#0@@73| |y#0@@49|)) ))))
(assert  (=> true (forall ((|x#0@@74| Int) (|y#0@@50| Int) ) (!  (=> (or (|_module.__default.BitwiseXor#canCall| (LitInt |x#0@@74|) (LitInt |y#0@@50|)) (and (_module.__default.isUInt32 |x#0@@74|) (_module.__default.isUInt32 |y#0@@50|))) (and (and (and (and (|_module.__default.WordAsBits#canCall| (LitInt |x#0@@74|)) (|_module.__default.WordAsBits#canCall| (LitInt |y#0@@50|))) (|_module.__default.BitXor#canCall| (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@74|)) (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |y#0@@50|)))) (|_module.__default.BitsAsWord#canCall| (_module.__default.BitXor StartFuel__module._default.BitXor (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@74|)) (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |y#0@@50|))))) (= (_module.__default.BitwiseXor (LitInt |x#0@@74|) (LitInt |y#0@@50|)) (_module.__default.BitsAsWord StartFuel__module._default.BitsAsWord (_module.__default.BitXor StartFuel__module._default.BitXor (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@74|)) (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |y#0@@50|))))))) :qid |bitvecto.10:21| :weight 3 :skolemid |926| :pattern ( (_module.__default.BitwiseXor (LitInt |x#0@@74|) (LitInt |y#0@@50|))) ))))
(assert  (=> true (forall ((|x#0@@75| Int) (|y#0@@51| Int) ) (!  (=> (or (|_module.__default.BitwiseAnd#canCall| |x#0@@75| |y#0@@51|) (and (_module.__default.isUInt32 |x#0@@75|) (_module.__default.isUInt32 |y#0@@51|))) (_module.__default.isUInt32 (_module.__default.BitwiseAnd |x#0@@75| |y#0@@51|))) :qid |bitvecto.13:21| :skolemid |927| :pattern ( (_module.__default.BitwiseAnd |x#0@@75| |y#0@@51|)) ))))
(assert (forall ((|x#0@@76| Int) (|y#0@@52| Int) ) (!  (=> (and (_module.__default.isUInt32 |x#0@@76|) (_module.__default.isUInt32 |y#0@@52|)) (and (=> (|_module.__default.BitwiseAnd#requires| |x#0@@76| |y#0@@52|) true) (=> true (|_module.__default.BitwiseAnd#requires| |x#0@@76| |y#0@@52|)))) :qid |bitvecto.13:21| :skolemid |928| :pattern ( (|_module.__default.BitwiseAnd#requires| |x#0@@76| |y#0@@52|)) )))
(assert  (=> true (forall ((|x#0@@77| Int) (|y#0@@53| Int) ) (!  (=> (or (|_module.__default.BitwiseAnd#canCall| |x#0@@77| |y#0@@53|) (and (_module.__default.isUInt32 |x#0@@77|) (_module.__default.isUInt32 |y#0@@53|))) (and (and (and (and (|_module.__default.WordAsBits#canCall| |x#0@@77|) (|_module.__default.WordAsBits#canCall| |y#0@@53|)) (|_module.__default.BitAnd#canCall| (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@77|) (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |y#0@@53|))) (|_module.__default.BitsAsWord#canCall| (_module.__default.BitAnd StartFuel__module._default.BitAnd (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@77|) (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |y#0@@53|)))) (= (_module.__default.BitwiseAnd |x#0@@77| |y#0@@53|) (_module.__default.BitsAsWord StartFuel__module._default.BitsAsWord (_module.__default.BitAnd StartFuel__module._default.BitAnd (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@77|) (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |y#0@@53|)))))) :qid |bitvecto.13:21| :skolemid |929| :pattern ( (_module.__default.BitwiseAnd |x#0@@77| |y#0@@53|)) ))))
(assert  (=> true (forall ((|x#0@@78| Int) (|y#0@@54| Int) ) (!  (=> (or (|_module.__default.BitwiseAnd#canCall| (LitInt |x#0@@78|) (LitInt |y#0@@54|)) (and (_module.__default.isUInt32 |x#0@@78|) (_module.__default.isUInt32 |y#0@@54|))) (and (and (and (and (|_module.__default.WordAsBits#canCall| (LitInt |x#0@@78|)) (|_module.__default.WordAsBits#canCall| (LitInt |y#0@@54|))) (|_module.__default.BitAnd#canCall| (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@78|)) (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |y#0@@54|)))) (|_module.__default.BitsAsWord#canCall| (_module.__default.BitAnd StartFuel__module._default.BitAnd (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@78|)) (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |y#0@@54|))))) (= (_module.__default.BitwiseAnd (LitInt |x#0@@78|) (LitInt |y#0@@54|)) (_module.__default.BitsAsWord StartFuel__module._default.BitsAsWord (_module.__default.BitAnd StartFuel__module._default.BitAnd (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@78|)) (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |y#0@@54|))))))) :qid |bitvecto.13:21| :weight 3 :skolemid |930| :pattern ( (_module.__default.BitwiseAnd (LitInt |x#0@@78|) (LitInt |y#0@@54|))) ))))
(assert  (=> true (forall ((|x#0@@79| Int) (|y#0@@55| Int) ) (!  (=> (or (|_module.__default.BitwiseOr#canCall| |x#0@@79| |y#0@@55|) (and (_module.__default.isUInt32 |x#0@@79|) (_module.__default.isUInt32 |y#0@@55|))) (_module.__default.isUInt32 (_module.__default.BitwiseOr |x#0@@79| |y#0@@55|))) :qid |bitvecto.16:20| :skolemid |931| :pattern ( (_module.__default.BitwiseOr |x#0@@79| |y#0@@55|)) ))))
(assert (forall ((|x#0@@80| Int) (|y#0@@56| Int) ) (!  (=> (and (_module.__default.isUInt32 |x#0@@80|) (_module.__default.isUInt32 |y#0@@56|)) (and (=> (|_module.__default.BitwiseOr#requires| |x#0@@80| |y#0@@56|) true) (=> true (|_module.__default.BitwiseOr#requires| |x#0@@80| |y#0@@56|)))) :qid |bitvecto.16:20| :skolemid |932| :pattern ( (|_module.__default.BitwiseOr#requires| |x#0@@80| |y#0@@56|)) )))
(assert (= (type StartFuel__module._default.BitOr) LayerTypeType))
(assert  (=> true (forall ((|x#0@@81| Int) (|y#0@@57| Int) ) (!  (=> (or (|_module.__default.BitwiseOr#canCall| |x#0@@81| |y#0@@57|) (and (_module.__default.isUInt32 |x#0@@81|) (_module.__default.isUInt32 |y#0@@57|))) (and (and (and (and (|_module.__default.WordAsBits#canCall| |x#0@@81|) (|_module.__default.WordAsBits#canCall| |y#0@@57|)) (|_module.__default.BitOr#canCall| (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@81|) (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |y#0@@57|))) (|_module.__default.BitsAsWord#canCall| (_module.__default.BitOr StartFuel__module._default.BitOr (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@81|) (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |y#0@@57|)))) (= (_module.__default.BitwiseOr |x#0@@81| |y#0@@57|) (_module.__default.BitsAsWord StartFuel__module._default.BitsAsWord (_module.__default.BitOr StartFuel__module._default.BitOr (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@81|) (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |y#0@@57|)))))) :qid |bitvecto.16:20| :skolemid |933| :pattern ( (_module.__default.BitwiseOr |x#0@@81| |y#0@@57|)) ))))
(assert  (=> true (forall ((|x#0@@82| Int) (|y#0@@58| Int) ) (!  (=> (or (|_module.__default.BitwiseOr#canCall| (LitInt |x#0@@82|) (LitInt |y#0@@58|)) (and (_module.__default.isUInt32 |x#0@@82|) (_module.__default.isUInt32 |y#0@@58|))) (and (and (and (and (|_module.__default.WordAsBits#canCall| (LitInt |x#0@@82|)) (|_module.__default.WordAsBits#canCall| (LitInt |y#0@@58|))) (|_module.__default.BitOr#canCall| (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@82|)) (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |y#0@@58|)))) (|_module.__default.BitsAsWord#canCall| (_module.__default.BitOr StartFuel__module._default.BitOr (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@82|)) (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |y#0@@58|))))) (= (_module.__default.BitwiseOr (LitInt |x#0@@82|) (LitInt |y#0@@58|)) (_module.__default.BitsAsWord StartFuel__module._default.BitsAsWord (_module.__default.BitOr StartFuel__module._default.BitOr (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@82|)) (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |y#0@@58|))))))) :qid |bitvecto.16:20| :weight 3 :skolemid |934| :pattern ( (_module.__default.BitwiseOr (LitInt |x#0@@82|) (LitInt |y#0@@58|))) ))))
(assert  (=> true (forall ((|x#0@@83| Int) ) (!  (=> (or (|_module.__default.BitwiseNot#canCall| |x#0@@83|) (_module.__default.isUInt32 |x#0@@83|)) (_module.__default.isUInt32 (_module.__default.BitwiseNot |x#0@@83|))) :qid |bitvecto.19:21| :skolemid |935| :pattern ( (_module.__default.BitwiseNot |x#0@@83|)) ))))
(assert (forall ((|x#0@@84| Int) ) (!  (=> (_module.__default.isUInt32 |x#0@@84|) (and (=> (|_module.__default.BitwiseNot#requires| |x#0@@84|) true) (=> true (|_module.__default.BitwiseNot#requires| |x#0@@84|)))) :qid |bitvecto.19:21| :skolemid |936| :pattern ( (|_module.__default.BitwiseNot#requires| |x#0@@84|)) )))
(assert  (=> true (forall ((|x#0@@85| Int) ) (!  (=> (or (|_module.__default.BitwiseNot#canCall| |x#0@@85|) (_module.__default.isUInt32 |x#0@@85|)) (and (and (and (|_module.__default.WordAsBits#canCall| |x#0@@85|) (|_module.__default.BitNot#canCall| (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@85|))) (|_module.__default.BitsAsWord#canCall| (_module.__default.BitNot StartFuel__module._default.BitNot (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@85|)))) (= (_module.__default.BitwiseNot |x#0@@85|) (_module.__default.BitsAsWord StartFuel__module._default.BitsAsWord (_module.__default.BitNot StartFuel__module._default.BitNot (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@85|)))))) :qid |bitvecto.19:21| :skolemid |937| :pattern ( (_module.__default.BitwiseNot |x#0@@85|)) ))))
(assert  (=> true (forall ((|x#0@@86| Int) ) (!  (=> (or (|_module.__default.BitwiseNot#canCall| (LitInt |x#0@@86|)) (_module.__default.isUInt32 |x#0@@86|)) (and (and (and (|_module.__default.WordAsBits#canCall| (LitInt |x#0@@86|)) (|_module.__default.BitNot#canCall| (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@86|)))) (|_module.__default.BitsAsWord#canCall| (_module.__default.BitNot StartFuel__module._default.BitNot (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@86|))))) (= (_module.__default.BitwiseNot (LitInt |x#0@@86|)) (_module.__default.BitsAsWord StartFuel__module._default.BitsAsWord (_module.__default.BitNot StartFuel__module._default.BitNot (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@86|))))))) :qid |bitvecto.19:21| :weight 3 :skolemid |938| :pattern ( (_module.__default.BitwiseNot (LitInt |x#0@@86|))) ))))
(assert  (=> true (forall ((|x#0@@87| Int) (|amount#0@@15| Int) ) (!  (=> (or (|_module.__default.LeftShift#canCall| |x#0@@87| |amount#0@@15|) (and (and (_module.__default.isUInt32 |x#0@@87|) (_module.__default.isUInt32 |amount#0@@15|)) (and (INTERNAL_le_boogie 0 |amount#0@@15|) (INTERNAL_lt_boogie |amount#0@@15| 32)))) (_module.__default.isUInt32 (_module.__default.LeftShift |x#0@@87| |amount#0@@15|))) :qid |bitvecto.22:20| :skolemid |939| :pattern ( (_module.__default.LeftShift |x#0@@87| |amount#0@@15|)) ))))
(assert (forall ((|x#0@@88| Int) (|amount#0@@16| Int) ) (!  (=> (and (_module.__default.isUInt32 |x#0@@88|) (_module.__default.isUInt32 |amount#0@@16|)) (and (=> (|_module.__default.LeftShift#requires| |x#0@@88| |amount#0@@16|) (and (INTERNAL_le_boogie 0 |amount#0@@16|) (INTERNAL_lt_boogie |amount#0@@16| 32))) (=> (and (INTERNAL_le_boogie 0 |amount#0@@16|) (INTERNAL_lt_boogie |amount#0@@16| 32)) (|_module.__default.LeftShift#requires| |x#0@@88| |amount#0@@16|)))) :qid |bitvecto.22:20| :skolemid |940| :pattern ( (|_module.__default.LeftShift#requires| |x#0@@88| |amount#0@@16|)) )))
(assert (= (type StartFuel__module._default.BitShiftLeft) LayerTypeType))
(assert  (=> true (forall ((|x#0@@89| Int) (|amount#0@@17| Int) ) (!  (=> (or (|_module.__default.LeftShift#canCall| |x#0@@89| |amount#0@@17|) (and (and (_module.__default.isUInt32 |x#0@@89|) (_module.__default.isUInt32 |amount#0@@17|)) (and (INTERNAL_le_boogie 0 |amount#0@@17|) (INTERNAL_lt_boogie |amount#0@@17| 32)))) (and (and (and (|_module.__default.WordAsBits#canCall| |x#0@@89|) (|_module.__default.BitShiftLeft#canCall| (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@89|) |amount#0@@17|)) (|_module.__default.BitsAsWord#canCall| (_module.__default.BitShiftLeft StartFuel__module._default.BitShiftLeft (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@89|) |amount#0@@17|))) (= (_module.__default.LeftShift |x#0@@89| |amount#0@@17|) (_module.__default.BitsAsWord StartFuel__module._default.BitsAsWord (_module.__default.BitShiftLeft StartFuel__module._default.BitShiftLeft (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@89|) |amount#0@@17|))))) :qid |bitvecto.22:20| :skolemid |941| :pattern ( (_module.__default.LeftShift |x#0@@89| |amount#0@@17|)) ))))
(assert  (=> true (forall ((|x#0@@90| Int) (|amount#0@@18| Int) ) (!  (=> (or (|_module.__default.LeftShift#canCall| (LitInt |x#0@@90|) (LitInt |amount#0@@18|)) (and (and (_module.__default.isUInt32 |x#0@@90|) (_module.__default.isUInt32 |amount#0@@18|)) (and (INTERNAL_le_boogie 0 |amount#0@@18|) (INTERNAL_lt_boogie |amount#0@@18| 32)))) (and (and (and (|_module.__default.WordAsBits#canCall| (LitInt |x#0@@90|)) (|_module.__default.BitShiftLeft#canCall| (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@90|)) (LitInt |amount#0@@18|))) (|_module.__default.BitsAsWord#canCall| (_module.__default.BitShiftLeft StartFuel__module._default.BitShiftLeft (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@90|)) (LitInt |amount#0@@18|)))) (= (_module.__default.LeftShift (LitInt |x#0@@90|) (LitInt |amount#0@@18|)) (_module.__default.BitsAsWord StartFuel__module._default.BitsAsWord (_module.__default.BitShiftLeft StartFuel__module._default.BitShiftLeft (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@90|)) (LitInt |amount#0@@18|)))))) :qid |bitvecto.22:20| :weight 3 :skolemid |942| :pattern ( (_module.__default.LeftShift (LitInt |x#0@@90|) (LitInt |amount#0@@18|))) ))))
(assert  (=> true (forall ((|x#0@@91| Int) (|amount#0@@19| Int) ) (!  (=> (or (|_module.__default.RightShift#canCall| |x#0@@91| |amount#0@@19|) (and (and (_module.__default.isUInt32 |x#0@@91|) (_module.__default.isUInt32 |amount#0@@19|)) (and (INTERNAL_le_boogie 0 |amount#0@@19|) (INTERNAL_lt_boogie |amount#0@@19| 32)))) (_module.__default.isUInt32 (_module.__default.RightShift |x#0@@91| |amount#0@@19|))) :qid |bitvecto.26:21| :skolemid |943| :pattern ( (_module.__default.RightShift |x#0@@91| |amount#0@@19|)) ))))
(assert (forall ((|x#0@@92| Int) (|amount#0@@20| Int) ) (!  (=> (and (_module.__default.isUInt32 |x#0@@92|) (_module.__default.isUInt32 |amount#0@@20|)) (and (=> (|_module.__default.RightShift#requires| |x#0@@92| |amount#0@@20|) (and (INTERNAL_le_boogie 0 |amount#0@@20|) (INTERNAL_lt_boogie |amount#0@@20| 32))) (=> (and (INTERNAL_le_boogie 0 |amount#0@@20|) (INTERNAL_lt_boogie |amount#0@@20| 32)) (|_module.__default.RightShift#requires| |x#0@@92| |amount#0@@20|)))) :qid |bitvecto.26:21| :skolemid |944| :pattern ( (|_module.__default.RightShift#requires| |x#0@@92| |amount#0@@20|)) )))
(assert (= (type StartFuel__module._default.BitShiftRight) LayerTypeType))
(assert  (=> true (forall ((|x#0@@93| Int) (|amount#0@@21| Int) ) (!  (=> (or (|_module.__default.RightShift#canCall| |x#0@@93| |amount#0@@21|) (and (and (_module.__default.isUInt32 |x#0@@93|) (_module.__default.isUInt32 |amount#0@@21|)) (and (INTERNAL_le_boogie 0 |amount#0@@21|) (INTERNAL_lt_boogie |amount#0@@21| 32)))) (and (and (and (|_module.__default.WordAsBits#canCall| |x#0@@93|) (|_module.__default.BitShiftRight#canCall| (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@93|) |amount#0@@21|)) (|_module.__default.BitsAsWord#canCall| (_module.__default.BitShiftRight StartFuel__module._default.BitShiftRight (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@93|) |amount#0@@21|))) (= (_module.__default.RightShift |x#0@@93| |amount#0@@21|) (_module.__default.BitsAsWord StartFuel__module._default.BitsAsWord (_module.__default.BitShiftRight StartFuel__module._default.BitShiftRight (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@93|) |amount#0@@21|))))) :qid |bitvecto.26:21| :skolemid |945| :pattern ( (_module.__default.RightShift |x#0@@93| |amount#0@@21|)) ))))
(assert  (=> true (forall ((|x#0@@94| Int) (|amount#0@@22| Int) ) (!  (=> (or (|_module.__default.RightShift#canCall| (LitInt |x#0@@94|) (LitInt |amount#0@@22|)) (and (and (_module.__default.isUInt32 |x#0@@94|) (_module.__default.isUInt32 |amount#0@@22|)) (and (INTERNAL_le_boogie 0 |amount#0@@22|) (INTERNAL_lt_boogie |amount#0@@22| 32)))) (and (and (and (|_module.__default.WordAsBits#canCall| (LitInt |x#0@@94|)) (|_module.__default.BitShiftRight#canCall| (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@94|)) (LitInt |amount#0@@22|))) (|_module.__default.BitsAsWord#canCall| (_module.__default.BitShiftRight StartFuel__module._default.BitShiftRight (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@94|)) (LitInt |amount#0@@22|)))) (= (_module.__default.RightShift (LitInt |x#0@@94|) (LitInt |amount#0@@22|)) (_module.__default.BitsAsWord StartFuel__module._default.BitsAsWord (_module.__default.BitShiftRight StartFuel__module._default.BitShiftRight (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@94|)) (LitInt |amount#0@@22|)))))) :qid |bitvecto.26:21| :weight 3 :skolemid |946| :pattern ( (_module.__default.RightShift (LitInt |x#0@@94|) (LitInt |amount#0@@22|))) ))))
(assert  (=> true (forall ((|x#0@@95| Int) (|amount#0@@23| Int) ) (!  (=> (or (|_module.__default.RotateRight#canCall| |x#0@@95| |amount#0@@23|) (and (and (_module.__default.isUInt32 |x#0@@95|) (and (INTERNAL_le_boogie 0 |amount#0@@23|) (INTERNAL_lt_boogie |amount#0@@23| 32))) (and (INTERNAL_le_boogie 0 |amount#0@@23|) (INTERNAL_lt_boogie |amount#0@@23| 32)))) (_module.__default.isUInt32 (_module.__default.RotateRight |x#0@@95| |amount#0@@23|))) :qid |bitvecto.30:22| :skolemid |947| :pattern ( (_module.__default.RotateRight |x#0@@95| |amount#0@@23|)) ))))
(assert (forall ((|x#0@@96| Int) (|amount#0@@24| Int) ) (!  (=> (and (_module.__default.isUInt32 |x#0@@96|) (and (INTERNAL_le_boogie 0 |amount#0@@24|) (INTERNAL_lt_boogie |amount#0@@24| 32))) (and (=> (|_module.__default.RotateRight#requires| |x#0@@96| |amount#0@@24|) (and (INTERNAL_le_boogie 0 |amount#0@@24|) (INTERNAL_lt_boogie |amount#0@@24| 32))) (=> (and (INTERNAL_le_boogie 0 |amount#0@@24|) (INTERNAL_lt_boogie |amount#0@@24| 32)) (|_module.__default.RotateRight#requires| |x#0@@96| |amount#0@@24|)))) :qid |bitvecto.30:22| :skolemid |948| :pattern ( (|_module.__default.RotateRight#requires| |x#0@@96| |amount#0@@24|)) )))
(assert (= (type StartFuel__module._default.BitRotateRight) LayerTypeType))
(assert  (=> true (forall ((|x#0@@97| Int) (|amount#0@@25| Int) ) (!  (=> (or (|_module.__default.RotateRight#canCall| |x#0@@97| |amount#0@@25|) (and (and (_module.__default.isUInt32 |x#0@@97|) (and (INTERNAL_le_boogie 0 |amount#0@@25|) (INTERNAL_lt_boogie |amount#0@@25| 32))) (and (INTERNAL_le_boogie 0 |amount#0@@25|) (INTERNAL_lt_boogie |amount#0@@25| 32)))) (and (and (and (|_module.__default.WordAsBits#canCall| |x#0@@97|) (|_module.__default.BitRotateRight#canCall| (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@97|) |amount#0@@25|)) (|_module.__default.BitsAsWord#canCall| (_module.__default.BitRotateRight StartFuel__module._default.BitRotateRight (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@97|) |amount#0@@25|))) (= (_module.__default.RotateRight |x#0@@97| |amount#0@@25|) (_module.__default.BitsAsWord StartFuel__module._default.BitsAsWord (_module.__default.BitRotateRight StartFuel__module._default.BitRotateRight (_module.__default.WordAsBits StartFuel__module._default.WordAsBits |x#0@@97|) |amount#0@@25|))))) :qid |bitvecto.30:22| :skolemid |949| :pattern ( (_module.__default.RotateRight |x#0@@97| |amount#0@@25|)) ))))
(assert  (=> true (forall ((|x#0@@98| Int) (|amount#0@@26| Int) ) (!  (=> (or (|_module.__default.RotateRight#canCall| (LitInt |x#0@@98|) (LitInt |amount#0@@26|)) (and (and (_module.__default.isUInt32 |x#0@@98|) (and (INTERNAL_le_boogie 0 |amount#0@@26|) (INTERNAL_lt_boogie |amount#0@@26| 32))) (and (INTERNAL_le_boogie 0 |amount#0@@26|) (INTERNAL_lt_boogie |amount#0@@26| 32)))) (and (and (and (|_module.__default.WordAsBits#canCall| (LitInt |x#0@@98|)) (|_module.__default.BitRotateRight#canCall| (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@98|)) (LitInt |amount#0@@26|))) (|_module.__default.BitsAsWord#canCall| (_module.__default.BitRotateRight StartFuel__module._default.BitRotateRight (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@98|)) (LitInt |amount#0@@26|)))) (= (_module.__default.RotateRight (LitInt |x#0@@98|) (LitInt |amount#0@@26|)) (_module.__default.BitsAsWord StartFuel__module._default.BitsAsWord (_module.__default.BitRotateRight StartFuel__module._default.BitRotateRight (_module.__default.WordAsBits StartFuel__module._default.WordAsBits (LitInt |x#0@@98|)) (LitInt |amount#0@@26|)))))) :qid |bitvecto.30:22| :weight 3 :skolemid |950| :pattern ( (_module.__default.RotateRight (LitInt |x#0@@98|) (LitInt |amount#0@@26|))) ))))
(assert (forall (($ly@@105 T@U) (|origval#0| Int) (|newval#0| Int) ) (!  (=> (= (type $ly@@105) LayerTypeType) (= (_module.__default.UpdateTopBits ($LS $ly@@105) |origval#0| |newval#0|) (_module.__default.UpdateTopBits $ly@@105 |origval#0| |newval#0|))) :qid |bitvecto.34:20| :skolemid |951| :pattern ( (_module.__default.UpdateTopBits ($LS $ly@@105) |origval#0| |newval#0|)) )))
(assert (forall (($ly@@106 T@U) (|origval#0@@0| Int) (|newval#0@@0| Int) ) (!  (=> (= (type $ly@@106) LayerTypeType) (= (_module.__default.UpdateTopBits $ly@@106 |origval#0@@0| |newval#0@@0|) (_module.__default.UpdateTopBits $LZ |origval#0@@0| |newval#0@@0|))) :qid |bitvecto.34:20| :skolemid |952| :pattern ( (_module.__default.UpdateTopBits (AsFuelBottom $ly@@106) |origval#0@@0| |newval#0@@0|)) )))
(assert  (=> true (forall (($ly@@107 T@U) (|origval#0@@1| Int) (|newval#0@@1| Int) ) (!  (=> (and (= (type $ly@@107) LayerTypeType) (or (|_module.__default.UpdateTopBits#canCall| |origval#0@@1| |newval#0@@1|) (and (_module.__default.isUInt32 |origval#0@@1|) (_module.__default.isUInt32 |newval#0@@1|)))) (_module.__default.isUInt32 (_module.__default.UpdateTopBits $ly@@107 |origval#0@@1| |newval#0@@1|))) :qid |bitvecto.34:20| :skolemid |953| :pattern ( (_module.__default.UpdateTopBits $ly@@107 |origval#0@@1| |newval#0@@1|)) ))))
(assert (forall (($ly@@108 T@U) (|origval#0@@2| Int) (|newval#0@@2| Int) ) (!  (=> (= (type $ly@@108) LayerTypeType) (=> (and (_module.__default.isUInt32 |origval#0@@2|) (_module.__default.isUInt32 |newval#0@@2|)) (and (=> (|_module.__default.UpdateTopBits#requires| $ly@@108 |origval#0@@2| |newval#0@@2|) true) (=> true (|_module.__default.UpdateTopBits#requires| $ly@@108 |origval#0@@2| |newval#0@@2|))))) :qid |bitvecto.34:20| :skolemid |954| :pattern ( (|_module.__default.UpdateTopBits#requires| $ly@@108 |origval#0@@2| |newval#0@@2|)) )))
(assert (= (type StartFuel__module._default.BitwiseMaskLow) LayerTypeType))
(assert  (=> true (forall (($ly@@109 T@U) (|origval#0@@3| Int) (|newval#0@@3| Int) ) (!  (=> (and (= (type $ly@@109) LayerTypeType) (or (|_module.__default.UpdateTopBits#canCall| |origval#0@@3| |newval#0@@3|) (and (_module.__default.isUInt32 |origval#0@@3|) (_module.__default.isUInt32 |newval#0@@3|)))) (and (and (and (|_module.__default.LeftShift#canCall| |newval#0@@3| (LitInt 16)) (|_module.__default.BitwiseMaskLow#canCall| |origval#0@@3| (LitInt 16))) (|_module.__default.BitwiseOr#canCall| (_module.__default.LeftShift |newval#0@@3| (LitInt 16)) (_module.__default.BitwiseMaskLow StartFuel__module._default.BitwiseMaskLow |origval#0@@3| (LitInt 16)))) (= (_module.__default.UpdateTopBits ($LS $ly@@109) |origval#0@@3| |newval#0@@3|) (_module.__default.BitwiseOr (_module.__default.LeftShift |newval#0@@3| (LitInt 16)) (_module.__default.BitwiseMaskLow StartFuel__module._default.BitwiseMaskLow |origval#0@@3| (LitInt 16)))))) :qid |bitvecto.34:20| :skolemid |955| :pattern ( (_module.__default.UpdateTopBits ($LS $ly@@109) |origval#0@@3| |newval#0@@3|)) ))))
(assert  (=> true (forall (($ly@@110 T@U) (|origval#0@@4| Int) (|newval#0@@4| Int) ) (!  (=> (and (= (type $ly@@110) LayerTypeType) (or (|_module.__default.UpdateTopBits#canCall| (LitInt |origval#0@@4|) (LitInt |newval#0@@4|)) (and (_module.__default.isUInt32 |origval#0@@4|) (_module.__default.isUInt32 |newval#0@@4|)))) (and (and (and (|_module.__default.LeftShift#canCall| (LitInt |newval#0@@4|) (LitInt 16)) (|_module.__default.BitwiseMaskLow#canCall| (LitInt |origval#0@@4|) (LitInt 16))) (|_module.__default.BitwiseOr#canCall| (LitInt (_module.__default.LeftShift (LitInt |newval#0@@4|) (LitInt 16))) (_module.__default.BitwiseMaskLow StartFuel__module._default.BitwiseMaskLow (LitInt |origval#0@@4|) (LitInt 16)))) (= (_module.__default.UpdateTopBits ($LS $ly@@110) (LitInt |origval#0@@4|) (LitInt |newval#0@@4|)) (_module.__default.BitwiseOr (LitInt (_module.__default.LeftShift (LitInt |newval#0@@4|) (LitInt 16))) (_module.__default.BitwiseMaskLow StartFuel__module._default.BitwiseMaskLow (LitInt |origval#0@@4|) (LitInt 16)))))) :qid |bitvecto.34:20| :weight 3 :skolemid |956| :pattern ( (_module.__default.UpdateTopBits ($LS $ly@@110) (LitInt |origval#0@@4|) (LitInt |newval#0@@4|))) ))))
(assert  (=> true (forall ((|i#0@@17| Int) ) (!  (=> true true) :qid |typessdf.7:20| :skolemid |957| :pattern ( (_module.__default.isUInt32 |i#0@@17|)) ))))
(assert (forall ((|i#0@@18| Int) ) (!  (and (=> (|_module.__default.isUInt32#requires| |i#0@@18|) true) (=> true (|_module.__default.isUInt32#requires| |i#0@@18|))) :qid |typessdf.7:20| :skolemid |958| :pattern ( (|_module.__default.isUInt32#requires| |i#0@@18|)) )))
(assert  (=> true (forall ((|i#0@@19| Int) ) (!  (=> true (and (=> (_module.__default.isUInt32 |i#0@@19|) (and (INTERNAL_le_boogie 0 |i#0@@19|) (INTERNAL_lt_boogie |i#0@@19| (LitInt 4294967296)))) (=> (and (INTERNAL_le_boogie 0 |i#0@@19|) (INTERNAL_lt_boogie |i#0@@19| (LitInt 4294967296))) (_module.__default.isUInt32 |i#0@@19|)))) :qid |typessdf.7:20| :skolemid |959| :pattern ( (_module.__default.isUInt32 |i#0@@19|)) ))))
(assert  (=> true (forall ((|i#0@@20| Int) ) (!  (=> true (and (=> (_module.__default.isUInt32 (LitInt |i#0@@20|)) (and (INTERNAL_le_boogie 0 |i#0@@20|) (INTERNAL_lt_boogie |i#0@@20| (LitInt 4294967296)))) (=> (and (INTERNAL_le_boogie 0 |i#0@@20|) (INTERNAL_lt_boogie |i#0@@20| (LitInt 4294967296))) (_module.__default.isUInt32 (LitInt |i#0@@20|))))) :qid |typessdf.7:20| :weight 3 :skolemid |960| :pattern ( (_module.__default.isUInt32 (LitInt |i#0@@20|))) ))))
(assert (forall (($ly@@111 T@U) (|i#0@@21| Int) ) (!  (=> (= (type $ly@@111) LayerTypeType) (and (=> (_module.__default.WordAligned ($LS $ly@@111) |i#0@@21|) (_module.__default.WordAligned $ly@@111 |i#0@@21|)) (=> (_module.__default.WordAligned $ly@@111 |i#0@@21|) (_module.__default.WordAligned ($LS $ly@@111) |i#0@@21|)))) :qid |typessdf.10:21| :skolemid |961| :pattern ( (_module.__default.WordAligned ($LS $ly@@111) |i#0@@21|)) )))
(assert (forall (($ly@@112 T@U) (|i#0@@22| Int) ) (!  (=> (= (type $ly@@112) LayerTypeType) (and (=> (_module.__default.WordAligned $ly@@112 |i#0@@22|) (_module.__default.WordAligned $LZ |i#0@@22|)) (=> (_module.__default.WordAligned $LZ |i#0@@22|) (_module.__default.WordAligned $ly@@112 |i#0@@22|)))) :qid |typessdf.10:21| :skolemid |962| :pattern ( (_module.__default.WordAligned (AsFuelBottom $ly@@112) |i#0@@22|)) )))
(assert  (=> true (forall (($ly@@113 T@U) (|i#0@@23| Int) ) (!  (=> (and (= (type $ly@@113) LayerTypeType) true) true) :qid |typessdf.10:21| :skolemid |963| :pattern ( (_module.__default.WordAligned $ly@@113 |i#0@@23|)) ))))
(assert (forall (($ly@@114 T@U) (|i#0@@24| Int) ) (!  (=> (= (type $ly@@114) LayerTypeType) (and (=> (|_module.__default.WordAligned#requires| $ly@@114 |i#0@@24|) true) (=> true (|_module.__default.WordAligned#requires| $ly@@114 |i#0@@24|)))) :qid |typessdf.10:21| :skolemid |964| :pattern ( (|_module.__default.WordAligned#requires| $ly@@114 |i#0@@24|)) )))
(assert  (=> true (forall (($ly@@115 T@U) (|i#0@@25| Int) ) (!  (=> (and (= (type $ly@@115) LayerTypeType) true) (and (=> (_module.__default.WordAligned ($LS $ly@@115) |i#0@@25|) (= (INTERNAL_mod_boogie |i#0@@25| (LitInt 4)) (LitInt 0))) (=> (= (INTERNAL_mod_boogie |i#0@@25| (LitInt 4)) (LitInt 0)) (_module.__default.WordAligned ($LS $ly@@115) |i#0@@25|)))) :qid |typessdf.10:21| :skolemid |965| :pattern ( (_module.__default.WordAligned ($LS $ly@@115) |i#0@@25|)) ))))
(assert  (=> true (forall (($ly@@116 T@U) (|i#0@@26| Int) ) (!  (=> (and (= (type $ly@@116) LayerTypeType) true) (and (=> (_module.__default.WordAligned ($LS $ly@@116) (LitInt |i#0@@26|)) (= (INTERNAL_mod_boogie |i#0@@26| (LitInt 4)) (LitInt 0))) (=> (= (INTERNAL_mod_boogie |i#0@@26| (LitInt 4)) (LitInt 0)) (_module.__default.WordAligned ($LS $ly@@116) (LitInt |i#0@@26|))))) :qid |typessdf.10:21| :weight 3 :skolemid |966| :pattern ( (_module.__default.WordAligned ($LS $ly@@116) (LitInt |i#0@@26|))) ))))
(assert (= (type StartFuel__module._default.WordAligned) LayerTypeType))
(assert  (=> true (forall ((|w#0| Int) ) (!  (=> true (_module.__default.WordAligned StartFuel__module._default.WordAligned (_module.__default.WordsToBytes |w#0|))) :qid |typessdf.14:30| :skolemid |967| :pattern ( (_module.__default.WordsToBytes |w#0|)) ))))
(assert (forall ((|w#0@@0| Int) ) (!  (and (=> (|_module.__default.WordsToBytes#requires| |w#0@@0|) true) (=> true (|_module.__default.WordsToBytes#requires| |w#0@@0|))) :qid |typessdf.14:30| :skolemid |968| :pattern ( (|_module.__default.WordsToBytes#requires| |w#0@@0|)) )))
(assert  (and (= (type MoreFuel__module._default.WordAligned0) LayerTypeType) (= (type StartFuelAssert__module._default.WordAligned) LayerTypeType)))
(assert  (=> true (forall ((|w#0@@1| Int) ) (!  (=> true (and (and (and (= StartFuel__module._default.WordAligned ($LS MoreFuel__module._default.WordAligned0)) (= StartFuelAssert__module._default.WordAligned ($LS ($LS MoreFuel__module._default.WordAligned0)))) (= (AsFuelBottom MoreFuel__module._default.WordAligned0) MoreFuel__module._default.WordAligned0)) (= (_module.__default.WordsToBytes |w#0@@1|) (INTERNAL_mul_boogie (LitInt 4) |w#0@@1|)))) :qid |typessdf.14:30| :skolemid |969| :pattern ( (_module.__default.WordsToBytes |w#0@@1|)) ))))
(assert (= (type MoreFuel__module._default.WordAligned1) LayerTypeType))
(assert  (=> true (forall ((|w#0@@2| Int) ) (!  (=> true (and (and (and (= StartFuel__module._default.WordAligned ($LS MoreFuel__module._default.WordAligned1)) (= StartFuelAssert__module._default.WordAligned ($LS ($LS MoreFuel__module._default.WordAligned1)))) (= (AsFuelBottom MoreFuel__module._default.WordAligned1) MoreFuel__module._default.WordAligned1)) (= (_module.__default.WordsToBytes (LitInt |w#0@@2|)) (INTERNAL_mul_boogie (LitInt 4) |w#0@@2|)))) :qid |typessdf.14:30| :weight 3 :skolemid |970| :pattern ( (_module.__default.WordsToBytes (LitInt |w#0@@2|))) ))))
(assert  (=> true (forall ((|b#0@@5| Int) ) (!  (=> (or (|_module.__default.BytesToWords#canCall| |b#0@@5|) (_module.__default.WordAligned StartFuel__module._default.WordAligned |b#0@@5|)) true) :qid |typessdf.18:30| :skolemid |971| :pattern ( (_module.__default.BytesToWords |b#0@@5|)) ))))
(assert (forall ((|b#0@@6| Int) ) (!  (and (=> (|_module.__default.BytesToWords#requires| |b#0@@6|) (_module.__default.WordAligned StartFuel__module._default.WordAligned |b#0@@6|)) (=> (_module.__default.WordAligned StartFuel__module._default.WordAligned |b#0@@6|) (|_module.__default.BytesToWords#requires| |b#0@@6|))) :qid |typessdf.18:30| :skolemid |972| :pattern ( (|_module.__default.BytesToWords#requires| |b#0@@6|)) )))
(assert (= (type MoreFuel__module._default.WordAligned2) LayerTypeType))
(assert  (=> true (forall ((|b#0@@7| Int) ) (!  (=> (or (|_module.__default.BytesToWords#canCall| |b#0@@7|) (_module.__default.WordAligned StartFuel__module._default.WordAligned |b#0@@7|)) (and (and (and (= StartFuel__module._default.WordAligned ($LS MoreFuel__module._default.WordAligned2)) (= StartFuelAssert__module._default.WordAligned ($LS ($LS MoreFuel__module._default.WordAligned2)))) (= (AsFuelBottom MoreFuel__module._default.WordAligned2) MoreFuel__module._default.WordAligned2)) (= (_module.__default.BytesToWords |b#0@@7|) (INTERNAL_div_boogie |b#0@@7| (LitInt 4))))) :qid |typessdf.18:30| :skolemid |973| :pattern ( (_module.__default.BytesToWords |b#0@@7|)) ))))
(assert (= (type MoreFuel__module._default.WordAligned3) LayerTypeType))
(assert  (=> true (forall ((|b#0@@8| Int) ) (!  (=> (or (|_module.__default.BytesToWords#canCall| (LitInt |b#0@@8|)) (_module.__default.WordAligned StartFuel__module._default.WordAligned (LitInt |b#0@@8|))) (and (and (and (= StartFuel__module._default.WordAligned ($LS MoreFuel__module._default.WordAligned3)) (= StartFuelAssert__module._default.WordAligned ($LS ($LS MoreFuel__module._default.WordAligned3)))) (= (AsFuelBottom MoreFuel__module._default.WordAligned3) MoreFuel__module._default.WordAligned3)) (= (_module.__default.BytesToWords (LitInt |b#0@@8|)) (INTERNAL_div_boogie |b#0@@8| (LitInt 4))))) :qid |typessdf.18:30| :weight 3 :skolemid |974| :pattern ( (_module.__default.BytesToWords (LitInt |b#0@@8|))) ))))
(assert (forall (($ly@@117 T@U) (|x#0@@99| Int) ) (!  (=> (= (type $ly@@117) LayerTypeType) (= (_module.__default.TruncateWord ($LS $ly@@117) |x#0@@99|) (_module.__default.TruncateWord $ly@@117 |x#0@@99|))) :qid |typessdf.22:20| :skolemid |975| :pattern ( (_module.__default.TruncateWord ($LS $ly@@117) |x#0@@99|)) )))
(assert (forall (($ly@@118 T@U) (|x#0@@100| Int) ) (!  (=> (= (type $ly@@118) LayerTypeType) (= (_module.__default.TruncateWord $ly@@118 |x#0@@100|) (_module.__default.TruncateWord $LZ |x#0@@100|))) :qid |typessdf.22:20| :skolemid |976| :pattern ( (_module.__default.TruncateWord (AsFuelBottom $ly@@118) |x#0@@100|)) )))
(assert  (=> true (forall (($ly@@119 T@U) (|x#0@@101| Int) ) (!  (=> (and (= (type $ly@@119) LayerTypeType) true) (_module.__default.isUInt32 (_module.__default.TruncateWord $ly@@119 |x#0@@101|))) :qid |typessdf.22:20| :skolemid |977| :pattern ( (_module.__default.TruncateWord $ly@@119 |x#0@@101|)) ))))
(assert (forall (($ly@@120 T@U) (|x#0@@102| Int) ) (!  (=> (= (type $ly@@120) LayerTypeType) (and (=> (|_module.__default.TruncateWord#requires| $ly@@120 |x#0@@102|) true) (=> true (|_module.__default.TruncateWord#requires| $ly@@120 |x#0@@102|)))) :qid |typessdf.22:20| :skolemid |978| :pattern ( (|_module.__default.TruncateWord#requires| $ly@@120 |x#0@@102|)) )))
(assert  (=> true (forall (($ly@@121 T@U) (|x#0@@103| Int) ) (!  (=> (and (= (type $ly@@121) LayerTypeType) true) (= (_module.__default.TruncateWord ($LS $ly@@121) |x#0@@103|) (INTERNAL_mod_boogie |x#0@@103| (LitInt 4294967296)))) :qid |typessdf.22:20| :skolemid |979| :pattern ( (_module.__default.TruncateWord ($LS $ly@@121) |x#0@@103|)) ))))
(assert  (=> true (forall (($ly@@122 T@U) (|x#0@@104| Int) ) (!  (=> (and (= (type $ly@@122) LayerTypeType) true) (= (_module.__default.TruncateWord ($LS $ly@@122) (LitInt |x#0@@104|)) (INTERNAL_mod_boogie |x#0@@104| (LitInt 4294967296)))) :qid |typessdf.22:20| :weight 3 :skolemid |980| :pattern ( (_module.__default.TruncateWord ($LS $ly@@122) (LitInt |x#0@@104|))) ))))
(assert  (=> true (forall ((|b#0@@9| Int) (|i#0@@27| Int) ) (!  (=> (or (|_module.__default.WordOffset_k#canCall| |b#0@@9| |i#0@@27|) (_module.__default.isUInt32 |b#0@@9|)) (=> (_module.__default.WordAligned StartFuel__module._default.WordAligned |b#0@@9|) (_module.__default.WordAligned StartFuel__module._default.WordAligned (_module.__default.WordOffset_k |b#0@@9| |i#0@@27|)))) :qid |typessdf.26:29| :skolemid |981| :pattern ( (_module.__default.WordOffset_k |b#0@@9| |i#0@@27|)) ))))
(assert (forall ((|b#0@@10| Int) (|i#0@@28| Int) ) (!  (=> (_module.__default.isUInt32 |b#0@@10|) (and (=> (|_module.__default.WordOffset_k#requires| |b#0@@10| |i#0@@28|) true) (=> true (|_module.__default.WordOffset_k#requires| |b#0@@10| |i#0@@28|)))) :qid |typessdf.26:29| :skolemid |982| :pattern ( (|_module.__default.WordOffset_k#requires| |b#0@@10| |i#0@@28|)) )))
(assert (= (type MoreFuel__module._default.WordAligned4) LayerTypeType))
(assert  (=> true (forall ((|b#0@@11| Int) (|i#0@@29| Int) ) (!  (=> (or (|_module.__default.WordOffset_k#canCall| |b#0@@11| |i#0@@29|) (_module.__default.isUInt32 |b#0@@11|)) (and (|_module.__default.WordsToBytes#canCall| |i#0@@29|) (and (and (and (= StartFuel__module._default.WordAligned ($LS MoreFuel__module._default.WordAligned4)) (= StartFuelAssert__module._default.WordAligned ($LS ($LS MoreFuel__module._default.WordAligned4)))) (= (AsFuelBottom MoreFuel__module._default.WordAligned4) MoreFuel__module._default.WordAligned4)) (= (_module.__default.WordOffset_k |b#0@@11| |i#0@@29|) (INTERNAL_add_boogie |b#0@@11| (_module.__default.WordsToBytes |i#0@@29|)))))) :qid |typessdf.26:29| :skolemid |983| :pattern ( (_module.__default.WordOffset_k |b#0@@11| |i#0@@29|)) ))))
(assert (= (type MoreFuel__module._default.WordAligned5) LayerTypeType))
(assert  (=> true (forall ((|b#0@@12| Int) (|i#0@@30| Int) ) (!  (=> (or (|_module.__default.WordOffset_k#canCall| (LitInt |b#0@@12|) (LitInt |i#0@@30|)) (_module.__default.isUInt32 |b#0@@12|)) (and (|_module.__default.WordsToBytes#canCall| (LitInt |i#0@@30|)) (and (and (and (= StartFuel__module._default.WordAligned ($LS MoreFuel__module._default.WordAligned5)) (= StartFuelAssert__module._default.WordAligned ($LS ($LS MoreFuel__module._default.WordAligned5)))) (= (AsFuelBottom MoreFuel__module._default.WordAligned5) MoreFuel__module._default.WordAligned5)) (= (_module.__default.WordOffset_k (LitInt |b#0@@12|) (LitInt |i#0@@30|)) (LitInt (INTERNAL_add_boogie |b#0@@12| (_module.__default.WordsToBytes (LitInt |i#0@@30|)))))))) :qid |typessdf.26:29| :weight 3 :skolemid |984| :pattern ( (_module.__default.WordOffset_k (LitInt |b#0@@12|) (LitInt |i#0@@30|))) ))))
(assert  (=> true (forall ((|a#0| Int) (|i#0@@31| Int) ) (!  (=> (or (|_module.__default.ValidWordOffset#canCall| |a#0| |i#0@@31|) (_module.__default.isUInt32 |a#0|)) true) :qid |typessdf.30:27| :skolemid |985| :pattern ( (_module.__default.ValidWordOffset |a#0| |i#0@@31|)) ))))
(assert (forall ((|a#0@@0| Int) (|i#0@@32| Int) ) (!  (=> (_module.__default.isUInt32 |a#0@@0|) (and (=> (|_module.__default.ValidWordOffset#requires| |a#0@@0| |i#0@@32|) true) (=> true (|_module.__default.ValidWordOffset#requires| |a#0@@0| |i#0@@32|)))) :qid |typessdf.30:27| :skolemid |986| :pattern ( (|_module.__default.ValidWordOffset#requires| |a#0@@0| |i#0@@32|)) )))
(assert  (=> true (forall ((|a#0@@1| Int) (|i#0@@33| Int) ) (!  (=> (or (|_module.__default.ValidWordOffset#canCall| |a#0@@1| |i#0@@33|) (_module.__default.isUInt32 |a#0@@1|)) (and (and (|_module.__default.WordAligned#canCall| |a#0@@1|) (=> (_module.__default.WordAligned StartFuel__module._default.WordAligned |a#0@@1|) (and (|_module.__default.WordsToBytes#canCall| |i#0@@33|) (|_module.__default.isUInt32#canCall| (INTERNAL_add_boogie |a#0@@1| (_module.__default.WordsToBytes |i#0@@33|)))))) (and (=> (_module.__default.ValidWordOffset |a#0@@1| |i#0@@33|) (and (_module.__default.WordAligned StartFuel__module._default.WordAligned |a#0@@1|) (_module.__default.isUInt32 (INTERNAL_add_boogie |a#0@@1| (_module.__default.WordsToBytes |i#0@@33|))))) (=> (and (_module.__default.WordAligned StartFuel__module._default.WordAligned |a#0@@1|) (_module.__default.isUInt32 (INTERNAL_add_boogie |a#0@@1| (_module.__default.WordsToBytes |i#0@@33|)))) (_module.__default.ValidWordOffset |a#0@@1| |i#0@@33|))))) :qid |typessdf.30:27| :skolemid |987| :pattern ( (_module.__default.ValidWordOffset |a#0@@1| |i#0@@33|)) ))))
(assert  (=> true (forall ((|a#0@@2| Int) (|i#0@@34| Int) ) (!  (=> (or (|_module.__default.ValidWordOffset#canCall| (LitInt |a#0@@2|) (LitInt |i#0@@34|)) (_module.__default.isUInt32 |a#0@@2|)) (and (and (|_module.__default.WordAligned#canCall| (LitInt |a#0@@2|)) (=> (_module.__default.WordAligned StartFuel__module._default.WordAligned (LitInt |a#0@@2|)) (and (|_module.__default.WordsToBytes#canCall| (LitInt |i#0@@34|)) (|_module.__default.isUInt32#canCall| (LitInt (INTERNAL_add_boogie |a#0@@2| (_module.__default.WordsToBytes (LitInt |i#0@@34|)))))))) (and (=> (_module.__default.ValidWordOffset (LitInt |a#0@@2|) (LitInt |i#0@@34|)) (and (_module.__default.WordAligned StartFuel__module._default.WordAligned (LitInt |a#0@@2|)) (_module.__default.isUInt32 (LitInt (INTERNAL_add_boogie |a#0@@2| (_module.__default.WordsToBytes (LitInt |i#0@@34|))))))) (=> (and (_module.__default.WordAligned StartFuel__module._default.WordAligned (LitInt |a#0@@2|)) (_module.__default.isUInt32 (LitInt (INTERNAL_add_boogie |a#0@@2| (_module.__default.WordsToBytes (LitInt |i#0@@34|)))))) (_module.__default.ValidWordOffset (LitInt |a#0@@2|) (LitInt |i#0@@34|)))))) :qid |typessdf.30:27| :weight 3 :skolemid |988| :pattern ( (_module.__default.ValidWordOffset (LitInt |a#0@@2|) (LitInt |i#0@@34|))) ))))
(assert  (=> true (forall ((|a#0@@3| Int) (|i#0@@35| Int) ) (!  (=> (or (|_module.__default.WordOffset#canCall| |a#0@@3| |i#0@@35|) (and (and (_module.__default.isUInt32 |a#0@@3|) (_module.__default.WordAligned StartFuel__module._default.WordAligned |a#0@@3|)) (_module.__default.isUInt32 (INTERNAL_add_boogie |a#0@@3| (_module.__default.WordsToBytes |i#0@@35|))))) (and (_module.__default.isUInt32 (_module.__default.WordOffset |a#0@@3| |i#0@@35|)) (_module.__default.WordAligned StartFuel__module._default.WordAligned (_module.__default.WordOffset |a#0@@3| |i#0@@35|)))) :qid |typessdf.33:28| :skolemid |989| :pattern ( (_module.__default.WordOffset |a#0@@3| |i#0@@35|)) ))))
(assert (forall ((|a#0@@4| Int) (|i#0@@36| Int) ) (!  (=> (and (_module.__default.isUInt32 |a#0@@4|) (_module.__default.WordAligned StartFuel__module._default.WordAligned |a#0@@4|)) (and (=> (|_module.__default.WordOffset#requires| |a#0@@4| |i#0@@36|) (_module.__default.isUInt32 (INTERNAL_add_boogie |a#0@@4| (_module.__default.WordsToBytes |i#0@@36|)))) (=> (_module.__default.isUInt32 (INTERNAL_add_boogie |a#0@@4| (_module.__default.WordsToBytes |i#0@@36|))) (|_module.__default.WordOffset#requires| |a#0@@4| |i#0@@36|)))) :qid |typessdf.33:28| :skolemid |990| :pattern ( (|_module.__default.WordOffset#requires| |a#0@@4| |i#0@@36|)) )))
(assert  (=> true (forall ((|a#0@@5| Int) (|i#0@@37| Int) ) (!  (=> (or (|_module.__default.WordOffset#canCall| |a#0@@5| |i#0@@37|) (and (and (_module.__default.isUInt32 |a#0@@5|) (_module.__default.WordAligned StartFuel__module._default.WordAligned |a#0@@5|)) (_module.__default.isUInt32 (INTERNAL_add_boogie |a#0@@5| (_module.__default.WordsToBytes |i#0@@37|))))) (and (|_module.__default.WordOffset_k#canCall| |a#0@@5| |i#0@@37|) (= (_module.__default.WordOffset |a#0@@5| |i#0@@37|) (_module.__default.WordOffset_k |a#0@@5| |i#0@@37|)))) :qid |typessdf.33:28| :skolemid |991| :pattern ( (_module.__default.WordOffset |a#0@@5| |i#0@@37|)) ))))
(assert  (=> true (forall ((|a#0@@6| Int) (|i#0@@38| Int) ) (!  (=> (or (|_module.__default.WordOffset#canCall| (LitInt |a#0@@6|) (LitInt |i#0@@38|)) (and (and (_module.__default.isUInt32 |a#0@@6|) (_module.__default.WordAligned StartFuel__module._default.WordAligned |a#0@@6|)) (U_2_bool (Lit (bool_2_U (_module.__default.isUInt32 (LitInt (INTERNAL_add_boogie |a#0@@6| (_module.__default.WordsToBytes (LitInt |i#0@@38|)))))))))) (and (|_module.__default.WordOffset_k#canCall| (LitInt |a#0@@6|) (LitInt |i#0@@38|)) (= (_module.__default.WordOffset (LitInt |a#0@@6|) (LitInt |i#0@@38|)) (LitInt (_module.__default.WordOffset_k (LitInt |a#0@@6|) (LitInt |i#0@@38|)))))) :qid |typessdf.33:28| :weight 3 :skolemid |992| :pattern ( (_module.__default.WordOffset (LitInt |a#0@@6|) (LitInt |i#0@@38|))) ))))
(assert (forall (($ly@@123 T@U) (|addr#0| Int) ) (!  (=> (= (type $ly@@123) LayerTypeType) (and (=> (_module.__default.PageAligned ($LS $ly@@123) |addr#0|) (_module.__default.PageAligned $ly@@123 |addr#0|)) (=> (_module.__default.PageAligned $ly@@123 |addr#0|) (_module.__default.PageAligned ($LS $ly@@123) |addr#0|)))) :qid |typessdf.40:21| :skolemid |993| :pattern ( (_module.__default.PageAligned ($LS $ly@@123) |addr#0|)) )))
(assert (forall (($ly@@124 T@U) (|addr#0@@0| Int) ) (!  (=> (= (type $ly@@124) LayerTypeType) (and (=> (_module.__default.PageAligned $ly@@124 |addr#0@@0|) (_module.__default.PageAligned $LZ |addr#0@@0|)) (=> (_module.__default.PageAligned $LZ |addr#0@@0|) (_module.__default.PageAligned $ly@@124 |addr#0@@0|)))) :qid |typessdf.40:21| :skolemid |994| :pattern ( (_module.__default.PageAligned (AsFuelBottom $ly@@124) |addr#0@@0|)) )))
(assert  (=> true (forall (($ly@@125 T@U) (|addr#0@@1| Int) ) (!  (=> (and (and (= (type $ly@@125) LayerTypeType) (or (|_module.__default.PageAligned#canCall| |addr#0@@1|) (INTERNAL_ge_boogie |addr#0@@1| 0))) (_module.__default.PageAligned $ly@@125 |addr#0@@1|)) (_module.__default.WordAligned StartFuel__module._default.WordAligned |addr#0@@1|)) :qid |typessdf.40:21| :skolemid |995| :pattern ( (_module.__default.PageAligned $ly@@125 |addr#0@@1|)) ))))
(assert (forall (($ly@@126 T@U) (|addr#0@@2| Int) ) (!  (=> (= (type $ly@@126) LayerTypeType) (and (=> (|_module.__default.PageAligned#requires| $ly@@126 |addr#0@@2|) (INTERNAL_ge_boogie |addr#0@@2| 0)) (=> (INTERNAL_ge_boogie |addr#0@@2| 0) (|_module.__default.PageAligned#requires| $ly@@126 |addr#0@@2|)))) :qid |typessdf.40:21| :skolemid |996| :pattern ( (|_module.__default.PageAligned#requires| $ly@@126 |addr#0@@2|)) )))
(assert  (=> true (forall (($ly@@127 T@U) (|addr#0@@3| Int) ) (!  (=> (and (= (type $ly@@127) LayerTypeType) (or (|_module.__default.PageAligned#canCall| |addr#0@@3|) (INTERNAL_ge_boogie |addr#0@@3| 0))) (and (=> (_module.__default.PageAligned ($LS $ly@@127) |addr#0@@3|) (ite (= (INTERNAL_mod_boogie |addr#0@@3| (LitInt 4096)) (LitInt 0)) true false)) (=> (ite (= (INTERNAL_mod_boogie |addr#0@@3| (LitInt 4096)) (LitInt 0)) true false) (_module.__default.PageAligned ($LS $ly@@127) |addr#0@@3|)))) :qid |typessdf.40:21| :skolemid |997| :pattern ( (_module.__default.PageAligned ($LS $ly@@127) |addr#0@@3|)) ))))
(assert  (=> true (forall (($ly@@128 T@U) (|addr#0@@4| Int) ) (!  (=> (and (= (type $ly@@128) LayerTypeType) (or (|_module.__default.PageAligned#canCall| (LitInt |addr#0@@4|)) (INTERNAL_ge_boogie |addr#0@@4| 0))) (and (=> (_module.__default.PageAligned ($LS $ly@@128) (LitInt |addr#0@@4|)) (ite (= (INTERNAL_mod_boogie |addr#0@@4| (LitInt 4096)) (LitInt 0)) true false)) (=> (ite (= (INTERNAL_mod_boogie |addr#0@@4| (LitInt 4096)) (LitInt 0)) true false) (_module.__default.PageAligned ($LS $ly@@128) (LitInt |addr#0@@4|))))) :qid |typessdf.40:21| :weight 3 :skolemid |998| :pattern ( (_module.__default.PageAligned ($LS $ly@@128) (LitInt |addr#0@@4|))) ))))
(assert  (=> true (forall ((|x1#0| Int) (|x2#0| Int) ) (!  (=> (or (|_module.__default.WordAlignedAdd#canCall| |x1#0| |x2#0|) (and (_module.__default.WordAligned StartFuel__module._default.WordAligned |x1#0|) (_module.__default.WordAligned StartFuel__module._default.WordAligned |x2#0|))) (_module.__default.WordAligned StartFuel__module._default.WordAligned (_module.__default.WordAlignedAdd |x1#0| |x2#0|))) :qid |typessdf.82:25| :skolemid |999| :pattern ( (_module.__default.WordAlignedAdd |x1#0| |x2#0|)) ))))
(assert (forall ((|x1#0@@0| Int) (|x2#0@@0| Int) ) (!  (and (=> (|_module.__default.WordAlignedAdd#requires| |x1#0@@0| |x2#0@@0|) (and (_module.__default.WordAligned StartFuel__module._default.WordAligned |x1#0@@0|) (_module.__default.WordAligned StartFuel__module._default.WordAligned |x2#0@@0|))) (=> (and (_module.__default.WordAligned StartFuel__module._default.WordAligned |x1#0@@0|) (_module.__default.WordAligned StartFuel__module._default.WordAligned |x2#0@@0|)) (|_module.__default.WordAlignedAdd#requires| |x1#0@@0| |x2#0@@0|))) :qid |typessdf.82:25| :skolemid |1000| :pattern ( (|_module.__default.WordAlignedAdd#requires| |x1#0@@0| |x2#0@@0|)) )))
(assert (= (type MoreFuel__module._default.WordAligned6) LayerTypeType))
(assert  (=> true (forall ((|x1#0@@1| Int) (|x2#0@@1| Int) ) (!  (=> (or (|_module.__default.WordAlignedAdd#canCall| |x1#0@@1| |x2#0@@1|) (and (_module.__default.WordAligned StartFuel__module._default.WordAligned |x1#0@@1|) (_module.__default.WordAligned StartFuel__module._default.WordAligned |x2#0@@1|))) (and (and (and (= StartFuel__module._default.WordAligned ($LS MoreFuel__module._default.WordAligned6)) (= StartFuelAssert__module._default.WordAligned ($LS ($LS MoreFuel__module._default.WordAligned6)))) (= (AsFuelBottom MoreFuel__module._default.WordAligned6) MoreFuel__module._default.WordAligned6)) (= (_module.__default.WordAlignedAdd |x1#0@@1| |x2#0@@1|) (INTERNAL_add_boogie |x1#0@@1| |x2#0@@1|)))) :qid |typessdf.82:25| :skolemid |1001| :pattern ( (_module.__default.WordAlignedAdd |x1#0@@1| |x2#0@@1|)) ))))
(assert (= (type MoreFuel__module._default.WordAligned7) LayerTypeType))
(assert  (=> true (forall ((|x1#0@@2| Int) (|x2#0@@2| Int) ) (!  (=> (or (|_module.__default.WordAlignedAdd#canCall| (LitInt |x1#0@@2|) (LitInt |x2#0@@2|)) (and (_module.__default.WordAligned StartFuel__module._default.WordAligned (LitInt |x1#0@@2|)) (_module.__default.WordAligned StartFuel__module._default.WordAligned (LitInt |x2#0@@2|)))) (and (and (and (= StartFuel__module._default.WordAligned ($LS MoreFuel__module._default.WordAligned7)) (= StartFuelAssert__module._default.WordAligned ($LS ($LS MoreFuel__module._default.WordAligned7)))) (= (AsFuelBottom MoreFuel__module._default.WordAligned7) MoreFuel__module._default.WordAligned7)) (= (_module.__default.WordAlignedAdd (LitInt |x1#0@@2|) (LitInt |x2#0@@2|)) (LitInt (INTERNAL_add_boogie |x1#0@@2| |x2#0@@2|))))) :qid |typessdf.82:25| :weight 3 :skolemid |1002| :pattern ( (_module.__default.WordAlignedAdd (LitInt |x1#0@@2|) (LitInt |x2#0@@2|))) ))))
(assert  (=> true (forall ((|x1#0@@3| Int) (|x2#0@@3| Int) ) (!  (=> (or (|_module.__default.WordAlignedSub#canCall| |x1#0@@3| |x2#0@@3|) (and (_module.__default.WordAligned StartFuel__module._default.WordAligned |x1#0@@3|) (_module.__default.WordAligned StartFuel__module._default.WordAligned |x2#0@@3|))) (_module.__default.WordAligned StartFuel__module._default.WordAligned (_module.__default.WordAlignedSub |x1#0@@3| |x2#0@@3|))) :qid |typessdf.90:25| :skolemid |1003| :pattern ( (_module.__default.WordAlignedSub |x1#0@@3| |x2#0@@3|)) ))))
(assert (forall ((|x1#0@@4| Int) (|x2#0@@4| Int) ) (!  (and (=> (|_module.__default.WordAlignedSub#requires| |x1#0@@4| |x2#0@@4|) (and (_module.__default.WordAligned StartFuel__module._default.WordAligned |x1#0@@4|) (_module.__default.WordAligned StartFuel__module._default.WordAligned |x2#0@@4|))) (=> (and (_module.__default.WordAligned StartFuel__module._default.WordAligned |x1#0@@4|) (_module.__default.WordAligned StartFuel__module._default.WordAligned |x2#0@@4|)) (|_module.__default.WordAlignedSub#requires| |x1#0@@4| |x2#0@@4|))) :qid |typessdf.90:25| :skolemid |1004| :pattern ( (|_module.__default.WordAlignedSub#requires| |x1#0@@4| |x2#0@@4|)) )))
(assert (= (type MoreFuel__module._default.WordAligned8) LayerTypeType))
(assert  (=> true (forall ((|x1#0@@5| Int) (|x2#0@@5| Int) ) (!  (=> (or (|_module.__default.WordAlignedSub#canCall| |x1#0@@5| |x2#0@@5|) (and (_module.__default.WordAligned StartFuel__module._default.WordAligned |x1#0@@5|) (_module.__default.WordAligned StartFuel__module._default.WordAligned |x2#0@@5|))) (and (and (and (= StartFuel__module._default.WordAligned ($LS MoreFuel__module._default.WordAligned8)) (= StartFuelAssert__module._default.WordAligned ($LS ($LS MoreFuel__module._default.WordAligned8)))) (= (AsFuelBottom MoreFuel__module._default.WordAligned8) MoreFuel__module._default.WordAligned8)) (= (_module.__default.WordAlignedSub |x1#0@@5| |x2#0@@5|) (INTERNAL_sub_boogie |x1#0@@5| |x2#0@@5|)))) :qid |typessdf.90:25| :skolemid |1005| :pattern ( (_module.__default.WordAlignedSub |x1#0@@5| |x2#0@@5|)) ))))
(assert (= (type MoreFuel__module._default.WordAligned9) LayerTypeType))
(assert  (=> true (forall ((|x1#0@@6| Int) (|x2#0@@6| Int) ) (!  (=> (or (|_module.__default.WordAlignedSub#canCall| (LitInt |x1#0@@6|) (LitInt |x2#0@@6|)) (and (_module.__default.WordAligned StartFuel__module._default.WordAligned (LitInt |x1#0@@6|)) (_module.__default.WordAligned StartFuel__module._default.WordAligned (LitInt |x2#0@@6|)))) (and (and (and (= StartFuel__module._default.WordAligned ($LS MoreFuel__module._default.WordAligned9)) (= StartFuelAssert__module._default.WordAligned ($LS ($LS MoreFuel__module._default.WordAligned9)))) (= (AsFuelBottom MoreFuel__module._default.WordAligned9) MoreFuel__module._default.WordAligned9)) (= (_module.__default.WordAlignedSub (LitInt |x1#0@@6|) (LitInt |x2#0@@6|)) (LitInt (INTERNAL_sub_boogie |x1#0@@6| |x2#0@@6|))))) :qid |typessdf.90:25| :weight 3 :skolemid |1006| :pattern ( (_module.__default.WordAlignedSub (LitInt |x1#0@@6|) (LitInt |x2#0@@6|))) ))))
(assert (= (type Tclass._module.shift__amount) TyType))
(assert (= (Tag Tclass._module.shift__amount) Tagclass._module.shift__amount))
(assert (forall ((bx@@52 T@U) ) (!  (=> (and (= (type bx@@52) BoxType) ($IsBox bx@@52 Tclass._module.shift__amount)) (and (= ($Box ($Unbox intType bx@@52)) bx@@52) ($Is ($Unbox intType bx@@52) Tclass._module.shift__amount))) :qid |unknown.0:0| :skolemid |1007| :pattern ( ($IsBox bx@@52 Tclass._module.shift__amount)) )))
(assert (forall ((|s#0| T@U) ) (!  (=> (= (type |s#0|) intType) (and (=> ($Is |s#0| Tclass._module.shift__amount) (and (INTERNAL_le_boogie 0 (U_2_int |s#0|)) (INTERNAL_lt_boogie (U_2_int |s#0|) 32))) (=> (and (INTERNAL_le_boogie 0 (U_2_int |s#0|)) (INTERNAL_lt_boogie (U_2_int |s#0|) 32)) ($Is |s#0| Tclass._module.shift__amount)))) :qid |unknown.0:0| :skolemid |1008| :pattern ( ($Is |s#0| Tclass._module.shift__amount)) )))
(assert (forall ((|s#0@@0| T@U) ($h@@6 T@U) ) (!  (=> (and (= (type |s#0@@0|) intType) (= (type $h@@6) (MapType1Type refType))) ($IsAlloc |s#0@@0| Tclass._module.shift__amount $h@@6)) :qid |unknown.0:0| :skolemid |1009| :pattern ( ($IsAlloc |s#0@@0| Tclass._module.shift__amount $h@@6)) )))
(assert (forall ((|x#0@@105| T@U) ) (!  (=> (= (type |x#0@@105|) intType) (and (=> ($Is |x#0@@105| Tclass._module.word) (_module.__default.isUInt32 (U_2_int |x#0@@105|))) (=> (_module.__default.isUInt32 (U_2_int |x#0@@105|)) ($Is |x#0@@105| Tclass._module.word)))) :qid |unknown.0:0| :skolemid |1010| :pattern ( ($Is |x#0@@105| Tclass._module.word)) )))
(assert (forall ((|x#0@@106| T@U) ($h@@7 T@U) ) (!  (=> (and (= (type |x#0@@106|) intType) (= (type $h@@7) (MapType1Type refType))) ($IsAlloc |x#0@@106| Tclass._module.word $h@@7)) :qid |unknown.0:0| :skolemid |1011| :pattern ( ($IsAlloc |x#0@@106| Tclass._module.word $h@@7)) )))
(assert (= (type Tclass._module.addr) TyType))
(assert (= (Tag Tclass._module.addr) Tagclass._module.addr))
(assert (forall ((bx@@53 T@U) ) (!  (=> (and (= (type bx@@53) BoxType) ($IsBox bx@@53 Tclass._module.addr)) (and (= ($Box ($Unbox intType bx@@53)) bx@@53) ($Is ($Unbox intType bx@@53) Tclass._module.addr))) :qid |unknown.0:0| :skolemid |1012| :pattern ( ($IsBox bx@@53 Tclass._module.addr)) )))
(assert (forall ((|x#0@@107| T@U) ) (!  (=> (= (type |x#0@@107|) intType) (and (=> ($Is |x#0@@107| Tclass._module.addr) (and (_module.__default.isUInt32 (U_2_int |x#0@@107|)) (_module.__default.WordAligned StartFuel__module._default.WordAligned (U_2_int |x#0@@107|)))) (=> (and (_module.__default.isUInt32 (U_2_int |x#0@@107|)) (_module.__default.WordAligned StartFuel__module._default.WordAligned (U_2_int |x#0@@107|))) ($Is |x#0@@107| Tclass._module.addr)))) :qid |unknown.0:0| :skolemid |1013| :pattern ( ($Is |x#0@@107| Tclass._module.addr)) )))
(assert (forall ((|x#0@@108| T@U) ($h@@8 T@U) ) (!  (=> (and (= (type |x#0@@108|) intType) (= (type $h@@8) (MapType1Type refType))) ($IsAlloc |x#0@@108| Tclass._module.addr $h@@8)) :qid |unknown.0:0| :skolemid |1014| :pattern ( ($IsAlloc |x#0@@108| Tclass._module.addr $h@@8)) )))
(assert  (and (and (and (and (and (and (and (forall ((arg0@@137 T@T) (arg1@@67 T@T) ) (! (= (Ctor (MapType4Type arg0@@137 arg1@@67)) 23) :qid |ctor:MapType4Type| )) (forall ((arg0@@138 T@T) (arg1@@68 T@T) ) (! (= (MapType4TypeInv0 (MapType4Type arg0@@138 arg1@@68)) arg0@@138) :qid |typeInv:MapType4TypeInv0| :pattern ( (MapType4Type arg0@@138 arg1@@68)) ))) (forall ((arg0@@139 T@T) (arg1@@69 T@T) ) (! (= (MapType4TypeInv1 (MapType4Type arg0@@139 arg1@@69)) arg1@@69) :qid |typeInv:MapType4TypeInv1| :pattern ( (MapType4Type arg0@@139 arg1@@69)) ))) (forall ((arg0@@140 T@U) (arg1@@70 T@U) (arg2@@30 T@U) ) (! (let ((aVar1@@4 (MapType4TypeInv1 (type arg0@@140)))) (= (type (MapType4Select arg0@@140 arg1@@70 arg2@@30)) aVar1@@4)) :qid |funType:MapType4Select| :pattern ( (MapType4Select arg0@@140 arg1@@70 arg2@@30)) ))) (forall ((arg0@@141 T@U) (arg1@@71 T@U) (arg2@@31 T@U) (arg3@@12 T@U) ) (! (let ((aVar1@@5 (type arg3@@12))) (let ((aVar0@@3 (type arg1@@71))) (= (type (MapType4Store arg0@@141 arg1@@71 arg2@@31 arg3@@12)) (MapType4Type aVar0@@3 aVar1@@5)))) :qid |funType:MapType4Store| :pattern ( (MapType4Store arg0@@141 arg1@@71 arg2@@31 arg3@@12)) ))) (forall ((m@@36 T@U) (x0@@15 T@U) (x1@@12 T@U) (val@@16 T@U) ) (! (let ((aVar1@@6 (MapType4TypeInv1 (type m@@36)))) (=> (= (type val@@16) aVar1@@6) (= (MapType4Select (MapType4Store m@@36 x0@@15 x1@@12 val@@16) x0@@15 x1@@12) val@@16))) :qid |mapAx0:MapType4Select| :weight 0 ))) (and (and (forall ((val@@17 T@U) (m@@37 T@U) (x0@@16 T@U) (x1@@13 T@U) (y0@@11 T@U) (y1@@9 T@U) ) (!  (or (= x0@@16 y0@@11) (= (MapType4Select (MapType4Store m@@37 x0@@16 x1@@13 val@@17) y0@@11 y1@@9) (MapType4Select m@@37 y0@@11 y1@@9))) :qid |mapAx1:MapType4Select:0| :weight 0 )) (forall ((val@@18 T@U) (m@@38 T@U) (x0@@17 T@U) (x1@@14 T@U) (y0@@12 T@U) (y1@@10 T@U) ) (!  (or (= x1@@14 y1@@10) (= (MapType4Select (MapType4Store m@@38 x0@@17 x1@@14 val@@18) y0@@12 y1@@10) (MapType4Select m@@38 y0@@12 y1@@10))) :qid |mapAx1:MapType4Select:1| :weight 0 ))) (forall ((val@@19 T@U) (m@@39 T@U) (x0@@18 T@U) (x1@@15 T@U) (y0@@13 T@U) (y1@@11 T@U) ) (!  (or true (= (MapType4Select (MapType4Store m@@39 x0@@18 x1@@15 val@@19) y0@@13 y1@@11) (MapType4Select m@@39 y0@@13 y1@@11))) :qid |mapAx2:MapType4Select| :weight 0 )))) (forall ((arg0@@142 T@U) (arg1@@72 T@U) (arg2@@32 T@U) ) (! (= (type (|lambda#0| arg0@@142 arg1@@72 arg2@@32)) (MapType4Type refType boolType)) :qid |funType:lambda#0| :pattern ( (|lambda#0| arg0@@142 arg1@@72 arg2@@32)) ))))
(assert (forall (($o@@7 T@U) ($f T@U) (alloc@@0 T@U) (null@@0 T@U) ($Heap T@U) ) (! (let ((alpha@@6 (FieldTypeInv0 (type $f)))) (=> (and (and (and (and (= (type $o@@7) refType) (= (type $f) (FieldType alpha@@6))) (= (type alloc@@0) (FieldType boolType))) (= (type null@@0) refType)) (= (type $Heap) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#0| alloc@@0 null@@0 $Heap) $o@@7 $f))  (=> (and (not (= $o@@7 null@@0)) (U_2_bool (MapType1Select $Heap $o@@7 alloc@@0))) false)))) :qid |bitvecto.5:7| :skolemid |1015| :pattern ( (MapType4Select (|lambda#0| alloc@@0 null@@0 $Heap) $o@@7 $f)) )))
(assert (forall ((arg0@@143 T@U) (arg1@@73 T@U) (arg2@@33 T@U) ) (! (= (type (|lambda#1| arg0@@143 arg1@@73 arg2@@33)) (MapType4Type refType boolType)) :qid |funType:lambda#1| :pattern ( (|lambda#1| arg0@@143 arg1@@73 arg2@@33)) )))
(assert (forall (($o@@8 T@U) ($f@@0 T@U) (alloc@@1 T@U) (null@@1 T@U) ($Heap@@0 T@U) ) (! (let ((alpha@@7 (FieldTypeInv0 (type $f@@0)))) (=> (and (and (and (and (= (type $o@@8) refType) (= (type $f@@0) (FieldType alpha@@7))) (= (type alloc@@1) (FieldType boolType))) (= (type null@@1) refType)) (= (type $Heap@@0) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#1| alloc@@1 null@@1 $Heap@@0) $o@@8 $f@@0))  (=> (and (not (= $o@@8 null@@1)) (U_2_bool (MapType1Select $Heap@@0 $o@@8 alloc@@1))) false)))) :qid |bitvecto.5:7| :skolemid |1016| :pattern ( (MapType4Select (|lambda#1| alloc@@1 null@@1 $Heap@@0) $o@@8 $f@@0)) )))
(assert (forall ((arg0@@144 T@U) (arg1@@74 T@U) (arg2@@34 T@U) ) (! (= (type (|lambda#2| arg0@@144 arg1@@74 arg2@@34)) (MapType4Type refType boolType)) :qid |funType:lambda#2| :pattern ( (|lambda#2| arg0@@144 arg1@@74 arg2@@34)) )))
(assert (forall (($o@@9 T@U) ($f@@1 T@U) (alloc@@2 T@U) (null@@2 T@U) ($Heap@@1 T@U) ) (! (let ((alpha@@8 (FieldTypeInv0 (type $f@@1)))) (=> (and (and (and (and (= (type $o@@9) refType) (= (type $f@@1) (FieldType alpha@@8))) (= (type alloc@@2) (FieldType boolType))) (= (type null@@2) refType)) (= (type $Heap@@1) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#2| alloc@@2 null@@2 $Heap@@1) $o@@9 $f@@1))  (=> (and (not (= $o@@9 null@@2)) (U_2_bool (MapType1Select $Heap@@1 $o@@9 alloc@@2))) false)))) :qid |bitvecto.13:7| :skolemid |1017| :pattern ( (MapType4Select (|lambda#2| alloc@@2 null@@2 $Heap@@1) $o@@9 $f@@1)) )))
(assert (forall ((arg0@@145 T@U) (arg1@@75 T@U) (arg2@@35 T@U) ) (! (= (type (|lambda#3| arg0@@145 arg1@@75 arg2@@35)) (MapType4Type refType boolType)) :qid |funType:lambda#3| :pattern ( (|lambda#3| arg0@@145 arg1@@75 arg2@@35)) )))
(assert (forall (($o@@10 T@U) ($f@@2 T@U) (alloc@@3 T@U) (null@@3 T@U) ($Heap@@2 T@U) ) (! (let ((alpha@@9 (FieldTypeInv0 (type $f@@2)))) (=> (and (and (and (and (= (type $o@@10) refType) (= (type $f@@2) (FieldType alpha@@9))) (= (type alloc@@3) (FieldType boolType))) (= (type null@@3) refType)) (= (type $Heap@@2) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#3| alloc@@3 null@@3 $Heap@@2) $o@@10 $f@@2))  (=> (and (not (= $o@@10 null@@3)) (U_2_bool (MapType1Select $Heap@@2 $o@@10 alloc@@3))) false)))) :qid |bitvecto.13:7| :skolemid |1018| :pattern ( (MapType4Select (|lambda#3| alloc@@3 null@@3 $Heap@@2) $o@@10 $f@@2)) )))
(assert (forall ((arg0@@146 T@U) (arg1@@76 T@U) (arg2@@36 T@U) ) (! (= (type (|lambda#4| arg0@@146 arg1@@76 arg2@@36)) (MapType4Type refType boolType)) :qid |funType:lambda#4| :pattern ( (|lambda#4| arg0@@146 arg1@@76 arg2@@36)) )))
(assert (forall (($o@@11 T@U) ($f@@3 T@U) (alloc@@4 T@U) (null@@4 T@U) ($Heap@@3 T@U) ) (! (let ((alpha@@10 (FieldTypeInv0 (type $f@@3)))) (=> (and (and (and (and (= (type $o@@11) refType) (= (type $f@@3) (FieldType alpha@@10))) (= (type alloc@@4) (FieldType boolType))) (= (type null@@4) refType)) (= (type $Heap@@3) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#4| alloc@@4 null@@4 $Heap@@3) $o@@11 $f@@3))  (=> (and (not (= $o@@11 null@@4)) (U_2_bool (MapType1Select $Heap@@3 $o@@11 alloc@@4))) false)))) :qid |bitvecto.21:7| :skolemid |1019| :pattern ( (MapType4Select (|lambda#4| alloc@@4 null@@4 $Heap@@3) $o@@11 $f@@3)) )))
(assert (forall ((arg0@@147 T@U) (arg1@@77 T@U) (arg2@@37 T@U) ) (! (= (type (|lambda#5| arg0@@147 arg1@@77 arg2@@37)) (MapType4Type refType boolType)) :qid |funType:lambda#5| :pattern ( (|lambda#5| arg0@@147 arg1@@77 arg2@@37)) )))
(assert (forall (($o@@12 T@U) ($f@@4 T@U) (alloc@@5 T@U) (null@@5 T@U) ($Heap@@4 T@U) ) (! (let ((alpha@@11 (FieldTypeInv0 (type $f@@4)))) (=> (and (and (and (and (= (type $o@@12) refType) (= (type $f@@4) (FieldType alpha@@11))) (= (type alloc@@5) (FieldType boolType))) (= (type null@@5) refType)) (= (type $Heap@@4) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#5| alloc@@5 null@@5 $Heap@@4) $o@@12 $f@@4))  (=> (and (not (= $o@@12 null@@5)) (U_2_bool (MapType1Select $Heap@@4 $o@@12 alloc@@5))) false)))) :qid |bitvecto.25:7| :skolemid |1020| :pattern ( (MapType4Select (|lambda#5| alloc@@5 null@@5 $Heap@@4) $o@@12 $f@@4)) )))
(assert (forall ((arg0@@148 T@U) (arg1@@78 T@U) (arg2@@38 T@U) ) (! (= (type (|lambda#6| arg0@@148 arg1@@78 arg2@@38)) (MapType4Type refType boolType)) :qid |funType:lambda#6| :pattern ( (|lambda#6| arg0@@148 arg1@@78 arg2@@38)) )))
(assert (forall (($o@@13 T@U) ($f@@5 T@U) (alloc@@6 T@U) (null@@6 T@U) ($Heap@@5 T@U) ) (! (let ((alpha@@12 (FieldTypeInv0 (type $f@@5)))) (=> (and (and (and (and (= (type $o@@13) refType) (= (type $f@@5) (FieldType alpha@@12))) (= (type alloc@@6) (FieldType boolType))) (= (type null@@6) refType)) (= (type $Heap@@5) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#6| alloc@@6 null@@6 $Heap@@5) $o@@13 $f@@5))  (=> (and (not (= $o@@13 null@@6)) (U_2_bool (MapType1Select $Heap@@5 $o@@13 alloc@@6))) false)))) :qid |bitvecto.29:7| :skolemid |1021| :pattern ( (MapType4Select (|lambda#6| alloc@@6 null@@6 $Heap@@5) $o@@13 $f@@5)) )))
(assert (forall ((arg0@@149 T@U) (arg1@@79 T@U) (arg2@@39 T@U) ) (! (= (type (|lambda#7| arg0@@149 arg1@@79 arg2@@39)) (MapType4Type refType boolType)) :qid |funType:lambda#7| :pattern ( (|lambda#7| arg0@@149 arg1@@79 arg2@@39)) )))
(assert (forall (($o@@14 T@U) ($f@@6 T@U) (alloc@@7 T@U) (null@@7 T@U) ($Heap@@6 T@U) ) (! (let ((alpha@@13 (FieldTypeInv0 (type $f@@6)))) (=> (and (and (and (and (= (type $o@@14) refType) (= (type $f@@6) (FieldType alpha@@13))) (= (type alloc@@7) (FieldType boolType))) (= (type null@@7) refType)) (= (type $Heap@@6) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#7| alloc@@7 null@@7 $Heap@@6) $o@@14 $f@@6))  (=> (and (not (= $o@@14 null@@7)) (U_2_bool (MapType1Select $Heap@@6 $o@@14 alloc@@7))) false)))) :qid |bitvecto.33:7| :skolemid |1022| :pattern ( (MapType4Select (|lambda#7| alloc@@7 null@@7 $Heap@@6) $o@@14 $f@@6)) )))
(assert (forall ((arg0@@150 T@U) (arg1@@80 T@U) (arg2@@40 T@U) ) (! (= (type (|lambda#8| arg0@@150 arg1@@80 arg2@@40)) (MapType4Type refType boolType)) :qid |funType:lambda#8| :pattern ( (|lambda#8| arg0@@150 arg1@@80 arg2@@40)) )))
(assert (forall (($o@@15 T@U) ($f@@7 T@U) (alloc@@8 T@U) (null@@8 T@U) ($Heap@@7 T@U) ) (! (let ((alpha@@14 (FieldTypeInv0 (type $f@@7)))) (=> (and (and (and (and (= (type $o@@15) refType) (= (type $f@@7) (FieldType alpha@@14))) (= (type alloc@@8) (FieldType boolType))) (= (type null@@8) refType)) (= (type $Heap@@7) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#8| alloc@@8 null@@8 $Heap@@7) $o@@15 $f@@7))  (=> (and (not (= $o@@15 null@@8)) (U_2_bool (MapType1Select $Heap@@7 $o@@15 alloc@@8))) false)))) :qid |bitvecto.37:7| :skolemid |1023| :pattern ( (MapType4Select (|lambda#8| alloc@@8 null@@8 $Heap@@7) $o@@15 $f@@7)) )))
(assert (forall ((arg0@@151 T@U) (arg1@@81 T@U) (arg2@@41 T@U) ) (! (= (type (|lambda#9| arg0@@151 arg1@@81 arg2@@41)) (MapType4Type refType boolType)) :qid |funType:lambda#9| :pattern ( (|lambda#9| arg0@@151 arg1@@81 arg2@@41)) )))
(assert (forall (($o@@16 T@U) ($f@@8 T@U) (alloc@@9 T@U) (null@@9 T@U) ($Heap@@8 T@U) ) (! (let ((alpha@@15 (FieldTypeInv0 (type $f@@8)))) (=> (and (and (and (and (= (type $o@@16) refType) (= (type $f@@8) (FieldType alpha@@15))) (= (type alloc@@9) (FieldType boolType))) (= (type null@@9) refType)) (= (type $Heap@@8) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#9| alloc@@9 null@@9 $Heap@@8) $o@@16 $f@@8))  (=> (and (not (= $o@@16 null@@9)) (U_2_bool (MapType1Select $Heap@@8 $o@@16 alloc@@9))) false)))) :qid |bitvecto.41:7| :skolemid |1024| :pattern ( (MapType4Select (|lambda#9| alloc@@9 null@@9 $Heap@@8) $o@@16 $f@@8)) )))
(assert (forall ((arg0@@152 T@U) (arg1@@82 T@U) (arg2@@42 T@U) ) (! (= (type (|lambda#10| arg0@@152 arg1@@82 arg2@@42)) (MapType4Type refType boolType)) :qid |funType:lambda#10| :pattern ( (|lambda#10| arg0@@152 arg1@@82 arg2@@42)) )))
(assert (forall (($o@@17 T@U) ($f@@9 T@U) (alloc@@10 T@U) (null@@10 T@U) ($Heap@@9 T@U) ) (! (let ((alpha@@16 (FieldTypeInv0 (type $f@@9)))) (=> (and (and (and (and (= (type $o@@17) refType) (= (type $f@@9) (FieldType alpha@@16))) (= (type alloc@@10) (FieldType boolType))) (= (type null@@10) refType)) (= (type $Heap@@9) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#10| alloc@@10 null@@10 $Heap@@9) $o@@17 $f@@9))  (=> (and (not (= $o@@17 null@@10)) (U_2_bool (MapType1Select $Heap@@9 $o@@17 alloc@@10))) false)))) :qid |bitvecto.41:7| :skolemid |1025| :pattern ( (MapType4Select (|lambda#10| alloc@@10 null@@10 $Heap@@9) $o@@17 $f@@9)) )))
(assert (forall ((arg0@@153 T@U) (arg1@@83 T@U) (arg2@@43 T@U) ) (! (= (type (|lambda#11| arg0@@153 arg1@@83 arg2@@43)) (MapType4Type refType boolType)) :qid |funType:lambda#11| :pattern ( (|lambda#11| arg0@@153 arg1@@83 arg2@@43)) )))
(assert (forall (($o@@18 T@U) ($f@@10 T@U) (alloc@@11 T@U) (null@@11 T@U) ($Heap@@10 T@U) ) (! (let ((alpha@@17 (FieldTypeInv0 (type $f@@10)))) (=> (and (and (and (and (= (type $o@@18) refType) (= (type $f@@10) (FieldType alpha@@17))) (= (type alloc@@11) (FieldType boolType))) (= (type null@@11) refType)) (= (type $Heap@@10) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#11| alloc@@11 null@@11 $Heap@@10) $o@@18 $f@@10))  (=> (and (not (= $o@@18 null@@11)) (U_2_bool (MapType1Select $Heap@@10 $o@@18 alloc@@11))) false)))) :qid |bitvecto.47:7| :skolemid |1026| :pattern ( (MapType4Select (|lambda#11| alloc@@11 null@@11 $Heap@@10) $o@@18 $f@@10)) )))
(assert (forall ((arg0@@154 T@U) (arg1@@84 T@U) (arg2@@44 T@U) ) (! (= (type (|lambda#12| arg0@@154 arg1@@84 arg2@@44)) (MapType4Type refType boolType)) :qid |funType:lambda#12| :pattern ( (|lambda#12| arg0@@154 arg1@@84 arg2@@44)) )))
(assert (forall (($o@@19 T@U) ($f@@11 T@U) (alloc@@12 T@U) (null@@12 T@U) ($Heap@@11 T@U) ) (! (let ((alpha@@18 (FieldTypeInv0 (type $f@@11)))) (=> (and (and (and (and (= (type $o@@19) refType) (= (type $f@@11) (FieldType alpha@@18))) (= (type alloc@@12) (FieldType boolType))) (= (type null@@12) refType)) (= (type $Heap@@11) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#12| alloc@@12 null@@12 $Heap@@11) $o@@19 $f@@11))  (=> (and (not (= $o@@19 null@@12)) (U_2_bool (MapType1Select $Heap@@11 $o@@19 alloc@@12))) false)))) :qid |bitvecto.47:7| :skolemid |1027| :pattern ( (MapType4Select (|lambda#12| alloc@@12 null@@12 $Heap@@11) $o@@19 $f@@11)) )))
(assert (forall ((arg0@@155 T@U) (arg1@@85 T@U) (arg2@@45 T@U) ) (! (= (type (|lambda#13| arg0@@155 arg1@@85 arg2@@45)) (MapType4Type refType boolType)) :qid |funType:lambda#13| :pattern ( (|lambda#13| arg0@@155 arg1@@85 arg2@@45)) )))
(assert (forall (($o@@20 T@U) ($f@@12 T@U) (alloc@@13 T@U) (null@@13 T@U) ($Heap@@12 T@U) ) (! (let ((alpha@@19 (FieldTypeInv0 (type $f@@12)))) (=> (and (and (and (and (= (type $o@@20) refType) (= (type $f@@12) (FieldType alpha@@19))) (= (type alloc@@13) (FieldType boolType))) (= (type null@@13) refType)) (= (type $Heap@@12) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#13| alloc@@13 null@@13 $Heap@@12) $o@@20 $f@@12))  (=> (and (not (= $o@@20 null@@13)) (U_2_bool (MapType1Select $Heap@@12 $o@@20 alloc@@13))) false)))) :qid |bitvecto.61:7| :skolemid |1028| :pattern ( (MapType4Select (|lambda#13| alloc@@13 null@@13 $Heap@@12) $o@@20 $f@@12)) )))
(assert (forall ((arg0@@156 T@U) (arg1@@86 T@U) (arg2@@46 T@U) ) (! (= (type (|lambda#14| arg0@@156 arg1@@86 arg2@@46)) (MapType4Type refType boolType)) :qid |funType:lambda#14| :pattern ( (|lambda#14| arg0@@156 arg1@@86 arg2@@46)) )))
(assert (forall (($o@@21 T@U) ($f@@13 T@U) (alloc@@14 T@U) (null@@14 T@U) ($Heap@@13 T@U) ) (! (let ((alpha@@20 (FieldTypeInv0 (type $f@@13)))) (=> (and (and (and (and (= (type $o@@21) refType) (= (type $f@@13) (FieldType alpha@@20))) (= (type alloc@@14) (FieldType boolType))) (= (type null@@14) refType)) (= (type $Heap@@13) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#14| alloc@@14 null@@14 $Heap@@13) $o@@21 $f@@13))  (=> (and (not (= $o@@21 null@@14)) (U_2_bool (MapType1Select $Heap@@13 $o@@21 alloc@@14))) false)))) :qid |bitvecto.61:7| :skolemid |1029| :pattern ( (MapType4Select (|lambda#14| alloc@@14 null@@14 $Heap@@13) $o@@21 $f@@13)) )))
(assert (forall ((arg0@@157 T@U) (arg1@@87 T@U) (arg2@@47 T@U) ) (! (= (type (|lambda#15| arg0@@157 arg1@@87 arg2@@47)) (MapType4Type refType boolType)) :qid |funType:lambda#15| :pattern ( (|lambda#15| arg0@@157 arg1@@87 arg2@@47)) )))
(assert (forall (($o@@22 T@U) ($f@@14 T@U) (alloc@@15 T@U) (null@@15 T@U) ($Heap@@14 T@U) ) (! (let ((alpha@@21 (FieldTypeInv0 (type $f@@14)))) (=> (and (and (and (and (= (type $o@@22) refType) (= (type $f@@14) (FieldType alpha@@21))) (= (type alloc@@15) (FieldType boolType))) (= (type null@@15) refType)) (= (type $Heap@@14) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#15| alloc@@15 null@@15 $Heap@@14) $o@@22 $f@@14))  (=> (and (not (= $o@@22 null@@15)) (U_2_bool (MapType1Select $Heap@@14 $o@@22 alloc@@15))) false)))) :qid |bitvecto.74:7| :skolemid |1030| :pattern ( (MapType4Select (|lambda#15| alloc@@15 null@@15 $Heap@@14) $o@@22 $f@@14)) )))
(assert (forall ((arg0@@158 T@U) (arg1@@88 T@U) (arg2@@48 T@U) ) (! (= (type (|lambda#16| arg0@@158 arg1@@88 arg2@@48)) (MapType4Type refType boolType)) :qid |funType:lambda#16| :pattern ( (|lambda#16| arg0@@158 arg1@@88 arg2@@48)) )))
(assert (forall (($o@@23 T@U) ($f@@15 T@U) (alloc@@16 T@U) (null@@16 T@U) ($Heap@@15 T@U) ) (! (let ((alpha@@22 (FieldTypeInv0 (type $f@@15)))) (=> (and (and (and (and (= (type $o@@23) refType) (= (type $f@@15) (FieldType alpha@@22))) (= (type alloc@@16) (FieldType boolType))) (= (type null@@16) refType)) (= (type $Heap@@15) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#16| alloc@@16 null@@16 $Heap@@15) $o@@23 $f@@15))  (=> (and (not (= $o@@23 null@@16)) (U_2_bool (MapType1Select $Heap@@15 $o@@23 alloc@@16))) false)))) :qid |bitvecto.74:7| :skolemid |1031| :pattern ( (MapType4Select (|lambda#16| alloc@@16 null@@16 $Heap@@15) $o@@23 $f@@15)) )))
(assert (forall ((arg0@@159 T@U) (arg1@@89 T@U) (arg2@@49 T@U) ) (! (= (type (|lambda#17| arg0@@159 arg1@@89 arg2@@49)) (MapType4Type refType boolType)) :qid |funType:lambda#17| :pattern ( (|lambda#17| arg0@@159 arg1@@89 arg2@@49)) )))
(assert (forall (($o@@24 T@U) ($f@@16 T@U) (alloc@@17 T@U) (null@@17 T@U) ($Heap@@16 T@U) ) (! (let ((alpha@@23 (FieldTypeInv0 (type $f@@16)))) (=> (and (and (and (and (= (type $o@@24) refType) (= (type $f@@16) (FieldType alpha@@23))) (= (type alloc@@17) (FieldType boolType))) (= (type null@@17) refType)) (= (type $Heap@@16) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#17| alloc@@17 null@@17 $Heap@@16) $o@@24 $f@@16))  (=> (and (not (= $o@@24 null@@17)) (U_2_bool (MapType1Select $Heap@@16 $o@@24 alloc@@17))) false)))) :qid |bitvecto.92:7| :skolemid |1032| :pattern ( (MapType4Select (|lambda#17| alloc@@17 null@@17 $Heap@@16) $o@@24 $f@@16)) )))
(assert (forall ((arg0@@160 T@U) (arg1@@90 T@U) (arg2@@50 T@U) ) (! (= (type (|lambda#18| arg0@@160 arg1@@90 arg2@@50)) (MapType4Type refType boolType)) :qid |funType:lambda#18| :pattern ( (|lambda#18| arg0@@160 arg1@@90 arg2@@50)) )))
(assert (forall (($o@@25 T@U) ($f@@17 T@U) (alloc@@18 T@U) (null@@18 T@U) ($Heap@@17 T@U) ) (! (let ((alpha@@24 (FieldTypeInv0 (type $f@@17)))) (=> (and (and (and (and (= (type $o@@25) refType) (= (type $f@@17) (FieldType alpha@@24))) (= (type alloc@@18) (FieldType boolType))) (= (type null@@18) refType)) (= (type $Heap@@17) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#18| alloc@@18 null@@18 $Heap@@17) $o@@25 $f@@17))  (=> (and (not (= $o@@25 null@@18)) (U_2_bool (MapType1Select $Heap@@17 $o@@25 alloc@@18))) false)))) :qid |bitvecto.92:7| :skolemid |1033| :pattern ( (MapType4Select (|lambda#18| alloc@@18 null@@18 $Heap@@17) $o@@25 $f@@17)) )))
(assert (forall ((arg0@@161 T@U) (arg1@@91 T@U) (arg2@@51 T@U) ) (! (= (type (|lambda#19| arg0@@161 arg1@@91 arg2@@51)) (MapType4Type refType boolType)) :qid |funType:lambda#19| :pattern ( (|lambda#19| arg0@@161 arg1@@91 arg2@@51)) )))
(assert (forall (($o@@26 T@U) ($f@@18 T@U) (alloc@@19 T@U) (null@@19 T@U) ($Heap@@18 T@U) ) (! (let ((alpha@@25 (FieldTypeInv0 (type $f@@18)))) (=> (and (and (and (and (= (type $o@@26) refType) (= (type $f@@18) (FieldType alpha@@25))) (= (type alloc@@19) (FieldType boolType))) (= (type null@@19) refType)) (= (type $Heap@@18) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#19| alloc@@19 null@@19 $Heap@@18) $o@@26 $f@@18))  (=> (and (not (= $o@@26 null@@19)) (U_2_bool (MapType1Select $Heap@@18 $o@@26 alloc@@19))) false)))) :qid |bitvecto.107:7| :skolemid |1034| :pattern ( (MapType4Select (|lambda#19| alloc@@19 null@@19 $Heap@@18) $o@@26 $f@@18)) )))
(assert (forall ((arg0@@162 T@U) (arg1@@92 T@U) (arg2@@52 T@U) ) (! (= (type (|lambda#20| arg0@@162 arg1@@92 arg2@@52)) (MapType4Type refType boolType)) :qid |funType:lambda#20| :pattern ( (|lambda#20| arg0@@162 arg1@@92 arg2@@52)) )))
(assert (forall (($o@@27 T@U) ($f@@19 T@U) (alloc@@20 T@U) (null@@20 T@U) ($Heap@@19 T@U) ) (! (let ((alpha@@26 (FieldTypeInv0 (type $f@@19)))) (=> (and (and (and (and (= (type $o@@27) refType) (= (type $f@@19) (FieldType alpha@@26))) (= (type alloc@@20) (FieldType boolType))) (= (type null@@20) refType)) (= (type $Heap@@19) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#20| alloc@@20 null@@20 $Heap@@19) $o@@27 $f@@19))  (=> (and (not (= $o@@27 null@@20)) (U_2_bool (MapType1Select $Heap@@19 $o@@27 alloc@@20))) false)))) :qid |bitvecto.107:7| :skolemid |1035| :pattern ( (MapType4Select (|lambda#20| alloc@@20 null@@20 $Heap@@19) $o@@27 $f@@19)) )))
(assert (forall ((arg0@@163 T@U) (arg1@@93 T@U) (arg2@@53 T@U) ) (! (= (type (|lambda#21| arg0@@163 arg1@@93 arg2@@53)) (MapType4Type refType boolType)) :qid |funType:lambda#21| :pattern ( (|lambda#21| arg0@@163 arg1@@93 arg2@@53)) )))
(assert (forall (($o@@28 T@U) ($f@@20 T@U) (alloc@@21 T@U) (null@@21 T@U) ($Heap@@20 T@U) ) (! (let ((alpha@@27 (FieldTypeInv0 (type $f@@20)))) (=> (and (and (and (and (= (type $o@@28) refType) (= (type $f@@20) (FieldType alpha@@27))) (= (type alloc@@21) (FieldType boolType))) (= (type null@@21) refType)) (= (type $Heap@@20) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#21| alloc@@21 null@@21 $Heap@@20) $o@@28 $f@@20))  (=> (and (not (= $o@@28 null@@21)) (U_2_bool (MapType1Select $Heap@@20 $o@@28 alloc@@21))) false)))) :qid |bitvecto.135:7| :skolemid |1036| :pattern ( (MapType4Select (|lambda#21| alloc@@21 null@@21 $Heap@@20) $o@@28 $f@@20)) )))
(assert (forall ((arg0@@164 T@U) (arg1@@94 T@U) (arg2@@54 T@U) ) (! (= (type (|lambda#22| arg0@@164 arg1@@94 arg2@@54)) (MapType4Type refType boolType)) :qid |funType:lambda#22| :pattern ( (|lambda#22| arg0@@164 arg1@@94 arg2@@54)) )))
(assert (forall (($o@@29 T@U) ($f@@21 T@U) (alloc@@22 T@U) (null@@22 T@U) ($Heap@@21 T@U) ) (! (let ((alpha@@28 (FieldTypeInv0 (type $f@@21)))) (=> (and (and (and (and (= (type $o@@29) refType) (= (type $f@@21) (FieldType alpha@@28))) (= (type alloc@@22) (FieldType boolType))) (= (type null@@22) refType)) (= (type $Heap@@21) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#22| alloc@@22 null@@22 $Heap@@21) $o@@29 $f@@21))  (=> (and (not (= $o@@29 null@@22)) (U_2_bool (MapType1Select $Heap@@21 $o@@29 alloc@@22))) false)))) :qid |bitvecto.135:7| :skolemid |1037| :pattern ( (MapType4Select (|lambda#22| alloc@@22 null@@22 $Heap@@21) $o@@29 $f@@21)) )))
(assert (forall ((arg0@@165 T@U) (arg1@@95 T@U) (arg2@@55 T@U) ) (! (= (type (|lambda#23| arg0@@165 arg1@@95 arg2@@55)) (MapType4Type refType boolType)) :qid |funType:lambda#23| :pattern ( (|lambda#23| arg0@@165 arg1@@95 arg2@@55)) )))
(assert (forall (($o@@30 T@U) ($f@@22 T@U) (alloc@@23 T@U) (null@@23 T@U) ($Heap@@22 T@U) ) (! (let ((alpha@@29 (FieldTypeInv0 (type $f@@22)))) (=> (and (and (and (and (= (type $o@@30) refType) (= (type $f@@22) (FieldType alpha@@29))) (= (type alloc@@23) (FieldType boolType))) (= (type null@@23) refType)) (= (type $Heap@@22) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#23| alloc@@23 null@@23 $Heap@@22) $o@@30 $f@@22))  (=> (and (not (= $o@@30 null@@23)) (U_2_bool (MapType1Select $Heap@@22 $o@@30 alloc@@23))) false)))) :qid |bitvecto.145:7| :skolemid |1038| :pattern ( (MapType4Select (|lambda#23| alloc@@23 null@@23 $Heap@@22) $o@@30 $f@@22)) )))
(assert (forall ((arg0@@166 T@U) (arg1@@96 T@U) (arg2@@56 T@U) ) (! (= (type (|lambda#24| arg0@@166 arg1@@96 arg2@@56)) (MapType4Type refType boolType)) :qid |funType:lambda#24| :pattern ( (|lambda#24| arg0@@166 arg1@@96 arg2@@56)) )))
(assert (forall (($o@@31 T@U) ($f@@23 T@U) (alloc@@24 T@U) (null@@24 T@U) ($Heap@@23 T@U) ) (! (let ((alpha@@30 (FieldTypeInv0 (type $f@@23)))) (=> (and (and (and (and (= (type $o@@31) refType) (= (type $f@@23) (FieldType alpha@@30))) (= (type alloc@@24) (FieldType boolType))) (= (type null@@24) refType)) (= (type $Heap@@23) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#24| alloc@@24 null@@24 $Heap@@23) $o@@31 $f@@23))  (=> (and (not (= $o@@31 null@@24)) (U_2_bool (MapType1Select $Heap@@23 $o@@31 alloc@@24))) false)))) :qid |bitvecto.145:7| :skolemid |1039| :pattern ( (MapType4Select (|lambda#24| alloc@@24 null@@24 $Heap@@23) $o@@31 $f@@23)) )))
(assert (forall ((arg0@@167 T@U) (arg1@@97 T@U) (arg2@@57 T@U) ) (! (= (type (|lambda#25| arg0@@167 arg1@@97 arg2@@57)) (MapType4Type refType boolType)) :qid |funType:lambda#25| :pattern ( (|lambda#25| arg0@@167 arg1@@97 arg2@@57)) )))
(assert (forall (($o@@32 T@U) ($f@@24 T@U) (alloc@@25 T@U) (null@@25 T@U) ($Heap@@24 T@U) ) (! (let ((alpha@@31 (FieldTypeInv0 (type $f@@24)))) (=> (and (and (and (and (= (type $o@@32) refType) (= (type $f@@24) (FieldType alpha@@31))) (= (type alloc@@25) (FieldType boolType))) (= (type null@@25) refType)) (= (type $Heap@@24) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#25| alloc@@25 null@@25 $Heap@@24) $o@@32 $f@@24))  (=> (and (not (= $o@@32 null@@25)) (U_2_bool (MapType1Select $Heap@@24 $o@@32 alloc@@25))) false)))) :qid |bitvecto.155:7| :skolemid |1040| :pattern ( (MapType4Select (|lambda#25| alloc@@25 null@@25 $Heap@@24) $o@@32 $f@@24)) )))
(assert (forall ((arg0@@168 T@U) (arg1@@98 T@U) (arg2@@58 T@U) ) (! (= (type (|lambda#26| arg0@@168 arg1@@98 arg2@@58)) (MapType4Type refType boolType)) :qid |funType:lambda#26| :pattern ( (|lambda#26| arg0@@168 arg1@@98 arg2@@58)) )))
(assert (forall (($o@@33 T@U) ($f@@25 T@U) (alloc@@26 T@U) (null@@26 T@U) ($Heap@@25 T@U) ) (! (let ((alpha@@32 (FieldTypeInv0 (type $f@@25)))) (=> (and (and (and (and (= (type $o@@33) refType) (= (type $f@@25) (FieldType alpha@@32))) (= (type alloc@@26) (FieldType boolType))) (= (type null@@26) refType)) (= (type $Heap@@25) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#26| alloc@@26 null@@26 $Heap@@25) $o@@33 $f@@25))  (=> (and (not (= $o@@33 null@@26)) (U_2_bool (MapType1Select $Heap@@25 $o@@33 alloc@@26))) false)))) :qid |bitvecto.155:7| :skolemid |1041| :pattern ( (MapType4Select (|lambda#26| alloc@@26 null@@26 $Heap@@25) $o@@33 $f@@25)) )))
(assert (forall ((arg0@@169 T@U) (arg1@@99 T@U) (arg2@@59 T@U) ) (! (= (type (|lambda#27| arg0@@169 arg1@@99 arg2@@59)) (MapType4Type refType boolType)) :qid |funType:lambda#27| :pattern ( (|lambda#27| arg0@@169 arg1@@99 arg2@@59)) )))
(assert (forall (($o@@34 T@U) ($f@@26 T@U) (alloc@@27 T@U) (null@@27 T@U) ($Heap@@26 T@U) ) (! (let ((alpha@@33 (FieldTypeInv0 (type $f@@26)))) (=> (and (and (and (and (= (type $o@@34) refType) (= (type $f@@26) (FieldType alpha@@33))) (= (type alloc@@27) (FieldType boolType))) (= (type null@@27) refType)) (= (type $Heap@@26) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#27| alloc@@27 null@@27 $Heap@@26) $o@@34 $f@@26))  (=> (and (not (= $o@@34 null@@27)) (U_2_bool (MapType1Select $Heap@@26 $o@@34 alloc@@27))) false)))) :qid |bitvecto.165:7| :skolemid |1042| :pattern ( (MapType4Select (|lambda#27| alloc@@27 null@@27 $Heap@@26) $o@@34 $f@@26)) )))
(assert (forall ((arg0@@170 T@U) (arg1@@100 T@U) (arg2@@60 T@U) ) (! (= (type (|lambda#28| arg0@@170 arg1@@100 arg2@@60)) (MapType4Type refType boolType)) :qid |funType:lambda#28| :pattern ( (|lambda#28| arg0@@170 arg1@@100 arg2@@60)) )))
(assert (forall (($o@@35 T@U) ($f@@27 T@U) (alloc@@28 T@U) (null@@28 T@U) ($Heap@@27 T@U) ) (! (let ((alpha@@34 (FieldTypeInv0 (type $f@@27)))) (=> (and (and (and (and (= (type $o@@35) refType) (= (type $f@@27) (FieldType alpha@@34))) (= (type alloc@@28) (FieldType boolType))) (= (type null@@28) refType)) (= (type $Heap@@27) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#28| alloc@@28 null@@28 $Heap@@27) $o@@35 $f@@27))  (=> (and (not (= $o@@35 null@@28)) (U_2_bool (MapType1Select $Heap@@27 $o@@35 alloc@@28))) false)))) :qid |bitvecto.165:7| :skolemid |1043| :pattern ( (MapType4Select (|lambda#28| alloc@@28 null@@28 $Heap@@27) $o@@35 $f@@27)) )))
(assert (forall ((arg0@@171 T@U) (arg1@@101 T@U) (arg2@@61 T@U) ) (! (= (type (|lambda#29| arg0@@171 arg1@@101 arg2@@61)) (MapType4Type refType boolType)) :qid |funType:lambda#29| :pattern ( (|lambda#29| arg0@@171 arg1@@101 arg2@@61)) )))
(assert (forall (($o@@36 T@U) ($f@@28 T@U) (alloc@@29 T@U) (null@@29 T@U) ($Heap@@28 T@U) ) (! (let ((alpha@@35 (FieldTypeInv0 (type $f@@28)))) (=> (and (and (and (and (= (type $o@@36) refType) (= (type $f@@28) (FieldType alpha@@35))) (= (type alloc@@29) (FieldType boolType))) (= (type null@@29) refType)) (= (type $Heap@@28) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#29| alloc@@29 null@@29 $Heap@@28) $o@@36 $f@@28))  (=> (and (not (= $o@@36 null@@29)) (U_2_bool (MapType1Select $Heap@@28 $o@@36 alloc@@29))) false)))) :qid |bitvecto.183:7| :skolemid |1044| :pattern ( (MapType4Select (|lambda#29| alloc@@29 null@@29 $Heap@@28) $o@@36 $f@@28)) )))
(assert (forall ((arg0@@172 T@U) (arg1@@102 T@U) (arg2@@62 T@U) ) (! (= (type (|lambda#30| arg0@@172 arg1@@102 arg2@@62)) (MapType4Type refType boolType)) :qid |funType:lambda#30| :pattern ( (|lambda#30| arg0@@172 arg1@@102 arg2@@62)) )))
(assert (forall (($o@@37 T@U) ($f@@29 T@U) (alloc@@30 T@U) (null@@30 T@U) ($Heap@@29 T@U) ) (! (let ((alpha@@36 (FieldTypeInv0 (type $f@@29)))) (=> (and (and (and (and (= (type $o@@37) refType) (= (type $f@@29) (FieldType alpha@@36))) (= (type alloc@@30) (FieldType boolType))) (= (type null@@30) refType)) (= (type $Heap@@29) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#30| alloc@@30 null@@30 $Heap@@29) $o@@37 $f@@29))  (=> (and (not (= $o@@37 null@@30)) (U_2_bool (MapType1Select $Heap@@29 $o@@37 alloc@@30))) false)))) :qid |bitvecto.183:7| :skolemid |1045| :pattern ( (MapType4Select (|lambda#30| alloc@@30 null@@30 $Heap@@29) $o@@37 $f@@29)) )))
(assert (forall ((arg0@@173 T@U) (arg1@@103 T@U) (arg2@@63 T@U) ) (! (= (type (|lambda#31| arg0@@173 arg1@@103 arg2@@63)) (MapType4Type refType boolType)) :qid |funType:lambda#31| :pattern ( (|lambda#31| arg0@@173 arg1@@103 arg2@@63)) )))
(assert (forall (($o@@38 T@U) ($f@@30 T@U) (alloc@@31 T@U) (null@@31 T@U) ($Heap@@30 T@U) ) (! (let ((alpha@@37 (FieldTypeInv0 (type $f@@30)))) (=> (and (and (and (and (= (type $o@@38) refType) (= (type $f@@30) (FieldType alpha@@37))) (= (type alloc@@31) (FieldType boolType))) (= (type null@@31) refType)) (= (type $Heap@@30) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#31| alloc@@31 null@@31 $Heap@@30) $o@@38 $f@@30))  (=> (and (not (= $o@@38 null@@31)) (U_2_bool (MapType1Select $Heap@@30 $o@@38 alloc@@31))) false)))) :qid |bitvecto.193:7| :skolemid |1046| :pattern ( (MapType4Select (|lambda#31| alloc@@31 null@@31 $Heap@@30) $o@@38 $f@@30)) )))
(assert (forall ((arg0@@174 T@U) (arg1@@104 T@U) (arg2@@64 T@U) ) (! (= (type (|lambda#32| arg0@@174 arg1@@104 arg2@@64)) (MapType4Type refType boolType)) :qid |funType:lambda#32| :pattern ( (|lambda#32| arg0@@174 arg1@@104 arg2@@64)) )))
(assert (forall (($o@@39 T@U) ($f@@31 T@U) (alloc@@32 T@U) (null@@32 T@U) ($Heap@@31 T@U) ) (! (let ((alpha@@38 (FieldTypeInv0 (type $f@@31)))) (=> (and (and (and (and (= (type $o@@39) refType) (= (type $f@@31) (FieldType alpha@@38))) (= (type alloc@@32) (FieldType boolType))) (= (type null@@32) refType)) (= (type $Heap@@31) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#32| alloc@@32 null@@32 $Heap@@31) $o@@39 $f@@31))  (=> (and (not (= $o@@39 null@@32)) (U_2_bool (MapType1Select $Heap@@31 $o@@39 alloc@@32))) false)))) :qid |bitvecto.193:7| :skolemid |1047| :pattern ( (MapType4Select (|lambda#32| alloc@@32 null@@32 $Heap@@31) $o@@39 $f@@31)) )))
(assert (forall ((arg0@@175 T@U) (arg1@@105 T@U) (arg2@@65 T@U) ) (! (= (type (|lambda#33| arg0@@175 arg1@@105 arg2@@65)) (MapType4Type refType boolType)) :qid |funType:lambda#33| :pattern ( (|lambda#33| arg0@@175 arg1@@105 arg2@@65)) )))
(assert (forall (($o@@40 T@U) ($f@@32 T@U) (alloc@@33 T@U) (null@@33 T@U) ($Heap@@32 T@U) ) (! (let ((alpha@@39 (FieldTypeInv0 (type $f@@32)))) (=> (and (and (and (and (= (type $o@@40) refType) (= (type $f@@32) (FieldType alpha@@39))) (= (type alloc@@33) (FieldType boolType))) (= (type null@@33) refType)) (= (type $Heap@@32) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#33| alloc@@33 null@@33 $Heap@@32) $o@@40 $f@@32))  (=> (and (not (= $o@@40 null@@33)) (U_2_bool (MapType1Select $Heap@@32 $o@@40 alloc@@33))) false)))) :qid |bitvecto.202:7| :skolemid |1048| :pattern ( (MapType4Select (|lambda#33| alloc@@33 null@@33 $Heap@@32) $o@@40 $f@@32)) )))
(assert (forall ((arg0@@176 T@U) (arg1@@106 T@U) (arg2@@66 T@U) ) (! (= (type (|lambda#34| arg0@@176 arg1@@106 arg2@@66)) (MapType4Type refType boolType)) :qid |funType:lambda#34| :pattern ( (|lambda#34| arg0@@176 arg1@@106 arg2@@66)) )))
(assert (forall (($o@@41 T@U) ($f@@33 T@U) (alloc@@34 T@U) (null@@34 T@U) ($Heap@@33 T@U) ) (! (let ((alpha@@40 (FieldTypeInv0 (type $f@@33)))) (=> (and (and (and (and (= (type $o@@41) refType) (= (type $f@@33) (FieldType alpha@@40))) (= (type alloc@@34) (FieldType boolType))) (= (type null@@34) refType)) (= (type $Heap@@33) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#34| alloc@@34 null@@34 $Heap@@33) $o@@41 $f@@33))  (=> (and (not (= $o@@41 null@@34)) (U_2_bool (MapType1Select $Heap@@33 $o@@41 alloc@@34))) false)))) :qid |bitvecto.202:7| :skolemid |1049| :pattern ( (MapType4Select (|lambda#34| alloc@@34 null@@34 $Heap@@33) $o@@41 $f@@33)) )))
(assert (forall ((arg0@@177 T@U) (arg1@@107 T@U) (arg2@@67 T@U) ) (! (= (type (|lambda#35| arg0@@177 arg1@@107 arg2@@67)) (MapType4Type refType boolType)) :qid |funType:lambda#35| :pattern ( (|lambda#35| arg0@@177 arg1@@107 arg2@@67)) )))
(assert (forall (($o@@42 T@U) ($f@@34 T@U) (alloc@@35 T@U) (null@@35 T@U) ($Heap@@34 T@U) ) (! (let ((alpha@@41 (FieldTypeInv0 (type $f@@34)))) (=> (and (and (and (and (= (type $o@@42) refType) (= (type $f@@34) (FieldType alpha@@41))) (= (type alloc@@35) (FieldType boolType))) (= (type null@@35) refType)) (= (type $Heap@@34) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#35| alloc@@35 null@@35 $Heap@@34) $o@@42 $f@@34))  (=> (and (not (= $o@@42 null@@35)) (U_2_bool (MapType1Select $Heap@@34 $o@@42 alloc@@35))) false)))) :qid |bitvecto.211:7| :skolemid |1050| :pattern ( (MapType4Select (|lambda#35| alloc@@35 null@@35 $Heap@@34) $o@@42 $f@@34)) )))
(assert (forall ((arg0@@178 T@U) (arg1@@108 T@U) (arg2@@68 T@U) ) (! (= (type (|lambda#36| arg0@@178 arg1@@108 arg2@@68)) (MapType4Type refType boolType)) :qid |funType:lambda#36| :pattern ( (|lambda#36| arg0@@178 arg1@@108 arg2@@68)) )))
(assert (forall (($o@@43 T@U) ($f@@35 T@U) (alloc@@36 T@U) (null@@36 T@U) ($Heap@@35 T@U) ) (! (let ((alpha@@42 (FieldTypeInv0 (type $f@@35)))) (=> (and (and (and (and (= (type $o@@43) refType) (= (type $f@@35) (FieldType alpha@@42))) (= (type alloc@@36) (FieldType boolType))) (= (type null@@36) refType)) (= (type $Heap@@35) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#36| alloc@@36 null@@36 $Heap@@35) $o@@43 $f@@35))  (=> (and (not (= $o@@43 null@@36)) (U_2_bool (MapType1Select $Heap@@35 $o@@43 alloc@@36))) false)))) :qid |bitvecto.211:7| :skolemid |1051| :pattern ( (MapType4Select (|lambda#36| alloc@@36 null@@36 $Heap@@35) $o@@43 $f@@35)) )))
(assert (forall ((arg0@@179 T@U) (arg1@@109 T@U) (arg2@@69 T@U) ) (! (= (type (|lambda#37| arg0@@179 arg1@@109 arg2@@69)) (MapType4Type refType boolType)) :qid |funType:lambda#37| :pattern ( (|lambda#37| arg0@@179 arg1@@109 arg2@@69)) )))
(assert (forall (($o@@44 T@U) ($f@@36 T@U) (alloc@@37 T@U) (null@@37 T@U) ($Heap@@36 T@U) ) (! (let ((alpha@@43 (FieldTypeInv0 (type $f@@36)))) (=> (and (and (and (and (= (type $o@@44) refType) (= (type $f@@36) (FieldType alpha@@43))) (= (type alloc@@37) (FieldType boolType))) (= (type null@@37) refType)) (= (type $Heap@@36) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#37| alloc@@37 null@@37 $Heap@@36) $o@@44 $f@@36))  (=> (and (not (= $o@@44 null@@37)) (U_2_bool (MapType1Select $Heap@@36 $o@@44 alloc@@37))) false)))) :qid |bitvecto.228:7| :skolemid |1052| :pattern ( (MapType4Select (|lambda#37| alloc@@37 null@@37 $Heap@@36) $o@@44 $f@@36)) )))
(assert (forall ((arg0@@180 T@U) (arg1@@110 T@U) (arg2@@70 T@U) ) (! (= (type (|lambda#38| arg0@@180 arg1@@110 arg2@@70)) (MapType4Type refType boolType)) :qid |funType:lambda#38| :pattern ( (|lambda#38| arg0@@180 arg1@@110 arg2@@70)) )))
(assert (forall (($o@@45 T@U) ($f@@37 T@U) (alloc@@38 T@U) (null@@38 T@U) ($Heap@@37 T@U) ) (! (let ((alpha@@44 (FieldTypeInv0 (type $f@@37)))) (=> (and (and (and (and (= (type $o@@45) refType) (= (type $f@@37) (FieldType alpha@@44))) (= (type alloc@@38) (FieldType boolType))) (= (type null@@38) refType)) (= (type $Heap@@37) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#38| alloc@@38 null@@38 $Heap@@37) $o@@45 $f@@37))  (=> (and (not (= $o@@45 null@@38)) (U_2_bool (MapType1Select $Heap@@37 $o@@45 alloc@@38))) false)))) :qid |bitvecto.228:7| :skolemid |1053| :pattern ( (MapType4Select (|lambda#38| alloc@@38 null@@38 $Heap@@37) $o@@45 $f@@37)) )))
(assert (forall ((arg0@@181 T@U) (arg1@@111 T@U) (arg2@@71 T@U) ) (! (= (type (|lambda#39| arg0@@181 arg1@@111 arg2@@71)) (MapType4Type refType boolType)) :qid |funType:lambda#39| :pattern ( (|lambda#39| arg0@@181 arg1@@111 arg2@@71)) )))
(assert (forall (($o@@46 T@U) ($f@@38 T@U) (alloc@@39 T@U) (null@@39 T@U) ($Heap@@38 T@U) ) (! (let ((alpha@@45 (FieldTypeInv0 (type $f@@38)))) (=> (and (and (and (and (= (type $o@@46) refType) (= (type $f@@38) (FieldType alpha@@45))) (= (type alloc@@39) (FieldType boolType))) (= (type null@@39) refType)) (= (type $Heap@@38) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#39| alloc@@39 null@@39 $Heap@@38) $o@@46 $f@@38))  (=> (and (not (= $o@@46 null@@39)) (U_2_bool (MapType1Select $Heap@@38 $o@@46 alloc@@39))) false)))) :qid |bitvecto.237:7| :skolemid |1054| :pattern ( (MapType4Select (|lambda#39| alloc@@39 null@@39 $Heap@@38) $o@@46 $f@@38)) )))
(assert (forall ((arg0@@182 T@U) (arg1@@112 T@U) (arg2@@72 T@U) ) (! (= (type (|lambda#40| arg0@@182 arg1@@112 arg2@@72)) (MapType4Type refType boolType)) :qid |funType:lambda#40| :pattern ( (|lambda#40| arg0@@182 arg1@@112 arg2@@72)) )))
(assert (forall (($o@@47 T@U) ($f@@39 T@U) (alloc@@40 T@U) (null@@40 T@U) ($Heap@@39 T@U) ) (! (let ((alpha@@46 (FieldTypeInv0 (type $f@@39)))) (=> (and (and (and (and (= (type $o@@47) refType) (= (type $f@@39) (FieldType alpha@@46))) (= (type alloc@@40) (FieldType boolType))) (= (type null@@40) refType)) (= (type $Heap@@39) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#40| alloc@@40 null@@40 $Heap@@39) $o@@47 $f@@39))  (=> (and (not (= $o@@47 null@@40)) (U_2_bool (MapType1Select $Heap@@39 $o@@47 alloc@@40))) false)))) :qid |bitvecto.237:7| :skolemid |1055| :pattern ( (MapType4Select (|lambda#40| alloc@@40 null@@40 $Heap@@39) $o@@47 $f@@39)) )))
(assert (forall ((arg0@@183 T@U) (arg1@@113 T@U) (arg2@@73 T@U) ) (! (= (type (|lambda#41| arg0@@183 arg1@@113 arg2@@73)) (MapType4Type refType boolType)) :qid |funType:lambda#41| :pattern ( (|lambda#41| arg0@@183 arg1@@113 arg2@@73)) )))
(assert (forall (($o@@48 T@U) ($f@@40 T@U) (alloc@@41 T@U) (null@@41 T@U) ($Heap@@40 T@U) ) (! (let ((alpha@@47 (FieldTypeInv0 (type $f@@40)))) (=> (and (and (and (and (= (type $o@@48) refType) (= (type $f@@40) (FieldType alpha@@47))) (= (type alloc@@41) (FieldType boolType))) (= (type null@@41) refType)) (= (type $Heap@@40) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#41| alloc@@41 null@@41 $Heap@@40) $o@@48 $f@@40))  (=> (and (not (= $o@@48 null@@41)) (U_2_bool (MapType1Select $Heap@@40 $o@@48 alloc@@41))) false)))) :qid |bitvecto.263:7| :skolemid |1056| :pattern ( (MapType4Select (|lambda#41| alloc@@41 null@@41 $Heap@@40) $o@@48 $f@@40)) )))
(assert (forall ((arg0@@184 T@U) (arg1@@114 T@U) (arg2@@74 T@U) ) (! (= (type (|lambda#42| arg0@@184 arg1@@114 arg2@@74)) (MapType4Type refType boolType)) :qid |funType:lambda#42| :pattern ( (|lambda#42| arg0@@184 arg1@@114 arg2@@74)) )))
(assert (forall (($o@@49 T@U) ($f@@41 T@U) (alloc@@42 T@U) (null@@42 T@U) ($Heap@@41 T@U) ) (! (let ((alpha@@48 (FieldTypeInv0 (type $f@@41)))) (=> (and (and (and (and (= (type $o@@49) refType) (= (type $f@@41) (FieldType alpha@@48))) (= (type alloc@@42) (FieldType boolType))) (= (type null@@42) refType)) (= (type $Heap@@41) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#42| alloc@@42 null@@42 $Heap@@41) $o@@49 $f@@41))  (=> (and (not (= $o@@49 null@@42)) (U_2_bool (MapType1Select $Heap@@41 $o@@49 alloc@@42))) false)))) :qid |bitvecto.263:7| :skolemid |1057| :pattern ( (MapType4Select (|lambda#42| alloc@@42 null@@42 $Heap@@41) $o@@49 $f@@41)) )))
(assert (forall ((arg0@@185 T@U) (arg1@@115 T@U) (arg2@@75 T@U) ) (! (= (type (|lambda#43| arg0@@185 arg1@@115 arg2@@75)) (MapType4Type refType boolType)) :qid |funType:lambda#43| :pattern ( (|lambda#43| arg0@@185 arg1@@115 arg2@@75)) )))
(assert (forall (($o@@50 T@U) ($f@@42 T@U) (alloc@@43 T@U) (null@@43 T@U) ($Heap@@42 T@U) ) (! (let ((alpha@@49 (FieldTypeInv0 (type $f@@42)))) (=> (and (and (and (and (= (type $o@@50) refType) (= (type $f@@42) (FieldType alpha@@49))) (= (type alloc@@43) (FieldType boolType))) (= (type null@@43) refType)) (= (type $Heap@@42) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#43| alloc@@43 null@@43 $Heap@@42) $o@@50 $f@@42))  (=> (and (not (= $o@@50 null@@43)) (U_2_bool (MapType1Select $Heap@@42 $o@@50 alloc@@43))) false)))) :qid |bitvecto.289:7| :skolemid |1058| :pattern ( (MapType4Select (|lambda#43| alloc@@43 null@@43 $Heap@@42) $o@@50 $f@@42)) )))
(assert (forall ((arg0@@186 T@U) (arg1@@116 T@U) (arg2@@76 T@U) ) (! (= (type (|lambda#44| arg0@@186 arg1@@116 arg2@@76)) (MapType4Type refType boolType)) :qid |funType:lambda#44| :pattern ( (|lambda#44| arg0@@186 arg1@@116 arg2@@76)) )))
(assert (forall (($o@@51 T@U) ($f@@43 T@U) (alloc@@44 T@U) (null@@44 T@U) ($Heap@@43 T@U) ) (! (let ((alpha@@50 (FieldTypeInv0 (type $f@@43)))) (=> (and (and (and (and (= (type $o@@51) refType) (= (type $f@@43) (FieldType alpha@@50))) (= (type alloc@@44) (FieldType boolType))) (= (type null@@44) refType)) (= (type $Heap@@43) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#44| alloc@@44 null@@44 $Heap@@43) $o@@51 $f@@43))  (=> (and (not (= $o@@51 null@@44)) (U_2_bool (MapType1Select $Heap@@43 $o@@51 alloc@@44))) false)))) :qid |bitvecto.289:7| :skolemid |1059| :pattern ( (MapType4Select (|lambda#44| alloc@@44 null@@44 $Heap@@43) $o@@51 $f@@43)) )))
(assert (forall ((arg0@@187 T@U) (arg1@@117 T@U) (arg2@@77 T@U) ) (! (= (type (|lambda#45| arg0@@187 arg1@@117 arg2@@77)) (MapType4Type refType boolType)) :qid |funType:lambda#45| :pattern ( (|lambda#45| arg0@@187 arg1@@117 arg2@@77)) )))
(assert (forall (($o@@52 T@U) ($f@@44 T@U) (alloc@@45 T@U) (null@@45 T@U) ($Heap@@44 T@U) ) (! (let ((alpha@@51 (FieldTypeInv0 (type $f@@44)))) (=> (and (and (and (and (= (type $o@@52) refType) (= (type $f@@44) (FieldType alpha@@51))) (= (type alloc@@45) (FieldType boolType))) (= (type null@@45) refType)) (= (type $Heap@@44) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#45| alloc@@45 null@@45 $Heap@@44) $o@@52 $f@@44))  (=> (and (not (= $o@@52 null@@45)) (U_2_bool (MapType1Select $Heap@@44 $o@@52 alloc@@45))) false)))) :qid |bitvecto.296:7| :skolemid |1060| :pattern ( (MapType4Select (|lambda#45| alloc@@45 null@@45 $Heap@@44) $o@@52 $f@@44)) )))
(assert (forall ((arg0@@188 T@U) (arg1@@118 T@U) (arg2@@78 T@U) ) (! (= (type (|lambda#46| arg0@@188 arg1@@118 arg2@@78)) (MapType4Type refType boolType)) :qid |funType:lambda#46| :pattern ( (|lambda#46| arg0@@188 arg1@@118 arg2@@78)) )))
(assert (forall (($o@@53 T@U) ($f@@45 T@U) (alloc@@46 T@U) (null@@46 T@U) ($Heap@@45 T@U) ) (! (let ((alpha@@52 (FieldTypeInv0 (type $f@@45)))) (=> (and (and (and (and (= (type $o@@53) refType) (= (type $f@@45) (FieldType alpha@@52))) (= (type alloc@@46) (FieldType boolType))) (= (type null@@46) refType)) (= (type $Heap@@45) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#46| alloc@@46 null@@46 $Heap@@45) $o@@53 $f@@45))  (=> (and (not (= $o@@53 null@@46)) (U_2_bool (MapType1Select $Heap@@45 $o@@53 alloc@@46))) false)))) :qid |bitvecto.296:7| :skolemid |1061| :pattern ( (MapType4Select (|lambda#46| alloc@@46 null@@46 $Heap@@45) $o@@53 $f@@45)) )))
(assert (forall ((arg0@@189 T@U) (arg1@@119 T@U) (arg2@@79 T@U) ) (! (= (type (|lambda#47| arg0@@189 arg1@@119 arg2@@79)) (MapType4Type refType boolType)) :qid |funType:lambda#47| :pattern ( (|lambda#47| arg0@@189 arg1@@119 arg2@@79)) )))
(assert (forall (($o@@54 T@U) ($f@@46 T@U) (alloc@@47 T@U) (null@@47 T@U) ($Heap@@46 T@U) ) (! (let ((alpha@@53 (FieldTypeInv0 (type $f@@46)))) (=> (and (and (and (and (= (type $o@@54) refType) (= (type $f@@46) (FieldType alpha@@53))) (= (type alloc@@47) (FieldType boolType))) (= (type null@@47) refType)) (= (type $Heap@@46) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#47| alloc@@47 null@@47 $Heap@@46) $o@@54 $f@@46))  (=> (and (not (= $o@@54 null@@47)) (U_2_bool (MapType1Select $Heap@@46 $o@@54 alloc@@47))) false)))) :qid |bitvecto.310:7| :skolemid |1062| :pattern ( (MapType4Select (|lambda#47| alloc@@47 null@@47 $Heap@@46) $o@@54 $f@@46)) )))
(assert (forall ((arg0@@190 T@U) (arg1@@120 T@U) (arg2@@80 T@U) ) (! (= (type (|lambda#48| arg0@@190 arg1@@120 arg2@@80)) (MapType4Type refType boolType)) :qid |funType:lambda#48| :pattern ( (|lambda#48| arg0@@190 arg1@@120 arg2@@80)) )))
(assert (forall (($o@@55 T@U) ($f@@47 T@U) (alloc@@48 T@U) (null@@48 T@U) ($Heap@@47 T@U) ) (! (let ((alpha@@54 (FieldTypeInv0 (type $f@@47)))) (=> (and (and (and (and (= (type $o@@55) refType) (= (type $f@@47) (FieldType alpha@@54))) (= (type alloc@@48) (FieldType boolType))) (= (type null@@48) refType)) (= (type $Heap@@47) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#48| alloc@@48 null@@48 $Heap@@47) $o@@55 $f@@47))  (=> (and (not (= $o@@55 null@@48)) (U_2_bool (MapType1Select $Heap@@47 $o@@55 alloc@@48))) false)))) :qid |bitvecto.327:7| :skolemid |1063| :pattern ( (MapType4Select (|lambda#48| alloc@@48 null@@48 $Heap@@47) $o@@55 $f@@47)) )))
(assert (forall ((arg0@@191 T@U) (arg1@@121 T@U) (arg2@@81 T@U) ) (! (= (type (|lambda#49| arg0@@191 arg1@@121 arg2@@81)) (MapType4Type refType boolType)) :qid |funType:lambda#49| :pattern ( (|lambda#49| arg0@@191 arg1@@121 arg2@@81)) )))
(assert (forall (($o@@56 T@U) ($f@@48 T@U) (alloc@@49 T@U) (null@@49 T@U) ($Heap@@48 T@U) ) (! (let ((alpha@@55 (FieldTypeInv0 (type $f@@48)))) (=> (and (and (and (and (= (type $o@@56) refType) (= (type $f@@48) (FieldType alpha@@55))) (= (type alloc@@49) (FieldType boolType))) (= (type null@@49) refType)) (= (type $Heap@@48) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#49| alloc@@49 null@@49 $Heap@@48) $o@@56 $f@@48))  (=> (and (not (= $o@@56 null@@49)) (U_2_bool (MapType1Select $Heap@@48 $o@@56 alloc@@49))) false)))) :qid |bitvecto.327:7| :skolemid |1064| :pattern ( (MapType4Select (|lambda#49| alloc@@49 null@@49 $Heap@@48) $o@@56 $f@@48)) )))
(assert (forall ((arg0@@192 T@U) (arg1@@122 T@U) (arg2@@82 T@U) ) (! (= (type (|lambda#50| arg0@@192 arg1@@122 arg2@@82)) (MapType4Type refType boolType)) :qid |funType:lambda#50| :pattern ( (|lambda#50| arg0@@192 arg1@@122 arg2@@82)) )))
(assert (forall (($o@@57 T@U) ($f@@49 T@U) (alloc@@50 T@U) (null@@50 T@U) ($Heap@@49 T@U) ) (! (let ((alpha@@56 (FieldTypeInv0 (type $f@@49)))) (=> (and (and (and (and (= (type $o@@57) refType) (= (type $f@@49) (FieldType alpha@@56))) (= (type alloc@@50) (FieldType boolType))) (= (type null@@50) refType)) (= (type $Heap@@49) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#50| alloc@@50 null@@50 $Heap@@49) $o@@57 $f@@49))  (=> (and (not (= $o@@57 null@@50)) (U_2_bool (MapType1Select $Heap@@49 $o@@57 alloc@@50))) false)))) :qid |bitvecto.337:7| :skolemid |1065| :pattern ( (MapType4Select (|lambda#50| alloc@@50 null@@50 $Heap@@49) $o@@57 $f@@49)) )))
(assert (forall ((arg0@@193 T@U) (arg1@@123 T@U) (arg2@@83 T@U) ) (! (= (type (|lambda#51| arg0@@193 arg1@@123 arg2@@83)) (MapType4Type refType boolType)) :qid |funType:lambda#51| :pattern ( (|lambda#51| arg0@@193 arg1@@123 arg2@@83)) )))
(assert (forall (($o@@58 T@U) ($f@@50 T@U) (alloc@@51 T@U) (null@@51 T@U) ($Heap@@50 T@U) ) (! (let ((alpha@@57 (FieldTypeInv0 (type $f@@50)))) (=> (and (and (and (and (= (type $o@@58) refType) (= (type $f@@50) (FieldType alpha@@57))) (= (type alloc@@51) (FieldType boolType))) (= (type null@@51) refType)) (= (type $Heap@@50) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#51| alloc@@51 null@@51 $Heap@@50) $o@@58 $f@@50))  (=> (and (not (= $o@@58 null@@51)) (U_2_bool (MapType1Select $Heap@@50 $o@@58 alloc@@51))) false)))) :qid |bitvecto.337:7| :skolemid |1066| :pattern ( (MapType4Select (|lambda#51| alloc@@51 null@@51 $Heap@@50) $o@@58 $f@@50)) )))
(assert (forall ((arg0@@194 T@U) (arg1@@124 T@U) (arg2@@84 T@U) ) (! (= (type (|lambda#52| arg0@@194 arg1@@124 arg2@@84)) (MapType4Type refType boolType)) :qid |funType:lambda#52| :pattern ( (|lambda#52| arg0@@194 arg1@@124 arg2@@84)) )))
(assert (forall (($o@@59 T@U) ($f@@51 T@U) (alloc@@52 T@U) (null@@52 T@U) ($Heap@@51 T@U) ) (! (let ((alpha@@58 (FieldTypeInv0 (type $f@@51)))) (=> (and (and (and (and (= (type $o@@59) refType) (= (type $f@@51) (FieldType alpha@@58))) (= (type alloc@@52) (FieldType boolType))) (= (type null@@52) refType)) (= (type $Heap@@51) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#52| alloc@@52 null@@52 $Heap@@51) $o@@59 $f@@51))  (=> (and (not (= $o@@59 null@@52)) (U_2_bool (MapType1Select $Heap@@51 $o@@59 alloc@@52))) false)))) :qid |bitvecto.349:7| :skolemid |1067| :pattern ( (MapType4Select (|lambda#52| alloc@@52 null@@52 $Heap@@51) $o@@59 $f@@51)) )))
(assert (forall ((arg0@@195 T@U) (arg1@@125 T@U) (arg2@@85 T@U) ) (! (= (type (|lambda#53| arg0@@195 arg1@@125 arg2@@85)) (MapType4Type refType boolType)) :qid |funType:lambda#53| :pattern ( (|lambda#53| arg0@@195 arg1@@125 arg2@@85)) )))
(assert (forall (($o@@60 T@U) ($f@@52 T@U) (alloc@@53 T@U) (null@@53 T@U) ($Heap@@52 T@U) ) (! (let ((alpha@@59 (FieldTypeInv0 (type $f@@52)))) (=> (and (and (and (and (= (type $o@@60) refType) (= (type $f@@52) (FieldType alpha@@59))) (= (type alloc@@53) (FieldType boolType))) (= (type null@@53) refType)) (= (type $Heap@@52) (MapType1Type refType))) (= (U_2_bool (MapType4Select (|lambda#53| alloc@@53 null@@53 $Heap@@52) $o@@60 $f@@52))  (=> (and (not (= $o@@60 null@@53)) (U_2_bool (MapType1Select $Heap@@52 $o@@60 alloc@@53))) false)))) :qid |bitvecto.349:7| :skolemid |1068| :pattern ( (MapType4Select (|lambda#53| alloc@@53 null@@53 $Heap@@52) $o@@60 $f@@52)) )))
(declare-fun StartFuelAssert__module._default.WordAsBits () T@U)
(declare-fun StartFuelAssert__module._default.BitsAsWord () T@U)
(declare-fun StartFuel__module._default.BitAdd () T@U)
(declare-fun StartFuelAssert__module._default.BitAdd () T@U)
(declare-fun StartFuel__module._default.BitSub () T@U)
(declare-fun StartFuelAssert__module._default.BitSub () T@U)
(declare-fun StartFuelAssert__module._default.BitAnd () T@U)
(declare-fun StartFuelAssert__module._default.BitOr () T@U)
(declare-fun StartFuelAssert__module._default.BitXor () T@U)
(declare-fun StartFuel__module._default.BitMod () T@U)
(declare-fun StartFuelAssert__module._default.BitMod () T@U)
(declare-fun StartFuel__module._default.BitDiv () T@U)
(declare-fun StartFuelAssert__module._default.BitDiv () T@U)
(declare-fun StartFuel__module._default.BitMul () T@U)
(declare-fun StartFuelAssert__module._default.BitMul () T@U)
(declare-fun StartFuelAssert__module._default.BitNot () T@U)
(declare-fun StartFuelAssert__module._default.BitShiftLeft () T@U)
(declare-fun StartFuelAssert__module._default.BitShiftRight () T@U)
(declare-fun StartFuelAssert__module._default.BitRotateRight () T@U)
(declare-fun StartFuelAssert__module._default.pow2 () T@U)
(declare-fun StartFuelAssert__module._default.BitAtPos () T@U)
(declare-fun StartFuel__module._default.BitwiseMaskHigh () T@U)
(declare-fun StartFuelAssert__module._default.BitwiseMaskHigh () T@U)
(declare-fun StartFuelAssert__module._default.BitwiseMaskLow () T@U)
(declare-fun StartFuel__module._default.UpdateTopBits () T@U)
(declare-fun StartFuelAssert__module._default.UpdateTopBits () T@U)
(declare-fun StartFuel__module._default.TruncateWord () T@U)
(declare-fun StartFuelAssert__module._default.TruncateWord () T@U)
(declare-fun StartFuel__module._default.PageAligned () T@U)
(declare-fun StartFuelAssert__module._default.PageAligned () T@U)
(declare-fun $_Frame@0 () T@U)
(declare-fun $Heap@@53 () T@U)
(declare-fun $Heap@0 () T@U)
(declare-fun %lbl%+0 () Bool)
(declare-fun $IsHeapAnchor (T@U) Bool)
(declare-fun %lbl%@1 () Bool)
(declare-fun |x#0@@109| () Int)
(declare-fun %lbl%@2 () Bool)
(declare-fun |##amount#0@0| () Int)
(declare-fun %lbl%@3 () Bool)
(declare-fun %lbl%@4 () Bool)
(declare-fun %lbl%@5 () Bool)
(declare-fun %lbl%+6 () Bool)
(declare-fun $FunctionContextHeight () Int)
(assert  (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (type StartFuelAssert__module._default.WordAsBits) LayerTypeType) (= (type StartFuelAssert__module._default.BitsAsWord) LayerTypeType)) (= (type StartFuel__module._default.BitAdd) LayerTypeType)) (= (type StartFuelAssert__module._default.BitAdd) LayerTypeType)) (= (type StartFuel__module._default.BitSub) LayerTypeType)) (= (type StartFuelAssert__module._default.BitSub) LayerTypeType)) (= (type StartFuelAssert__module._default.BitAnd) LayerTypeType)) (= (type StartFuelAssert__module._default.BitOr) LayerTypeType)) (= (type StartFuelAssert__module._default.BitXor) LayerTypeType)) (= (type StartFuel__module._default.BitMod) LayerTypeType)) (= (type StartFuelAssert__module._default.BitMod) LayerTypeType)) (= (type StartFuel__module._default.BitDiv) LayerTypeType)) (= (type StartFuelAssert__module._default.BitDiv) LayerTypeType)) (= (type StartFuel__module._default.BitMul) LayerTypeType)) (= (type StartFuelAssert__module._default.BitMul) LayerTypeType)) (= (type StartFuelAssert__module._default.BitNot) LayerTypeType)) (= (type StartFuelAssert__module._default.BitShiftLeft) LayerTypeType)) (= (type StartFuelAssert__module._default.BitShiftRight) LayerTypeType)) (= (type StartFuelAssert__module._default.BitRotateRight) LayerTypeType)) (= (type StartFuelAssert__module._default.pow2) LayerTypeType)) (= (type StartFuelAssert__module._default.BitAtPos) LayerTypeType)) (= (type StartFuel__module._default.BitwiseMaskHigh) LayerTypeType)) (= (type StartFuelAssert__module._default.BitwiseMaskHigh) LayerTypeType)) (= (type StartFuelAssert__module._default.BitwiseMaskLow) LayerTypeType)) (= (type StartFuel__module._default.UpdateTopBits) LayerTypeType)) (= (type StartFuelAssert__module._default.UpdateTopBits) LayerTypeType)) (= (type StartFuel__module._default.TruncateWord) LayerTypeType)) (= (type StartFuelAssert__module._default.TruncateWord) LayerTypeType)) (= (type StartFuel__module._default.PageAligned) LayerTypeType)) (= (type StartFuelAssert__module._default.PageAligned) LayerTypeType)) (= (type $_Frame@0) (MapType4Type refType boolType))) (= (type $Heap@@53) (MapType1Type refType))) (= (type $Heap@0) (MapType1Type refType))))
(push 1)
(set-info :boogie-vc-id CheckWellformed$$_module.__default.lemma__RightShift2)
(assert (not (let ((anon0_correct  (=> (! (and %lbl%+0 true) :lblpos +0) (=> (= (AsFuelBottom StartFuel__module._default.WordAsBits) StartFuel__module._default.WordAsBits) (=> (and (and (and (and (= (AsFuelBottom StartFuelAssert__module._default.WordAsBits) StartFuelAssert__module._default.WordAsBits) (= (AsFuelBottom StartFuel__module._default.BitsAsWord) StartFuel__module._default.BitsAsWord)) (and (= (AsFuelBottom StartFuelAssert__module._default.BitsAsWord) StartFuelAssert__module._default.BitsAsWord) (= (AsFuelBottom StartFuel__module._default.BitAdd) StartFuel__module._default.BitAdd))) (and (and (= (AsFuelBottom StartFuelAssert__module._default.BitAdd) StartFuelAssert__module._default.BitAdd) (= (AsFuelBottom StartFuel__module._default.BitSub) StartFuel__module._default.BitSub)) (and (= (AsFuelBottom StartFuelAssert__module._default.BitSub) StartFuelAssert__module._default.BitSub) (= (AsFuelBottom StartFuel__module._default.BitAnd) StartFuel__module._default.BitAnd)))) (and (and (and (= (AsFuelBottom StartFuelAssert__module._default.BitAnd) StartFuelAssert__module._default.BitAnd) (= (AsFuelBottom StartFuel__module._default.BitOr) StartFuel__module._default.BitOr)) (and (= (AsFuelBottom StartFuelAssert__module._default.BitOr) StartFuelAssert__module._default.BitOr) (= (AsFuelBottom StartFuel__module._default.BitXor) StartFuel__module._default.BitXor))) (and (and (= (AsFuelBottom StartFuelAssert__module._default.BitXor) StartFuelAssert__module._default.BitXor) (= (AsFuelBottom StartFuel__module._default.BitMod) StartFuel__module._default.BitMod)) (and (= (AsFuelBottom StartFuelAssert__module._default.BitMod) StartFuelAssert__module._default.BitMod) (= (AsFuelBottom StartFuel__module._default.BitDiv) StartFuel__module._default.BitDiv))))) (=> (and (and (and (and (and (= (AsFuelBottom StartFuelAssert__module._default.BitDiv) StartFuelAssert__module._default.BitDiv) (= (AsFuelBottom StartFuel__module._default.BitMul) StartFuel__module._default.BitMul)) (and (= (AsFuelBottom StartFuelAssert__module._default.BitMul) StartFuelAssert__module._default.BitMul) (= (AsFuelBottom StartFuel__module._default.BitNot) StartFuel__module._default.BitNot))) (and (and (= (AsFuelBottom StartFuelAssert__module._default.BitNot) StartFuelAssert__module._default.BitNot) (= (AsFuelBottom StartFuel__module._default.BitShiftLeft) StartFuel__module._default.BitShiftLeft)) (and (= (AsFuelBottom StartFuelAssert__module._default.BitShiftLeft) StartFuelAssert__module._default.BitShiftLeft) (= (AsFuelBottom StartFuel__module._default.BitShiftRight) StartFuel__module._default.BitShiftRight)))) (and (and (and (= (AsFuelBottom StartFuelAssert__module._default.BitShiftRight) StartFuelAssert__module._default.BitShiftRight) (= (AsFuelBottom StartFuel__module._default.BitRotateRight) StartFuel__module._default.BitRotateRight)) (and (= (AsFuelBottom StartFuelAssert__module._default.BitRotateRight) StartFuelAssert__module._default.BitRotateRight) (= (AsFuelBottom StartFuel__module._default.pow2) StartFuel__module._default.pow2))) (and (and (= (AsFuelBottom StartFuelAssert__module._default.pow2) StartFuelAssert__module._default.pow2) (= (AsFuelBottom StartFuel__module._default.BitAtPos) StartFuel__module._default.BitAtPos)) (and (= (AsFuelBottom StartFuelAssert__module._default.BitAtPos) StartFuelAssert__module._default.BitAtPos) (= (AsFuelBottom StartFuel__module._default.BitwiseMaskHigh) StartFuel__module._default.BitwiseMaskHigh))))) (and (and (and (and (= (AsFuelBottom StartFuelAssert__module._default.BitwiseMaskHigh) StartFuelAssert__module._default.BitwiseMaskHigh) (= (AsFuelBottom StartFuel__module._default.BitwiseMaskLow) StartFuel__module._default.BitwiseMaskLow)) (and (= (AsFuelBottom StartFuelAssert__module._default.BitwiseMaskLow) StartFuelAssert__module._default.BitwiseMaskLow) (= (AsFuelBottom StartFuel__module._default.UpdateTopBits) StartFuel__module._default.UpdateTopBits))) (and (and (= (AsFuelBottom StartFuelAssert__module._default.UpdateTopBits) StartFuelAssert__module._default.UpdateTopBits) (= (AsFuelBottom StartFuel__module._default.WordAligned) StartFuel__module._default.WordAligned)) (and (= (AsFuelBottom StartFuelAssert__module._default.WordAligned) StartFuelAssert__module._default.WordAligned) (= (AsFuelBottom StartFuel__module._default.TruncateWord) StartFuel__module._default.TruncateWord)))) (and (and (and (= (AsFuelBottom StartFuelAssert__module._default.TruncateWord) StartFuelAssert__module._default.TruncateWord) (= (AsFuelBottom StartFuel__module._default.PageAligned) StartFuel__module._default.PageAligned)) (and (= (AsFuelBottom StartFuelAssert__module._default.PageAligned) StartFuelAssert__module._default.PageAligned) (= $_Frame@0 (|lambda#31| alloc null $Heap@@53)))) (and (and ($IsGoodHeap $Heap@0) ($IsHeapAnchor $Heap@0)) (= $Heap@@53 $Heap@0))))) (and (! (or %lbl%@1 ($Is (int_2_U |x#0@@109|) Tclass._module.word)) :lblneg @1) (=> ($Is (int_2_U |x#0@@109|) Tclass._module.word) (and (! (or %lbl%@2 ($Is (int_2_U (LitInt 2)) Tclass._module.word)) :lblneg @2) (=> ($Is (int_2_U (LitInt 2)) Tclass._module.word) (=> (= |##amount#0@0| (LitInt 2)) (and (! (or %lbl%@3 (INTERNAL_le_boogie 0 |##amount#0@0|)) :lblneg @3) (and (! (or %lbl%@4 (INTERNAL_lt_boogie |##amount#0@0| 32)) :lblneg @4) (=> (and (and (INTERNAL_le_boogie 0 |##amount#0@0|) (INTERNAL_lt_boogie |##amount#0@0| 32)) (|_module.__default.RightShift#canCall| |x#0@@109| (LitInt 2))) (! (or %lbl%@5 (not (= (LitInt 4) 0))) :lblneg @5))))))))))))))) (let ((PreconditionGeneratedEntry_correct  (=> (! (and %lbl%+6 true) :lblpos +6) (=> (and (and ($IsGoodHeap $Heap@@53) ($IsHeapAnchor $Heap@@53)) (and (_module.__default.isUInt32 |x#0@@109|) (= 37 $FunctionContextHeight))) anon0_correct)))) PreconditionGeneratedEntry_correct)) ))
(check-sat)
