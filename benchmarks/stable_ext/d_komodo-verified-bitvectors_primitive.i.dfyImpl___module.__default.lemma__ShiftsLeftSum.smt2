(set-option :print-success false)
(set-info :smt-lib-version 2.0)
(set-option :AUTO_CONFIG false)
(set-option :pp.bv_literals false)
(set-option :MODEL.V2 true)
(set-option :NNF.SK_HACK true)
(set-option :smt.MBQI false)
(set-option :smt.QI.EAGER_THRESHOLD 100)
(set-option :TYPE_CHECK true)
(set-option :smt.BV.REFLECT true)
(set-info :category "industrial")
(declare-sort |T@U| 0)
(declare-sort |T@T| 0)
(declare-fun real_pow (Real Real) Real)
(declare-fun UOrdering2 (|T@U| |T@U|) Bool)
(declare-fun UOrdering3 (|T@T| |T@U| |T@U|) Bool)
(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun Ctor (T@T) Int)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun boolType () T@T)
(declare-fun int_2_U (Int) T@U)
(declare-fun U_2_int (T@U) Int)
(declare-fun type (T@U) T@T)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun TyType () T@T)
(declare-fun TBool () T@U)
(declare-fun TChar () T@U)
(declare-fun TInt () T@U)
(declare-fun TReal () T@U)
(declare-fun TyTagType () T@T)
(declare-fun TagBool () T@U)
(declare-fun TagChar () T@U)
(declare-fun TagInt () T@U)
(declare-fun TagReal () T@U)
(declare-fun TagSet () T@U)
(declare-fun TagISet () T@U)
(declare-fun TagMultiSet () T@U)
(declare-fun TagSeq () T@U)
(declare-fun TagMap () T@U)
(declare-fun TagIMap () T@U)
(declare-fun TagClass () T@U)
(declare-fun ClassNameType () T@T)
(declare-fun NoTraitAtAll () T@U)
(declare-fun class._System.int () T@U)
(declare-fun class._System.bool () T@U)
(declare-fun class._System.set () T@U)
(declare-fun class._System.seq () T@U)
(declare-fun class._System.multiset () T@U)
(declare-fun FieldType (T@T) T@T)
(declare-fun FieldTypeInv0 (T@T) T@T)
(declare-fun alloc () T@U)
(declare-fun Tagclass._System.nat () T@U)
(declare-fun class._System.object () T@U)
(declare-fun Tagclass._System.object () T@U)
(declare-fun class._System.array () T@U)
(declare-fun Tagclass._System.array () T@U)
(declare-fun Tagclass._System.___hFunc0 () T@U)
(declare-fun class._System.__tuple_h2 () T@U)
(declare-fun DtCtorIdType () T@T)
(declare-fun |##_System._tuple#2._#Make2| () T@U)
(declare-fun Tagclass._System.__tuple_h2 () T@U)
(declare-fun Tagclass._System.___hFunc1 () T@U)
(declare-fun class._module.__default () T@U)
(declare-fun Tagclass._module.__default () T@U)
(declare-fun $$Language$Dafny () Bool)
(declare-fun TSet (T@U) T@U)
(declare-fun Inv0_TSet (T@U) T@U)
(declare-fun TISet (T@U) T@U)
(declare-fun Inv0_TISet (T@U) T@U)
(declare-fun TSeq (T@U) T@U)
(declare-fun Inv0_TSeq (T@U) T@U)
(declare-fun TMultiSet (T@U) T@U)
(declare-fun Inv0_TMultiSet (T@U) T@U)
(declare-fun TMap (T@U T@U) T@U)
(declare-fun Inv0_TMap (T@U) T@U)
(declare-fun Inv1_TMap (T@U) T@U)
(declare-fun TIMap (T@U T@U) T@U)
(declare-fun Inv0_TIMap (T@U) T@U)
(declare-fun Inv1_TIMap (T@U) T@U)
(declare-fun Tag (T@U) T@U)
(declare-fun LitInt (Int) Int)
(declare-fun BoxType () T@T)
(declare-fun $Box (T@U) T@U)
(declare-fun Lit (T@U) T@U)
(declare-fun LitReal (Real) Real)
(declare-fun charType () T@T)
(declare-fun |char#FromInt| (Int) T@U)
(declare-fun |char#ToInt| (T@U) Int)
(declare-fun $Unbox (T@T T@U) T@U)
(declare-fun $IsBox (T@U T@U) Bool)
(declare-fun $Is (T@U T@U) Bool)
(declare-fun MapType0Type (T@T T@T) T@T)
(declare-fun MapType0TypeInv0 (T@T) T@T)
(declare-fun MapType0TypeInv1 (T@T) T@T)
(declare-fun MapType0Select (T@U T@U) T@U)
(declare-fun MapType0Store (T@U T@U T@U) T@U)
(declare-fun SeqType (T@T) T@T)
(declare-fun SeqTypeInv0 (T@T) T@T)
(declare-fun MapType (T@T T@T) T@T)
(declare-fun MapTypeInv0 (T@T) T@T)
(declare-fun MapTypeInv1 (T@T) T@T)
(declare-fun IMapType (T@T T@T) T@T)
(declare-fun IMapTypeInv0 (T@T) T@T)
(declare-fun IMapTypeInv1 (T@T) T@T)
(declare-fun MapType1Type (T@T) T@T)
(declare-fun MapType1TypeInv0 (T@T) T@T)
(declare-fun MapType1Select (T@U T@U T@U) T@U)
(declare-fun MapType1Store (T@U T@U T@U T@U) T@U)
(declare-fun refType () T@T)
(declare-fun $IsAllocBox (T@U T@U T@U) Bool)
(declare-fun $IsAlloc (T@U T@U T@U) Bool)
(declare-fun $IsGoodMultiSet (T@U) Bool)
(declare-fun |Seq#Index| (T@U Int) T@U)
(declare-fun |Seq#Length| (T@U) Int)
(declare-fun |Map#Elements| (T@U) T@U)
(declare-fun |Map#Domain| (T@U) T@U)
(declare-fun |IMap#Elements| (T@U) T@U)
(declare-fun |IMap#Domain| (T@U) T@U)
(declare-fun TypeTuple (T@U T@U) T@U)
(declare-fun TypeTupleCar (T@U) T@U)
(declare-fun TypeTupleCdr (T@U) T@U)
(declare-fun SetRef_to_SetBox (T@U) T@U)
(declare-fun Tclass._System.object () T@U)
(declare-fun DatatypeTypeType () T@T)
(declare-fun BoxRank (T@U) Int)
(declare-fun DtRank (T@U) Int)
(declare-fun LayerTypeType () T@T)
(declare-fun AtLayer (T@U T@U) T@U)
(declare-fun $LS (T@U) T@U)
(declare-fun IndexField (Int) T@U)
(declare-fun FDim (T@U) Int)
(declare-fun IndexField_Inverse (T@U) Int)
(declare-fun MultiIndexField (T@U Int) T@U)
(declare-fun MultiIndexField_Inverse0 (T@U) T@U)
(declare-fun MultiIndexField_Inverse1 (T@U) Int)
(declare-fun NameFamilyType () T@T)
(declare-fun FieldOfDecl (T@T T@U T@U) T@U)
(declare-fun DeclType (T@U) T@U)
(declare-fun DeclName (T@U) T@U)
(declare-fun $HeapSucc (T@U T@U) Bool)
(declare-fun $IsGhostField (T@U) Bool)
(declare-fun _System.array.Length (T@U) Int)
(declare-fun q@Int (Real) Int)
(declare-fun q@Real (Int) Real)
(declare-fun $IsGoodHeap (T@U) Bool)
(declare-fun $HeapSuccGhost (T@U T@U) Bool)
(declare-fun |Set#Card| (T@U) Int)
(declare-fun |Set#Empty| (T@T) T@U)
(declare-fun |Set#Singleton| (T@U) T@U)
(declare-fun |Set#UnionOne| (T@U T@U) T@U)
(declare-fun |Set#Union| (T@U T@U) T@U)
(declare-fun |Set#Difference| (T@U T@U) T@U)
(declare-fun |Set#Disjoint| (T@U T@U) Bool)
(declare-fun |Set#Intersection| (T@U T@U) T@U)
(declare-fun |Set#Subset| (T@U T@U) Bool)
(declare-fun |Set#Equal| (T@U T@U) Bool)
(declare-fun |ISet#Empty| (T@T) T@U)
(declare-fun |ISet#UnionOne| (T@U T@U) T@U)
(declare-fun |ISet#Union| (T@U T@U) T@U)
(declare-fun |ISet#Difference| (T@U T@U) T@U)
(declare-fun |ISet#Disjoint| (T@U T@U) Bool)
(declare-fun |ISet#Intersection| (T@U T@U) T@U)
(declare-fun |ISet#Subset| (T@U T@U) Bool)
(declare-fun |ISet#Equal| (T@U T@U) Bool)
(declare-fun |Math#min| (Int Int) Int)
(declare-fun |Math#clip| (Int) Int)
(declare-fun |MultiSet#Card| (T@U) Int)
(declare-fun |MultiSet#Empty| (T@T) T@U)
(declare-fun |MultiSet#Singleton| (T@U) T@U)
(declare-fun |MultiSet#UnionOne| (T@U T@U) T@U)
(declare-fun |MultiSet#Union| (T@U T@U) T@U)
(declare-fun |MultiSet#Intersection| (T@U T@U) T@U)
(declare-fun |MultiSet#Difference| (T@U T@U) T@U)
(declare-fun |MultiSet#Subset| (T@U T@U) Bool)
(declare-fun |MultiSet#Equal| (T@U T@U) Bool)
(declare-fun |MultiSet#Disjoint| (T@U T@U) Bool)
(declare-fun |MultiSet#FromSet| (T@U) T@U)
(declare-fun |MultiSet#FromSeq| (T@U) T@U)
(declare-fun |Seq#Build| (T@U T@U) T@U)
(declare-fun |Seq#Empty| (T@T) T@U)
(declare-fun |Seq#Append| (T@U T@U) T@U)
(declare-fun |Seq#Update| (T@U Int T@U) T@U)
(declare-fun |Seq#Singleton| (T@U) T@U)
(declare-fun |Seq#Build_inv0| (T@U) T@U)
(declare-fun |Seq#Build_inv1| (T@U) T@U)
(declare-fun |Seq#Contains| (T@U T@U) Bool)
(declare-fun |Seq#Take| (T@U Int) T@U)
(declare-fun |Seq#Drop| (T@U Int) T@U)
(declare-fun |Seq#Equal| (T@U T@U) Bool)
(declare-fun |Seq#SameUntil| (T@U T@U Int) Bool)
(declare-fun |Seq#FromArray| (T@U T@U) T@U)
(declare-fun |Seq#Rank| (T@U) Int)
(declare-fun |Map#Card| (T@U) Int)
(declare-fun |Map#Values| (T@U) T@U)
(declare-fun |Map#Items| (T@U) T@U)
(declare-fun _System.__tuple_h2._0 (T@U) T@U)
(declare-fun _System.__tuple_h2._1 (T@U) T@U)
(declare-fun |Map#Empty| (T@T T@T) T@U)
(declare-fun |Map#Glue| (T@U T@U T@U) T@U)
(declare-fun |Map#Build| (T@U T@U T@U) T@U)
(declare-fun |Map#Equal| (T@U T@U) Bool)
(declare-fun |Map#Disjoint| (T@U T@U) Bool)
(declare-fun |IMap#Values| (T@U) T@U)
(declare-fun |IMap#Items| (T@U) T@U)
(declare-fun |IMap#Empty| (T@T T@T) T@U)
(declare-fun |IMap#Glue| (T@U T@U T@U) T@U)
(declare-fun |IMap#Build| (T@U T@U T@U) T@U)
(declare-fun |IMap#Equal| (T@U T@U) Bool)
(declare-fun INTERNAL_add_boogie (Int Int) Int)
(declare-fun INTERNAL_sub_boogie (Int Int) Int)
(declare-fun INTERNAL_mul_boogie (Int Int) Int)
(declare-fun INTERNAL_div_boogie (Int Int) Int)
(declare-fun INTERNAL_mod_boogie (Int Int) Int)
(declare-fun INTERNAL_lt_boogie (Int Int) Bool)
(declare-fun INTERNAL_le_boogie (Int Int) Bool)
(declare-fun INTERNAL_gt_boogie (Int Int) Bool)
(declare-fun INTERNAL_ge_boogie (Int Int) Bool)
(declare-fun nat_from_bv32 ((_ BitVec 32)) Int)
(declare-fun Tclass._System.nat () T@U)
(declare-fun null () T@U)
(declare-fun Tclass._System.array (T@U) T@U)
(declare-fun Tclass._System.array_0 (T@U) T@U)
(declare-fun dtype (T@U) T@U)
(declare-fun Tclass._System.___hFunc0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc0_0 (T@U) T@U)
(declare-fun HandleTypeType () T@T)
(declare-fun Apply0 (T@U T@U T@U) T@U)
(declare-fun Handle0 (T@U T@U T@U) T@U)
(declare-fun Requires0 (T@U T@U T@U) Bool)
(declare-fun Reads0 (T@U T@U T@U) T@U)
(declare-fun |#_System._tuple#2._#Make2| (T@U T@U) T@U)
(declare-fun DatatypeCtorId (T@U) T@U)
(declare-fun _System.__tuple_h2.___hMake2_q (T@U) Bool)
(declare-fun Tclass._System.__tuple_h2 (T@U T@U) T@U)
(declare-fun Tclass._System.__tuple_h2_0 (T@U) T@U)
(declare-fun Tclass._System.__tuple_h2_1 (T@U) T@U)
(declare-fun |$IsA#_System.__tuple_h2| (T@U) Bool)
(declare-fun Tclass._System.___hFunc1 (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1_1 (T@U) T@U)
(declare-fun MapType2Type (T@T T@T T@T) T@T)
(declare-fun MapType2TypeInv0 (T@T) T@T)
(declare-fun MapType2TypeInv1 (T@T) T@T)
(declare-fun MapType2TypeInv2 (T@T) T@T)
(declare-fun MapType2Select (T@U T@U T@U) T@U)
(declare-fun MapType2Store (T@U T@U T@U T@U) T@U)
(declare-fun Apply1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Handle1 (T@U T@U T@U) T@U)
(declare-fun Requires1 (T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._module.__default () T@U)
(declare-fun MapType3Type (T@T T@T) T@T)
(declare-fun MapType3TypeInv0 (T@T) T@T)
(declare-fun MapType3TypeInv1 (T@T) T@T)
(declare-fun MapType3Select (T@U T@U T@U) T@U)
(declare-fun MapType3Store (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#0| (T@U T@U T@U) T@U)
(declare-fun |lambda#1| (T@U T@U T@U) T@U)
(declare-fun |lambda#2| (T@U T@U T@U) T@U)
(declare-fun |lambda#3| (T@U T@U T@U) T@U)
(assert  (and (and (and (and (and (and (and (and (and (and (and (= (Ctor intType) 0) (= (Ctor realType) 1)) (= (Ctor boolType) 2)) (forall ((arg0 Int) ) (! (= (U_2_int (int_2_U arg0)) arg0) :qid |typeInv:U_2_int| :pattern ( (int_2_U arg0)) ))) (forall ((x T@U) ) (!  (=> (= (type x) intType) (= (int_2_U (U_2_int x)) x)) :qid |cast:U_2_int| :pattern ( (U_2_int x)) ))) (forall ((arg0@@0 Int) ) (! (= (type (int_2_U arg0@@0)) intType) :qid |funType:int_2_U| :pattern ( (int_2_U arg0@@0)) ))) (forall ((arg0@@1 Real) ) (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1) :qid |typeInv:U_2_real| :pattern ( (real_2_U arg0@@1)) ))) (forall ((x@@0 T@U) ) (!  (=> (= (type x@@0) realType) (= (real_2_U (U_2_real x@@0)) x@@0)) :qid |cast:U_2_real| :pattern ( (U_2_real x@@0)) ))) (forall ((arg0@@2 Real) ) (! (= (type (real_2_U arg0@@2)) realType) :qid |funType:real_2_U| :pattern ( (real_2_U arg0@@2)) ))) (forall ((arg0@@3 Bool) ) (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3) :qid |typeInv:U_2_bool| :pattern ( (bool_2_U arg0@@3)) ))) (forall ((x@@1 T@U) ) (!  (=> (= (type x@@1) boolType) (= (bool_2_U (U_2_bool x@@1)) x@@1)) :qid |cast:U_2_bool| :pattern ( (U_2_bool x@@1)) ))) (forall ((arg0@@4 Bool) ) (! (= (type (bool_2_U arg0@@4)) boolType) :qid |funType:bool_2_U| :pattern ( (bool_2_U arg0@@4)) ))))
(assert (forall ((x@@2 T@U) ) (! (UOrdering2 x@@2 x@@2) :qid |bg:subtype-refl| :no-pattern (U_2_int x@@2) :no-pattern (U_2_bool x@@2) )))
(assert (forall ((x@@3 T@U) (y T@U) (z T@U) ) (! (let ((alpha (type x@@3))) (=> (and (and (= (type y) alpha) (= (type z) alpha)) (and (UOrdering2 x@@3 y) (UOrdering2 y z))) (UOrdering2 x@@3 z))) :qid |bg:subtype-trans| :pattern ( (UOrdering2 x@@3 y) (UOrdering2 y z)) )))
(assert (forall ((x@@4 T@U) (y@@0 T@U) ) (! (let ((alpha@@0 (type x@@4))) (=> (= (type y@@0) alpha@@0) (=> (and (UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4)) (= x@@4 y@@0)))) :qid |bg:subtype-antisymm| :pattern ( (UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4)) )))
(assert  (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (Ctor TyType) 3) (= (type TBool) TyType)) (= (type TChar) TyType)) (= (type TInt) TyType)) (= (type TReal) TyType)) (= (Ctor TyTagType) 4)) (= (type TagBool) TyTagType)) (= (type TagChar) TyTagType)) (= (type TagInt) TyTagType)) (= (type TagReal) TyTagType)) (= (type TagSet) TyTagType)) (= (type TagISet) TyTagType)) (= (type TagMultiSet) TyTagType)) (= (type TagSeq) TyTagType)) (= (type TagMap) TyTagType)) (= (type TagIMap) TyTagType)) (= (type TagClass) TyTagType)) (= (Ctor ClassNameType) 5)) (= (type NoTraitAtAll) ClassNameType)) (= (type class._System.int) ClassNameType)) (= (type class._System.bool) ClassNameType)) (= (type class._System.set) ClassNameType)) (= (type class._System.seq) ClassNameType)) (= (type class._System.multiset) ClassNameType)) (forall ((arg0@@5 T@T) ) (! (= (Ctor (FieldType arg0@@5)) 6) :qid |ctor:FieldType| ))) (forall ((arg0@@6 T@T) ) (! (= (FieldTypeInv0 (FieldType arg0@@6)) arg0@@6) :qid |typeInv:FieldTypeInv0| :pattern ( (FieldType arg0@@6)) ))) (= (type alloc) (FieldType boolType))) (= (type Tagclass._System.nat) TyTagType)) (= (type class._System.object) ClassNameType)) (= (type Tagclass._System.object) TyTagType)) (= (type class._System.array) ClassNameType)) (= (type Tagclass._System.array) TyTagType)) (= (type Tagclass._System.___hFunc0) TyTagType)) (= (type class._System.__tuple_h2) ClassNameType)) (= (Ctor DtCtorIdType) 7)) (= (type |##_System._tuple#2._#Make2|) DtCtorIdType)) (= (type Tagclass._System.__tuple_h2) TyTagType)) (= (type Tagclass._System.___hFunc1) TyTagType)) (= (type class._module.__default) ClassNameType)) (= (type Tagclass._module.__default) TyTagType)))
(assert (distinct TBool TChar TInt TReal TagBool TagChar TagInt TagReal TagSet TagISet TagMultiSet TagSeq TagMap TagIMap TagClass NoTraitAtAll class._System.int class._System.bool class._System.set class._System.seq class._System.multiset alloc Tagclass._System.nat class._System.object Tagclass._System.object class._System.array Tagclass._System.array Tagclass._System.___hFunc0 class._System.__tuple_h2 |##_System._tuple#2._#Make2| Tagclass._System.__tuple_h2 Tagclass._System.___hFunc1 class._module.__default Tagclass._module.__default) )
(assert $$Language$Dafny)
(assert  (and (forall ((arg0@@7 T@U) ) (! (= (type (TSet arg0@@7)) TyType) :qid |funType:TSet| :pattern ( (TSet arg0@@7)) )) (forall ((arg0@@8 T@U) ) (! (= (type (Inv0_TSet arg0@@8)) TyType) :qid |funType:Inv0_TSet| :pattern ( (Inv0_TSet arg0@@8)) ))))
(assert (forall ((t T@U) ) (!  (=> (= (type t) TyType) (= (Inv0_TSet (TSet t)) t)) :qid |DafnyPre.31:15| :skolemid |292| :pattern ( (TSet t)) )))
(assert  (and (forall ((arg0@@9 T@U) ) (! (= (type (TISet arg0@@9)) TyType) :qid |funType:TISet| :pattern ( (TISet arg0@@9)) )) (forall ((arg0@@10 T@U) ) (! (= (type (Inv0_TISet arg0@@10)) TyType) :qid |funType:Inv0_TISet| :pattern ( (Inv0_TISet arg0@@10)) ))))
(assert (forall ((t@@0 T@U) ) (!  (=> (= (type t@@0) TyType) (= (Inv0_TISet (TISet t@@0)) t@@0)) :qid |DafnyPre.33:15| :skolemid |293| :pattern ( (TISet t@@0)) )))
(assert  (and (forall ((arg0@@11 T@U) ) (! (= (type (TSeq arg0@@11)) TyType) :qid |funType:TSeq| :pattern ( (TSeq arg0@@11)) )) (forall ((arg0@@12 T@U) ) (! (= (type (Inv0_TSeq arg0@@12)) TyType) :qid |funType:Inv0_TSeq| :pattern ( (Inv0_TSeq arg0@@12)) ))))
(assert (forall ((t@@1 T@U) ) (!  (=> (= (type t@@1) TyType) (= (Inv0_TSeq (TSeq t@@1)) t@@1)) :qid |DafnyPre.35:15| :skolemid |294| :pattern ( (TSeq t@@1)) )))
(assert  (and (forall ((arg0@@13 T@U) ) (! (= (type (TMultiSet arg0@@13)) TyType) :qid |funType:TMultiSet| :pattern ( (TMultiSet arg0@@13)) )) (forall ((arg0@@14 T@U) ) (! (= (type (Inv0_TMultiSet arg0@@14)) TyType) :qid |funType:Inv0_TMultiSet| :pattern ( (Inv0_TMultiSet arg0@@14)) ))))
(assert (forall ((t@@2 T@U) ) (!  (=> (= (type t@@2) TyType) (= (Inv0_TMultiSet (TMultiSet t@@2)) t@@2)) :qid |DafnyPre.37:15| :skolemid |295| :pattern ( (TMultiSet t@@2)) )))
(assert  (and (forall ((arg0@@15 T@U) (arg1 T@U) ) (! (= (type (TMap arg0@@15 arg1)) TyType) :qid |funType:TMap| :pattern ( (TMap arg0@@15 arg1)) )) (forall ((arg0@@16 T@U) ) (! (= (type (Inv0_TMap arg0@@16)) TyType) :qid |funType:Inv0_TMap| :pattern ( (Inv0_TMap arg0@@16)) ))))
(assert (forall ((t@@3 T@U) (u T@U) ) (!  (=> (and (= (type t@@3) TyType) (= (type u) TyType)) (= (Inv0_TMap (TMap t@@3 u)) t@@3)) :qid |DafnyPre.40:15| :skolemid |296| :pattern ( (TMap t@@3 u)) )))
(assert (forall ((arg0@@17 T@U) ) (! (= (type (Inv1_TMap arg0@@17)) TyType) :qid |funType:Inv1_TMap| :pattern ( (Inv1_TMap arg0@@17)) )))
(assert (forall ((t@@4 T@U) (u@@0 T@U) ) (!  (=> (and (= (type t@@4) TyType) (= (type u@@0) TyType)) (= (Inv1_TMap (TMap t@@4 u@@0)) u@@0)) :qid |DafnyPre.41:15| :skolemid |297| :pattern ( (TMap t@@4 u@@0)) )))
(assert  (and (forall ((arg0@@18 T@U) (arg1@@0 T@U) ) (! (= (type (TIMap arg0@@18 arg1@@0)) TyType) :qid |funType:TIMap| :pattern ( (TIMap arg0@@18 arg1@@0)) )) (forall ((arg0@@19 T@U) ) (! (= (type (Inv0_TIMap arg0@@19)) TyType) :qid |funType:Inv0_TIMap| :pattern ( (Inv0_TIMap arg0@@19)) ))))
(assert (forall ((t@@5 T@U) (u@@1 T@U) ) (!  (=> (and (= (type t@@5) TyType) (= (type u@@1) TyType)) (= (Inv0_TIMap (TIMap t@@5 u@@1)) t@@5)) :qid |DafnyPre.44:15| :skolemid |298| :pattern ( (TIMap t@@5 u@@1)) )))
(assert (forall ((arg0@@20 T@U) ) (! (= (type (Inv1_TIMap arg0@@20)) TyType) :qid |funType:Inv1_TIMap| :pattern ( (Inv1_TIMap arg0@@20)) )))
(assert (forall ((t@@6 T@U) (u@@2 T@U) ) (!  (=> (and (= (type t@@6) TyType) (= (type u@@2) TyType)) (= (Inv1_TIMap (TIMap t@@6 u@@2)) u@@2)) :qid |DafnyPre.45:15| :skolemid |299| :pattern ( (TIMap t@@6 u@@2)) )))
(assert (forall ((arg0@@21 T@U) ) (! (= (type (Tag arg0@@21)) TyTagType) :qid |funType:Tag| :pattern ( (Tag arg0@@21)) )))
(assert (= (Tag TBool) TagBool))
(assert (= (Tag TChar) TagChar))
(assert (= (Tag TInt) TagInt))
(assert (= (Tag TReal) TagReal))
(assert (forall ((t@@7 T@U) ) (!  (=> (= (type t@@7) TyType) (= (Tag (TSet t@@7)) TagSet)) :qid |DafnyPre.69:15| :skolemid |300| :pattern ( (TSet t@@7)) )))
(assert (forall ((t@@8 T@U) ) (!  (=> (= (type t@@8) TyType) (= (Tag (TISet t@@8)) TagISet)) :qid |DafnyPre.70:15| :skolemid |301| :pattern ( (TISet t@@8)) )))
(assert (forall ((t@@9 T@U) ) (!  (=> (= (type t@@9) TyType) (= (Tag (TMultiSet t@@9)) TagMultiSet)) :qid |DafnyPre.71:15| :skolemid |302| :pattern ( (TMultiSet t@@9)) )))
(assert (forall ((t@@10 T@U) ) (!  (=> (= (type t@@10) TyType) (= (Tag (TSeq t@@10)) TagSeq)) :qid |DafnyPre.72:15| :skolemid |303| :pattern ( (TSeq t@@10)) )))
(assert (forall ((t@@11 T@U) (u@@3 T@U) ) (!  (=> (and (= (type t@@11) TyType) (= (type u@@3) TyType)) (= (Tag (TMap t@@11 u@@3)) TagMap)) :qid |DafnyPre.73:15| :skolemid |304| :pattern ( (TMap t@@11 u@@3)) )))
(assert (forall ((t@@12 T@U) (u@@4 T@U) ) (!  (=> (and (= (type t@@12) TyType) (= (type u@@4) TyType)) (= (Tag (TIMap t@@12 u@@4)) TagIMap)) :qid |DafnyPre.74:15| :skolemid |305| :pattern ( (TIMap t@@12 u@@4)) )))
(assert (forall ((x@@5 Int) ) (! (= (LitInt x@@5) x@@5) :qid |DafnyPre.79:29| :skolemid |306| :pattern ( (LitInt x@@5)) )))
(assert  (and (and (= (Ctor BoxType) 8) (forall ((arg0@@22 T@U) ) (! (= (type ($Box arg0@@22)) BoxType) :qid |funType:$Box| :pattern ( ($Box arg0@@22)) ))) (forall ((arg0@@23 T@U) ) (! (let ((T (type arg0@@23))) (= (type (Lit arg0@@23)) T)) :qid |funType:Lit| :pattern ( (Lit arg0@@23)) ))))
(assert (forall ((x@@6 Int) ) (! (= ($Box (int_2_U (LitInt x@@6))) (Lit ($Box (int_2_U x@@6)))) :qid |DafnyPre.80:15| :skolemid |307| :pattern ( ($Box (int_2_U (LitInt x@@6)))) )))
(assert (forall ((x@@7 Real) ) (! (= (LitReal x@@7) x@@7) :qid |DafnyPre.81:30| :skolemid |308| :pattern ( (LitReal x@@7)) )))
(assert (forall ((x@@8 Real) ) (! (= ($Box (real_2_U (LitReal x@@8))) (Lit ($Box (real_2_U x@@8)))) :qid |DafnyPre.82:15| :skolemid |309| :pattern ( ($Box (real_2_U (LitReal x@@8)))) )))
(assert (forall ((x@@9 T@U) ) (! (= (Lit x@@9) x@@9) :qid |DafnyPre.83:29| :skolemid |310| :pattern ( (Lit x@@9)) )))
(assert (forall ((x@@10 T@U) ) (! (= ($Box (Lit x@@10)) (Lit ($Box x@@10))) :qid |DafnyPre.84:18| :skolemid |311| :pattern ( ($Box (Lit x@@10))) )))
(assert  (and (= (Ctor charType) 9) (forall ((arg0@@24 Int) ) (! (= (type (|char#FromInt| arg0@@24)) charType) :qid |funType:char#FromInt| :pattern ( (|char#FromInt| arg0@@24)) ))))
(assert (forall ((ch T@U) ) (!  (=> (= (type ch) charType) (= (|char#FromInt| (|char#ToInt| ch)) ch)) :qid |DafnyPre.93:15| :skolemid |312| :pattern ( (|char#ToInt| ch)) )))
(assert (forall ((n Int) ) (!  (=> (and (<= 0 n) (< n 65536)) (= (|char#ToInt| (|char#FromInt| n)) n)) :qid |DafnyPre.96:15| :skolemid |313| :pattern ( (|char#FromInt| n)) )))
(assert (forall ((T@@0 T@T) (arg0@@25 T@U) ) (! (= (type ($Unbox T@@0 arg0@@25)) T@@0) :qid |funType:$Unbox| :pattern ( ($Unbox T@@0 arg0@@25)) )))
(assert (forall ((x@@11 T@U) ) (! (let ((T@@1 (type x@@11))) (= ($Unbox T@@1 ($Box x@@11)) x@@11)) :qid |DafnyPre.124:18| :skolemid |314| :pattern ( ($Box x@@11)) )))
(assert (forall ((bx T@U) ) (!  (=> (and (= (type bx) BoxType) ($IsBox bx TInt)) (and (= ($Box ($Unbox intType bx)) bx) ($Is ($Unbox intType bx) TInt))) :qid |DafnyPre.126:15| :skolemid |315| :pattern ( ($IsBox bx TInt)) )))
(assert (forall ((bx@@0 T@U) ) (!  (=> (and (= (type bx@@0) BoxType) ($IsBox bx@@0 TReal)) (and (= ($Box ($Unbox realType bx@@0)) bx@@0) ($Is ($Unbox realType bx@@0) TReal))) :qid |DafnyPre.129:15| :skolemid |316| :pattern ( ($IsBox bx@@0 TReal)) )))
(assert (forall ((bx@@1 T@U) ) (!  (=> (and (= (type bx@@1) BoxType) ($IsBox bx@@1 TBool)) (and (= ($Box ($Unbox boolType bx@@1)) bx@@1) ($Is ($Unbox boolType bx@@1) TBool))) :qid |DafnyPre.132:15| :skolemid |317| :pattern ( ($IsBox bx@@1 TBool)) )))
(assert (forall ((bx@@2 T@U) ) (!  (=> (and (= (type bx@@2) BoxType) ($IsBox bx@@2 TChar)) (and (= ($Box ($Unbox charType bx@@2)) bx@@2) ($Is ($Unbox charType bx@@2) TChar))) :qid |DafnyPre.135:15| :skolemid |318| :pattern ( ($IsBox bx@@2 TChar)) )))
(assert  (and (and (and (and (and (and (forall ((arg0@@26 T@T) (arg1@@1 T@T) ) (! (= (Ctor (MapType0Type arg0@@26 arg1@@1)) 10) :qid |ctor:MapType0Type| )) (forall ((arg0@@27 T@T) (arg1@@2 T@T) ) (! (= (MapType0TypeInv0 (MapType0Type arg0@@27 arg1@@2)) arg0@@27) :qid |typeInv:MapType0TypeInv0| :pattern ( (MapType0Type arg0@@27 arg1@@2)) ))) (forall ((arg0@@28 T@T) (arg1@@3 T@T) ) (! (= (MapType0TypeInv1 (MapType0Type arg0@@28 arg1@@3)) arg1@@3) :qid |typeInv:MapType0TypeInv1| :pattern ( (MapType0Type arg0@@28 arg1@@3)) ))) (forall ((arg0@@29 T@U) (arg1@@4 T@U) ) (! (let ((aVar1 (MapType0TypeInv1 (type arg0@@29)))) (= (type (MapType0Select arg0@@29 arg1@@4)) aVar1)) :qid |funType:MapType0Select| :pattern ( (MapType0Select arg0@@29 arg1@@4)) ))) (forall ((arg0@@30 T@U) (arg1@@5 T@U) (arg2 T@U) ) (! (let ((aVar1@@0 (type arg2))) (let ((aVar0 (type arg1@@5))) (= (type (MapType0Store arg0@@30 arg1@@5 arg2)) (MapType0Type aVar0 aVar1@@0)))) :qid |funType:MapType0Store| :pattern ( (MapType0Store arg0@@30 arg1@@5 arg2)) ))) (forall ((m T@U) (x0 T@U) (val T@U) ) (! (let ((aVar1@@1 (MapType0TypeInv1 (type m)))) (=> (= (type val) aVar1@@1) (= (MapType0Select (MapType0Store m x0 val) x0) val))) :qid |mapAx0:MapType0Select| :weight 0 ))) (and (forall ((val@@0 T@U) (m@@0 T@U) (x0@@0 T@U) (y0 T@U) ) (!  (or (= x0@@0 y0) (= (MapType0Select (MapType0Store m@@0 x0@@0 val@@0) y0) (MapType0Select m@@0 y0))) :qid |mapAx1:MapType0Select:0| :weight 0 )) (forall ((val@@1 T@U) (m@@1 T@U) (x0@@1 T@U) (y0@@0 T@U) ) (!  (or true (= (MapType0Select (MapType0Store m@@1 x0@@1 val@@1) y0@@0) (MapType0Select m@@1 y0@@0))) :qid |mapAx2:MapType0Select| :weight 0 )))))
(assert (forall ((bx@@3 T@U) (t@@13 T@U) ) (!  (=> (and (and (= (type bx@@3) BoxType) (= (type t@@13) TyType)) ($IsBox bx@@3 (TSet t@@13))) (and (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@3)) bx@@3) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@3) (TSet t@@13)))) :qid |DafnyPre.138:15| :skolemid |319| :pattern ( ($IsBox bx@@3 (TSet t@@13))) )))
(assert (forall ((bx@@4 T@U) (t@@14 T@U) ) (!  (=> (and (and (= (type bx@@4) BoxType) (= (type t@@14) TyType)) ($IsBox bx@@4 (TISet t@@14))) (and (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@4)) bx@@4) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@4) (TISet t@@14)))) :qid |DafnyPre.141:15| :skolemid |320| :pattern ( ($IsBox bx@@4 (TISet t@@14))) )))
(assert (forall ((bx@@5 T@U) (t@@15 T@U) ) (!  (=> (and (and (= (type bx@@5) BoxType) (= (type t@@15) TyType)) ($IsBox bx@@5 (TMultiSet t@@15))) (and (= ($Box ($Unbox (MapType0Type BoxType intType) bx@@5)) bx@@5) ($Is ($Unbox (MapType0Type BoxType intType) bx@@5) (TMultiSet t@@15)))) :qid |DafnyPre.144:15| :skolemid |321| :pattern ( ($IsBox bx@@5 (TMultiSet t@@15))) )))
(assert  (and (forall ((arg0@@31 T@T) ) (! (= (Ctor (SeqType arg0@@31)) 11) :qid |ctor:SeqType| )) (forall ((arg0@@32 T@T) ) (! (= (SeqTypeInv0 (SeqType arg0@@32)) arg0@@32) :qid |typeInv:SeqTypeInv0| :pattern ( (SeqType arg0@@32)) ))))
(assert (forall ((bx@@6 T@U) (t@@16 T@U) ) (!  (=> (and (and (= (type bx@@6) BoxType) (= (type t@@16) TyType)) ($IsBox bx@@6 (TSeq t@@16))) (and (= ($Box ($Unbox (SeqType BoxType) bx@@6)) bx@@6) ($Is ($Unbox (SeqType BoxType) bx@@6) (TSeq t@@16)))) :qid |DafnyPre.147:15| :skolemid |322| :pattern ( ($IsBox bx@@6 (TSeq t@@16))) )))
(assert  (and (and (forall ((arg0@@33 T@T) (arg1@@6 T@T) ) (! (= (Ctor (MapType arg0@@33 arg1@@6)) 12) :qid |ctor:MapType| )) (forall ((arg0@@34 T@T) (arg1@@7 T@T) ) (! (= (MapTypeInv0 (MapType arg0@@34 arg1@@7)) arg0@@34) :qid |typeInv:MapTypeInv0| :pattern ( (MapType arg0@@34 arg1@@7)) ))) (forall ((arg0@@35 T@T) (arg1@@8 T@T) ) (! (= (MapTypeInv1 (MapType arg0@@35 arg1@@8)) arg1@@8) :qid |typeInv:MapTypeInv1| :pattern ( (MapType arg0@@35 arg1@@8)) ))))
(assert (forall ((bx@@7 T@U) (s T@U) (t@@17 T@U) ) (!  (=> (and (and (and (= (type bx@@7) BoxType) (= (type s) TyType)) (= (type t@@17) TyType)) ($IsBox bx@@7 (TMap s t@@17))) (and (= ($Box ($Unbox (MapType BoxType BoxType) bx@@7)) bx@@7) ($Is ($Unbox (MapType BoxType BoxType) bx@@7) (TMap s t@@17)))) :qid |DafnyPre.150:15| :skolemid |323| :pattern ( ($IsBox bx@@7 (TMap s t@@17))) )))
(assert  (and (and (forall ((arg0@@36 T@T) (arg1@@9 T@T) ) (! (= (Ctor (IMapType arg0@@36 arg1@@9)) 13) :qid |ctor:IMapType| )) (forall ((arg0@@37 T@T) (arg1@@10 T@T) ) (! (= (IMapTypeInv0 (IMapType arg0@@37 arg1@@10)) arg0@@37) :qid |typeInv:IMapTypeInv0| :pattern ( (IMapType arg0@@37 arg1@@10)) ))) (forall ((arg0@@38 T@T) (arg1@@11 T@T) ) (! (= (IMapTypeInv1 (IMapType arg0@@38 arg1@@11)) arg1@@11) :qid |typeInv:IMapTypeInv1| :pattern ( (IMapType arg0@@38 arg1@@11)) ))))
(assert (forall ((bx@@8 T@U) (s@@0 T@U) (t@@18 T@U) ) (!  (=> (and (and (and (= (type bx@@8) BoxType) (= (type s@@0) TyType)) (= (type t@@18) TyType)) ($IsBox bx@@8 (TIMap s@@0 t@@18))) (and (= ($Box ($Unbox (IMapType BoxType BoxType) bx@@8)) bx@@8) ($Is ($Unbox (IMapType BoxType BoxType) bx@@8) (TIMap s@@0 t@@18)))) :qid |DafnyPre.153:15| :skolemid |324| :pattern ( ($IsBox bx@@8 (TIMap s@@0 t@@18))) )))
(assert (forall ((v T@U) (t@@19 T@U) ) (!  (=> (= (type t@@19) TyType) (and (=> ($IsBox ($Box v) t@@19) ($Is v t@@19)) (=> ($Is v t@@19) ($IsBox ($Box v) t@@19)))) :qid |DafnyPre.157:18| :skolemid |325| :pattern ( ($IsBox ($Box v) t@@19)) )))
(assert  (and (and (and (and (and (and (forall ((arg0@@39 T@T) ) (! (= (Ctor (MapType1Type arg0@@39)) 14) :qid |ctor:MapType1Type| )) (forall ((arg0@@40 T@T) ) (! (= (MapType1TypeInv0 (MapType1Type arg0@@40)) arg0@@40) :qid |typeInv:MapType1TypeInv0| :pattern ( (MapType1Type arg0@@40)) ))) (forall ((arg0@@41 T@U) (arg1@@12 T@U) (arg2@@0 T@U) ) (! (let ((alpha@@1 (FieldTypeInv0 (type arg2@@0)))) (= (type (MapType1Select arg0@@41 arg1@@12 arg2@@0)) alpha@@1)) :qid |funType:MapType1Select| :pattern ( (MapType1Select arg0@@41 arg1@@12 arg2@@0)) ))) (forall ((arg0@@42 T@U) (arg1@@13 T@U) (arg2@@1 T@U) (arg3 T@U) ) (! (let ((aVar0@@0 (type arg1@@13))) (= (type (MapType1Store arg0@@42 arg1@@13 arg2@@1 arg3)) (MapType1Type aVar0@@0))) :qid |funType:MapType1Store| :pattern ( (MapType1Store arg0@@42 arg1@@13 arg2@@1 arg3)) ))) (forall ((m@@2 T@U) (x0@@2 T@U) (x1 T@U) (val@@2 T@U) ) (! (let ((alpha@@2 (FieldTypeInv0 (type x1)))) (=> (= (type val@@2) alpha@@2) (= (MapType1Select (MapType1Store m@@2 x0@@2 x1 val@@2) x0@@2 x1) val@@2))) :qid |mapAx0:MapType1Select| :weight 0 ))) (and (and (forall ((val@@3 T@U) (m@@3 T@U) (x0@@3 T@U) (x1@@0 T@U) (y0@@1 T@U) (y1 T@U) ) (!  (or (= x0@@3 y0@@1) (= (MapType1Select (MapType1Store m@@3 x0@@3 x1@@0 val@@3) y0@@1 y1) (MapType1Select m@@3 y0@@1 y1))) :qid |mapAx1:MapType1Select:0| :weight 0 )) (forall ((val@@4 T@U) (m@@4 T@U) (x0@@4 T@U) (x1@@1 T@U) (y0@@2 T@U) (y1@@0 T@U) ) (!  (or (= x1@@1 y1@@0) (= (MapType1Select (MapType1Store m@@4 x0@@4 x1@@1 val@@4) y0@@2 y1@@0) (MapType1Select m@@4 y0@@2 y1@@0))) :qid |mapAx1:MapType1Select:1| :weight 0 ))) (forall ((val@@5 T@U) (m@@5 T@U) (x0@@5 T@U) (x1@@2 T@U) (y0@@3 T@U) (y1@@1 T@U) ) (!  (or true (= (MapType1Select (MapType1Store m@@5 x0@@5 x1@@2 val@@5) y0@@3 y1@@1) (MapType1Select m@@5 y0@@3 y1@@1))) :qid |mapAx2:MapType1Select| :weight 0 )))) (= (Ctor refType) 15)))
(assert (forall ((v@@0 T@U) (t@@20 T@U) (h T@U) ) (!  (=> (and (= (type t@@20) TyType) (= (type h) (MapType1Type refType))) (and (=> ($IsAllocBox ($Box v@@0) t@@20 h) ($IsAlloc v@@0 t@@20 h)) (=> ($IsAlloc v@@0 t@@20 h) ($IsAllocBox ($Box v@@0) t@@20 h)))) :qid |DafnyPre.160:18| :skolemid |326| :pattern ( ($IsAllocBox ($Box v@@0) t@@20 h)) )))
(assert (forall ((v@@1 T@U) ) (!  (=> (= (type v@@1) intType) ($Is v@@1 TInt)) :qid |DafnyPre.178:14| :skolemid |327| :pattern ( ($Is v@@1 TInt)) )))
(assert (forall ((v@@2 T@U) ) (!  (=> (= (type v@@2) realType) ($Is v@@2 TReal)) :qid |DafnyPre.179:14| :skolemid |328| :pattern ( ($Is v@@2 TReal)) )))
(assert (forall ((v@@3 T@U) ) (!  (=> (= (type v@@3) boolType) ($Is v@@3 TBool)) :qid |DafnyPre.180:14| :skolemid |329| :pattern ( ($Is v@@3 TBool)) )))
(assert (forall ((v@@4 T@U) ) (!  (=> (= (type v@@4) charType) ($Is v@@4 TChar)) :qid |DafnyPre.181:14| :skolemid |330| :pattern ( ($Is v@@4 TChar)) )))
(assert (forall ((h@@0 T@U) (v@@5 T@U) ) (!  (=> (and (= (type h@@0) (MapType1Type refType)) (= (type v@@5) intType)) ($IsAlloc v@@5 TInt h@@0)) :qid |DafnyPre.183:14| :skolemid |331| :pattern ( ($IsAlloc v@@5 TInt h@@0)) )))
(assert (forall ((h@@1 T@U) (v@@6 T@U) ) (!  (=> (and (= (type h@@1) (MapType1Type refType)) (= (type v@@6) realType)) ($IsAlloc v@@6 TReal h@@1)) :qid |DafnyPre.184:14| :skolemid |332| :pattern ( ($IsAlloc v@@6 TReal h@@1)) )))
(assert (forall ((h@@2 T@U) (v@@7 T@U) ) (!  (=> (and (= (type h@@2) (MapType1Type refType)) (= (type v@@7) boolType)) ($IsAlloc v@@7 TBool h@@2)) :qid |DafnyPre.185:14| :skolemid |333| :pattern ( ($IsAlloc v@@7 TBool h@@2)) )))
(assert (forall ((h@@3 T@U) (v@@8 T@U) ) (!  (=> (and (= (type h@@3) (MapType1Type refType)) (= (type v@@8) charType)) ($IsAlloc v@@8 TChar h@@3)) :qid |DafnyPre.186:14| :skolemid |334| :pattern ( ($IsAlloc v@@8 TChar h@@3)) )))
(assert (forall ((v@@9 T@U) (t0 T@U) ) (!  (=> (and (= (type v@@9) (MapType0Type BoxType boolType)) (= (type t0) TyType)) (and (=> ($Is v@@9 (TSet t0)) (forall ((bx@@9 T@U) ) (!  (=> (and (= (type bx@@9) BoxType) (U_2_bool (MapType0Select v@@9 bx@@9))) ($IsBox bx@@9 t0)) :qid |DafnyPre.190:11| :skolemid |335| :pattern ( (MapType0Select v@@9 bx@@9)) ))) (=> (forall ((bx@@10 T@U) ) (!  (=> (and (= (type bx@@10) BoxType) (U_2_bool (MapType0Select v@@9 bx@@10))) ($IsBox bx@@10 t0)) :qid |DafnyPre.190:11| :skolemid |335| :pattern ( (MapType0Select v@@9 bx@@10)) )) ($Is v@@9 (TSet t0))))) :qid |DafnyPre.188:15| :skolemid |336| :pattern ( ($Is v@@9 (TSet t0))) )))
(assert (forall ((v@@10 T@U) (t0@@0 T@U) ) (!  (=> (and (= (type v@@10) (MapType0Type BoxType boolType)) (= (type t0@@0) TyType)) (and (=> ($Is v@@10 (TISet t0@@0)) (forall ((bx@@11 T@U) ) (!  (=> (and (= (type bx@@11) BoxType) (U_2_bool (MapType0Select v@@10 bx@@11))) ($IsBox bx@@11 t0@@0)) :qid |DafnyPre.194:11| :skolemid |337| :pattern ( (MapType0Select v@@10 bx@@11)) ))) (=> (forall ((bx@@12 T@U) ) (!  (=> (and (= (type bx@@12) BoxType) (U_2_bool (MapType0Select v@@10 bx@@12))) ($IsBox bx@@12 t0@@0)) :qid |DafnyPre.194:11| :skolemid |337| :pattern ( (MapType0Select v@@10 bx@@12)) )) ($Is v@@10 (TISet t0@@0))))) :qid |DafnyPre.192:15| :skolemid |338| :pattern ( ($Is v@@10 (TISet t0@@0))) )))
(assert (forall ((v@@11 T@U) (t0@@1 T@U) ) (!  (=> (and (= (type v@@11) (MapType0Type BoxType intType)) (= (type t0@@1) TyType)) (and (=> ($Is v@@11 (TMultiSet t0@@1)) (forall ((bx@@13 T@U) ) (!  (=> (and (= (type bx@@13) BoxType) (< 0 (U_2_int (MapType0Select v@@11 bx@@13)))) ($IsBox bx@@13 t0@@1)) :qid |DafnyPre.198:11| :skolemid |339| :pattern ( (MapType0Select v@@11 bx@@13)) ))) (=> (forall ((bx@@14 T@U) ) (!  (=> (and (= (type bx@@14) BoxType) (< 0 (U_2_int (MapType0Select v@@11 bx@@14)))) ($IsBox bx@@14 t0@@1)) :qid |DafnyPre.198:11| :skolemid |339| :pattern ( (MapType0Select v@@11 bx@@14)) )) ($Is v@@11 (TMultiSet t0@@1))))) :qid |DafnyPre.196:15| :skolemid |340| :pattern ( ($Is v@@11 (TMultiSet t0@@1))) )))
(assert (forall ((v@@12 T@U) (t0@@2 T@U) ) (!  (=> (and (and (= (type v@@12) (MapType0Type BoxType intType)) (= (type t0@@2) TyType)) ($Is v@@12 (TMultiSet t0@@2))) ($IsGoodMultiSet v@@12)) :qid |DafnyPre.200:15| :skolemid |341| :pattern ( ($Is v@@12 (TMultiSet t0@@2))) )))
(assert (forall ((arg0@@43 T@U) (arg1@@14 Int) ) (! (let ((T@@2 (SeqTypeInv0 (type arg0@@43)))) (= (type (|Seq#Index| arg0@@43 arg1@@14)) T@@2)) :qid |funType:Seq#Index| :pattern ( (|Seq#Index| arg0@@43 arg1@@14)) )))
(assert (forall ((v@@13 T@U) (t0@@3 T@U) ) (!  (=> (and (= (type v@@13) (SeqType BoxType)) (= (type t0@@3) TyType)) (and (=> ($Is v@@13 (TSeq t0@@3)) (forall ((i Int) ) (!  (=> (and (<= 0 i) (< i (|Seq#Length| v@@13))) ($IsBox (|Seq#Index| v@@13 i) t0@@3)) :qid |DafnyPre.204:11| :skolemid |342| :pattern ( (|Seq#Index| v@@13 i)) ))) (=> (forall ((i@@0 Int) ) (!  (=> (and (<= 0 i@@0) (< i@@0 (|Seq#Length| v@@13))) ($IsBox (|Seq#Index| v@@13 i@@0) t0@@3)) :qid |DafnyPre.204:11| :skolemid |342| :pattern ( (|Seq#Index| v@@13 i@@0)) )) ($Is v@@13 (TSeq t0@@3))))) :qid |DafnyPre.202:15| :skolemid |343| :pattern ( ($Is v@@13 (TSeq t0@@3))) )))
(assert (forall ((v@@14 T@U) (t0@@4 T@U) (h@@4 T@U) ) (!  (=> (and (and (= (type v@@14) (MapType0Type BoxType boolType)) (= (type t0@@4) TyType)) (= (type h@@4) (MapType1Type refType))) (and (=> ($IsAlloc v@@14 (TSet t0@@4) h@@4) (forall ((bx@@15 T@U) ) (!  (=> (and (= (type bx@@15) BoxType) (U_2_bool (MapType0Select v@@14 bx@@15))) ($IsAllocBox bx@@15 t0@@4 h@@4)) :qid |DafnyPre.209:11| :skolemid |344| :pattern ( (MapType0Select v@@14 bx@@15)) ))) (=> (forall ((bx@@16 T@U) ) (!  (=> (and (= (type bx@@16) BoxType) (U_2_bool (MapType0Select v@@14 bx@@16))) ($IsAllocBox bx@@16 t0@@4 h@@4)) :qid |DafnyPre.209:11| :skolemid |344| :pattern ( (MapType0Select v@@14 bx@@16)) )) ($IsAlloc v@@14 (TSet t0@@4) h@@4)))) :qid |DafnyPre.207:15| :skolemid |345| :pattern ( ($IsAlloc v@@14 (TSet t0@@4) h@@4)) )))
(assert (forall ((v@@15 T@U) (t0@@5 T@U) (h@@5 T@U) ) (!  (=> (and (and (= (type v@@15) (MapType0Type BoxType boolType)) (= (type t0@@5) TyType)) (= (type h@@5) (MapType1Type refType))) (and (=> ($IsAlloc v@@15 (TISet t0@@5) h@@5) (forall ((bx@@17 T@U) ) (!  (=> (and (= (type bx@@17) BoxType) (U_2_bool (MapType0Select v@@15 bx@@17))) ($IsAllocBox bx@@17 t0@@5 h@@5)) :qid |DafnyPre.213:11| :skolemid |346| :pattern ( (MapType0Select v@@15 bx@@17)) ))) (=> (forall ((bx@@18 T@U) ) (!  (=> (and (= (type bx@@18) BoxType) (U_2_bool (MapType0Select v@@15 bx@@18))) ($IsAllocBox bx@@18 t0@@5 h@@5)) :qid |DafnyPre.213:11| :skolemid |346| :pattern ( (MapType0Select v@@15 bx@@18)) )) ($IsAlloc v@@15 (TISet t0@@5) h@@5)))) :qid |DafnyPre.211:15| :skolemid |347| :pattern ( ($IsAlloc v@@15 (TISet t0@@5) h@@5)) )))
(assert (forall ((v@@16 T@U) (t0@@6 T@U) (h@@6 T@U) ) (!  (=> (and (and (= (type v@@16) (MapType0Type BoxType intType)) (= (type t0@@6) TyType)) (= (type h@@6) (MapType1Type refType))) (and (=> ($IsAlloc v@@16 (TMultiSet t0@@6) h@@6) (forall ((bx@@19 T@U) ) (!  (=> (and (= (type bx@@19) BoxType) (< 0 (U_2_int (MapType0Select v@@16 bx@@19)))) ($IsAllocBox bx@@19 t0@@6 h@@6)) :qid |DafnyPre.217:11| :skolemid |348| :pattern ( (MapType0Select v@@16 bx@@19)) ))) (=> (forall ((bx@@20 T@U) ) (!  (=> (and (= (type bx@@20) BoxType) (< 0 (U_2_int (MapType0Select v@@16 bx@@20)))) ($IsAllocBox bx@@20 t0@@6 h@@6)) :qid |DafnyPre.217:11| :skolemid |348| :pattern ( (MapType0Select v@@16 bx@@20)) )) ($IsAlloc v@@16 (TMultiSet t0@@6) h@@6)))) :qid |DafnyPre.215:15| :skolemid |349| :pattern ( ($IsAlloc v@@16 (TMultiSet t0@@6) h@@6)) )))
(assert (forall ((v@@17 T@U) (t0@@7 T@U) (h@@7 T@U) ) (!  (=> (and (and (= (type v@@17) (SeqType BoxType)) (= (type t0@@7) TyType)) (= (type h@@7) (MapType1Type refType))) (and (=> ($IsAlloc v@@17 (TSeq t0@@7) h@@7) (forall ((i@@1 Int) ) (!  (=> (and (<= 0 i@@1) (< i@@1 (|Seq#Length| v@@17))) ($IsAllocBox (|Seq#Index| v@@17 i@@1) t0@@7 h@@7)) :qid |DafnyPre.221:11| :skolemid |350| :pattern ( (|Seq#Index| v@@17 i@@1)) ))) (=> (forall ((i@@2 Int) ) (!  (=> (and (<= 0 i@@2) (< i@@2 (|Seq#Length| v@@17))) ($IsAllocBox (|Seq#Index| v@@17 i@@2) t0@@7 h@@7)) :qid |DafnyPre.221:11| :skolemid |350| :pattern ( (|Seq#Index| v@@17 i@@2)) )) ($IsAlloc v@@17 (TSeq t0@@7) h@@7)))) :qid |DafnyPre.219:15| :skolemid |351| :pattern ( ($IsAlloc v@@17 (TSeq t0@@7) h@@7)) )))
(assert  (and (forall ((arg0@@44 T@U) ) (! (let ((V (MapTypeInv1 (type arg0@@44)))) (let ((U (MapTypeInv0 (type arg0@@44)))) (= (type (|Map#Elements| arg0@@44)) (MapType0Type U V)))) :qid |funType:Map#Elements| :pattern ( (|Map#Elements| arg0@@44)) )) (forall ((arg0@@45 T@U) ) (! (let ((U@@0 (MapTypeInv0 (type arg0@@45)))) (= (type (|Map#Domain| arg0@@45)) (MapType0Type U@@0 boolType))) :qid |funType:Map#Domain| :pattern ( (|Map#Domain| arg0@@45)) ))))
(assert (forall ((v@@18 T@U) (t0@@8 T@U) (t1 T@U) ) (!  (=> (and (and (= (type v@@18) (MapType BoxType BoxType)) (= (type t0@@8) TyType)) (= (type t1) TyType)) (and (=> ($Is v@@18 (TMap t0@@8 t1)) (forall ((bx@@21 T@U) ) (!  (=> (and (= (type bx@@21) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@18) bx@@21))) (and ($IsBox (MapType0Select (|Map#Elements| v@@18) bx@@21) t1) ($IsBox bx@@21 t0@@8))) :qid |DafnyPre.228:19| :skolemid |352| :pattern ( (MapType0Select (|Map#Elements| v@@18) bx@@21)) :pattern ( (MapType0Select (|Map#Domain| v@@18) bx@@21)) ))) (=> (forall ((bx@@22 T@U) ) (!  (=> (and (= (type bx@@22) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@18) bx@@22))) (and ($IsBox (MapType0Select (|Map#Elements| v@@18) bx@@22) t1) ($IsBox bx@@22 t0@@8))) :qid |DafnyPre.228:19| :skolemid |352| :pattern ( (MapType0Select (|Map#Elements| v@@18) bx@@22)) :pattern ( (MapType0Select (|Map#Domain| v@@18) bx@@22)) )) ($Is v@@18 (TMap t0@@8 t1))))) :qid |DafnyPre.225:15| :skolemid |353| :pattern ( ($Is v@@18 (TMap t0@@8 t1))) )))
(assert (forall ((v@@19 T@U) (t0@@9 T@U) (t1@@0 T@U) (h@@8 T@U) ) (!  (=> (and (and (and (= (type v@@19) (MapType BoxType BoxType)) (= (type t0@@9) TyType)) (= (type t1@@0) TyType)) (= (type h@@8) (MapType1Type refType))) (and (=> ($IsAlloc v@@19 (TMap t0@@9 t1@@0) h@@8) (forall ((bx@@23 T@U) ) (!  (=> (and (= (type bx@@23) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@19) bx@@23))) (and ($IsAllocBox (MapType0Select (|Map#Elements| v@@19) bx@@23) t1@@0 h@@8) ($IsAllocBox bx@@23 t0@@9 h@@8))) :qid |DafnyPre.236:19| :skolemid |354| :pattern ( (MapType0Select (|Map#Elements| v@@19) bx@@23)) :pattern ( (MapType0Select (|Map#Domain| v@@19) bx@@23)) ))) (=> (forall ((bx@@24 T@U) ) (!  (=> (and (= (type bx@@24) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@19) bx@@24))) (and ($IsAllocBox (MapType0Select (|Map#Elements| v@@19) bx@@24) t1@@0 h@@8) ($IsAllocBox bx@@24 t0@@9 h@@8))) :qid |DafnyPre.236:19| :skolemid |354| :pattern ( (MapType0Select (|Map#Elements| v@@19) bx@@24)) :pattern ( (MapType0Select (|Map#Domain| v@@19) bx@@24)) )) ($IsAlloc v@@19 (TMap t0@@9 t1@@0) h@@8)))) :qid |DafnyPre.233:15| :skolemid |355| :pattern ( ($IsAlloc v@@19 (TMap t0@@9 t1@@0) h@@8)) )))
(assert  (and (forall ((arg0@@46 T@U) ) (! (let ((V@@0 (IMapTypeInv1 (type arg0@@46)))) (let ((U@@1 (IMapTypeInv0 (type arg0@@46)))) (= (type (|IMap#Elements| arg0@@46)) (MapType0Type U@@1 V@@0)))) :qid |funType:IMap#Elements| :pattern ( (|IMap#Elements| arg0@@46)) )) (forall ((arg0@@47 T@U) ) (! (let ((U@@2 (IMapTypeInv0 (type arg0@@47)))) (= (type (|IMap#Domain| arg0@@47)) (MapType0Type U@@2 boolType))) :qid |funType:IMap#Domain| :pattern ( (|IMap#Domain| arg0@@47)) ))))
(assert (forall ((v@@20 T@U) (t0@@10 T@U) (t1@@1 T@U) ) (!  (=> (and (and (= (type v@@20) (IMapType BoxType BoxType)) (= (type t0@@10) TyType)) (= (type t1@@1) TyType)) (and (=> ($Is v@@20 (TIMap t0@@10 t1@@1)) (forall ((bx@@25 T@U) ) (!  (=> (and (= (type bx@@25) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@20) bx@@25))) (and ($IsBox (MapType0Select (|IMap#Elements| v@@20) bx@@25) t1@@1) ($IsBox bx@@25 t0@@10))) :qid |DafnyPre.245:19| :skolemid |356| :pattern ( (MapType0Select (|IMap#Elements| v@@20) bx@@25)) :pattern ( (MapType0Select (|IMap#Domain| v@@20) bx@@25)) ))) (=> (forall ((bx@@26 T@U) ) (!  (=> (and (= (type bx@@26) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@20) bx@@26))) (and ($IsBox (MapType0Select (|IMap#Elements| v@@20) bx@@26) t1@@1) ($IsBox bx@@26 t0@@10))) :qid |DafnyPre.245:19| :skolemid |356| :pattern ( (MapType0Select (|IMap#Elements| v@@20) bx@@26)) :pattern ( (MapType0Select (|IMap#Domain| v@@20) bx@@26)) )) ($Is v@@20 (TIMap t0@@10 t1@@1))))) :qid |DafnyPre.242:15| :skolemid |357| :pattern ( ($Is v@@20 (TIMap t0@@10 t1@@1))) )))
(assert (forall ((v@@21 T@U) (t0@@11 T@U) (t1@@2 T@U) (h@@9 T@U) ) (!  (=> (and (and (and (= (type v@@21) (IMapType BoxType BoxType)) (= (type t0@@11) TyType)) (= (type t1@@2) TyType)) (= (type h@@9) (MapType1Type refType))) (and (=> ($IsAlloc v@@21 (TIMap t0@@11 t1@@2) h@@9) (forall ((bx@@27 T@U) ) (!  (=> (and (= (type bx@@27) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@21) bx@@27))) (and ($IsAllocBox (MapType0Select (|IMap#Elements| v@@21) bx@@27) t1@@2 h@@9) ($IsAllocBox bx@@27 t0@@11 h@@9))) :qid |DafnyPre.253:19| :skolemid |358| :pattern ( (MapType0Select (|IMap#Elements| v@@21) bx@@27)) :pattern ( (MapType0Select (|IMap#Domain| v@@21) bx@@27)) ))) (=> (forall ((bx@@28 T@U) ) (!  (=> (and (= (type bx@@28) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@21) bx@@28))) (and ($IsAllocBox (MapType0Select (|IMap#Elements| v@@21) bx@@28) t1@@2 h@@9) ($IsAllocBox bx@@28 t0@@11 h@@9))) :qid |DafnyPre.253:19| :skolemid |358| :pattern ( (MapType0Select (|IMap#Elements| v@@21) bx@@28)) :pattern ( (MapType0Select (|IMap#Domain| v@@21) bx@@28)) )) ($IsAlloc v@@21 (TIMap t0@@11 t1@@2) h@@9)))) :qid |DafnyPre.250:15| :skolemid |359| :pattern ( ($IsAlloc v@@21 (TIMap t0@@11 t1@@2) h@@9)) )))
(assert  (and (and (forall ((arg0@@48 T@U) (arg1@@15 T@U) ) (! (= (type (TypeTuple arg0@@48 arg1@@15)) ClassNameType) :qid |funType:TypeTuple| :pattern ( (TypeTuple arg0@@48 arg1@@15)) )) (forall ((arg0@@49 T@U) ) (! (= (type (TypeTupleCar arg0@@49)) ClassNameType) :qid |funType:TypeTupleCar| :pattern ( (TypeTupleCar arg0@@49)) ))) (forall ((arg0@@50 T@U) ) (! (= (type (TypeTupleCdr arg0@@50)) ClassNameType) :qid |funType:TypeTupleCdr| :pattern ( (TypeTupleCdr arg0@@50)) ))))
(assert (forall ((a T@U) (b T@U) ) (!  (=> (and (= (type a) ClassNameType) (= (type b) ClassNameType)) (and (= (TypeTupleCar (TypeTuple a b)) a) (= (TypeTupleCdr (TypeTuple a b)) b))) :qid |DafnyPre.278:15| :skolemid |360| :pattern ( (TypeTuple a b)) )))
(assert (forall ((arg0@@51 T@U) ) (! (= (type (SetRef_to_SetBox arg0@@51)) (MapType0Type BoxType boolType)) :qid |funType:SetRef_to_SetBox| :pattern ( (SetRef_to_SetBox arg0@@51)) )))
(assert (forall ((s@@1 T@U) (bx@@29 T@U) ) (!  (=> (and (= (type s@@1) (MapType0Type refType boolType)) (= (type bx@@29) BoxType)) (and (=> (U_2_bool (MapType0Select (SetRef_to_SetBox s@@1) bx@@29)) (U_2_bool (MapType0Select s@@1 ($Unbox refType bx@@29)))) (=> (U_2_bool (MapType0Select s@@1 ($Unbox refType bx@@29))) (U_2_bool (MapType0Select (SetRef_to_SetBox s@@1) bx@@29))))) :qid |DafnyPre.287:15| :skolemid |361| :pattern ( (MapType0Select (SetRef_to_SetBox s@@1) bx@@29)) )))
(assert (= (type Tclass._System.object) TyType))
(assert (forall ((s@@2 T@U) ) (!  (=> (= (type s@@2) (MapType0Type refType boolType)) ($Is (SetRef_to_SetBox s@@2) (TSet Tclass._System.object))) :qid |DafnyPre.289:15| :skolemid |362| :pattern ( (SetRef_to_SetBox s@@2)) )))
(assert (= (Ctor DatatypeTypeType) 16))
(assert (forall ((d T@U) ) (!  (=> (= (type d) DatatypeTypeType) (= (BoxRank ($Box d)) (DtRank d))) :qid |DafnyPre.304:15| :skolemid |363| :pattern ( (BoxRank ($Box d))) )))
(assert  (and (= (Ctor LayerTypeType) 17) (forall ((arg0@@52 T@U) (arg1@@16 T@U) ) (! (let ((A (MapType0TypeInv1 (type arg0@@52)))) (= (type (AtLayer arg0@@52 arg1@@16)) A)) :qid |funType:AtLayer| :pattern ( (AtLayer arg0@@52 arg1@@16)) ))))
(assert (forall ((f T@U) (ly T@U) ) (! (let ((A@@0 (MapType0TypeInv1 (type f)))) (=> (and (= (type f) (MapType0Type LayerTypeType A@@0)) (= (type ly) LayerTypeType)) (= (AtLayer f ly) (MapType0Select f ly)))) :qid |DafnyPre.324:18| :skolemid |364| :pattern ( (AtLayer f ly)) )))
(assert (forall ((arg0@@53 T@U) ) (! (= (type ($LS arg0@@53)) LayerTypeType) :qid |funType:$LS| :pattern ( ($LS arg0@@53)) )))
(assert (forall ((f@@0 T@U) (ly@@0 T@U) ) (! (let ((A@@1 (MapType0TypeInv1 (type f@@0)))) (=> (and (= (type f@@0) (MapType0Type LayerTypeType A@@1)) (= (type ly@@0) LayerTypeType)) (= (AtLayer f@@0 ($LS ly@@0)) (AtLayer f@@0 ly@@0)))) :qid |DafnyPre.325:18| :skolemid |365| :pattern ( (AtLayer f@@0 ($LS ly@@0))) )))
(assert (forall ((arg0@@54 Int) ) (! (= (type (IndexField arg0@@54)) (FieldType BoxType)) :qid |funType:IndexField| :pattern ( (IndexField arg0@@54)) )))
(assert (forall ((i@@3 Int) ) (! (= (FDim (IndexField i@@3)) 1) :qid |DafnyPre.336:15| :skolemid |366| :pattern ( (IndexField i@@3)) )))
(assert (forall ((i@@4 Int) ) (! (= (IndexField_Inverse (IndexField i@@4)) i@@4) :qid |DafnyPre.338:15| :skolemid |367| :pattern ( (IndexField i@@4)) )))
(assert (forall ((arg0@@55 T@U) (arg1@@17 Int) ) (! (= (type (MultiIndexField arg0@@55 arg1@@17)) (FieldType BoxType)) :qid |funType:MultiIndexField| :pattern ( (MultiIndexField arg0@@55 arg1@@17)) )))
(assert (forall ((f@@1 T@U) (i@@5 Int) ) (!  (=> (= (type f@@1) (FieldType BoxType)) (= (FDim (MultiIndexField f@@1 i@@5)) (+ (FDim f@@1) 1))) :qid |DafnyPre.341:15| :skolemid |368| :pattern ( (MultiIndexField f@@1 i@@5)) )))
(assert (forall ((arg0@@56 T@U) ) (! (let ((T@@3 (FieldTypeInv0 (type arg0@@56)))) (= (type (MultiIndexField_Inverse0 arg0@@56)) (FieldType T@@3))) :qid |funType:MultiIndexField_Inverse0| :pattern ( (MultiIndexField_Inverse0 arg0@@56)) )))
(assert (forall ((f@@2 T@U) (i@@6 Int) ) (!  (=> (= (type f@@2) (FieldType BoxType)) (and (= (MultiIndexField_Inverse0 (MultiIndexField f@@2 i@@6)) f@@2) (= (MultiIndexField_Inverse1 (MultiIndexField f@@2 i@@6)) i@@6))) :qid |DafnyPre.344:15| :skolemid |369| :pattern ( (MultiIndexField f@@2 i@@6)) )))
(assert  (and (and (and (= (Ctor NameFamilyType) 18) (forall ((alpha@@3 T@T) (arg0@@57 T@U) (arg1@@18 T@U) ) (! (= (type (FieldOfDecl alpha@@3 arg0@@57 arg1@@18)) (FieldType alpha@@3)) :qid |funType:FieldOfDecl| :pattern ( (FieldOfDecl alpha@@3 arg0@@57 arg1@@18)) ))) (forall ((arg0@@58 T@U) ) (! (= (type (DeclType arg0@@58)) ClassNameType) :qid |funType:DeclType| :pattern ( (DeclType arg0@@58)) ))) (forall ((arg0@@59 T@U) ) (! (= (type (DeclName arg0@@59)) NameFamilyType) :qid |funType:DeclName| :pattern ( (DeclName arg0@@59)) ))))
(assert (forall ((cl T@U) (nm T@U) (T@@4 T@T) ) (!  (=> (and (= (type cl) ClassNameType) (= (type nm) NameFamilyType)) (and (= (DeclType (FieldOfDecl T@@4 cl nm)) cl) (= (DeclName (FieldOfDecl T@@4 cl nm)) nm))) :qid |DafnyPre.353:18| :skolemid |370| :pattern ( (FieldOfDecl T@@4 cl nm)) )))
(assert (forall ((h@@10 T@U) (k T@U) (v@@22 T@U) (t@@21 T@U) ) (!  (=> (and (and (and (and (= (type h@@10) (MapType1Type refType)) (= (type k) (MapType1Type refType))) (= (type t@@21) TyType)) ($HeapSucc h@@10 k)) ($IsAlloc v@@22 t@@21 h@@10)) ($IsAlloc v@@22 t@@21 k)) :qid |DafnyPre.366:17| :skolemid |371| :pattern ( ($HeapSucc h@@10 k) ($IsAlloc v@@22 t@@21 h@@10)) )))
(assert (forall ((h@@11 T@U) (k@@0 T@U) (bx@@30 T@U) (t@@22 T@U) ) (!  (=> (and (and (and (and (and (= (type h@@11) (MapType1Type refType)) (= (type k@@0) (MapType1Type refType))) (= (type bx@@30) BoxType)) (= (type t@@22) TyType)) ($HeapSucc h@@11 k@@0)) ($IsAllocBox bx@@30 t@@22 h@@11)) ($IsAllocBox bx@@30 t@@22 k@@0)) :qid |DafnyPre.369:14| :skolemid |372| :pattern ( ($HeapSucc h@@11 k@@0) ($IsAllocBox bx@@30 t@@22 h@@11)) )))
(assert (= (FDim alloc) 0))
(assert  (not ($IsGhostField alloc)))
(assert (forall ((o T@U) ) (!  (=> (= (type o) refType) (<= 0 (_System.array.Length o))) :qid |DafnyPre.383:15| :skolemid |373| :no-pattern (type o) :no-pattern (U_2_int o) :no-pattern (U_2_bool o) )))
(assert (forall ((x@@12 Real) ) (! (= (q@Int x@@12) (to_int x@@12)) :qid |DafnyPre.389:14| :skolemid |374| :pattern ( (q@Int x@@12)) )))
(assert (forall ((x@@13 Int) ) (! (= (q@Real x@@13) (to_real x@@13)) :qid |DafnyPre.390:15| :skolemid |375| :pattern ( (q@Real x@@13)) )))
(assert (forall ((i@@7 Int) ) (! (= (q@Int (q@Real i@@7)) i@@7) :qid |DafnyPre.391:15| :skolemid |376| :pattern ( (q@Int (q@Real i@@7))) )))
(assert (forall ((h@@12 T@U) (r T@U) (f@@3 T@U) (x@@14 T@U) ) (! (let ((alpha@@4 (type x@@14))) (=> (and (and (and (= (type h@@12) (MapType1Type refType)) (= (type r) refType)) (= (type f@@3) (FieldType alpha@@4))) ($IsGoodHeap (MapType1Store h@@12 r f@@3 x@@14))) ($HeapSucc h@@12 (MapType1Store h@@12 r f@@3 x@@14)))) :qid |DafnyPre.408:22| :skolemid |377| :pattern ( (MapType1Store h@@12 r f@@3 x@@14)) )))
(assert (forall ((a@@0 T@U) (b@@0 T@U) (c T@U) ) (!  (=> (and (and (and (= (type a@@0) (MapType1Type refType)) (= (type b@@0) (MapType1Type refType))) (= (type c) (MapType1Type refType))) (and ($HeapSucc a@@0 b@@0) ($HeapSucc b@@0 c))) ($HeapSucc a@@0 c)) :qid |DafnyPre.411:15| :skolemid |378| :pattern ( ($HeapSucc a@@0 b@@0) ($HeapSucc b@@0 c)) )))
(assert (forall ((h@@13 T@U) (k@@1 T@U) ) (!  (=> (and (and (= (type h@@13) (MapType1Type refType)) (= (type k@@1) (MapType1Type refType))) ($HeapSucc h@@13 k@@1)) (forall ((o@@0 T@U) ) (!  (=> (and (= (type o@@0) refType) (U_2_bool (MapType1Select h@@13 o@@0 alloc))) (U_2_bool (MapType1Select k@@1 o@@0 alloc))) :qid |DafnyPre.414:30| :skolemid |379| :pattern ( (MapType1Select k@@1 o@@0 alloc)) ))) :qid |DafnyPre.413:15| :skolemid |380| :pattern ( ($HeapSucc h@@13 k@@1)) )))
(assert (forall ((h@@14 T@U) (k@@2 T@U) ) (!  (=> (and (and (= (type h@@14) (MapType1Type refType)) (= (type k@@2) (MapType1Type refType))) ($HeapSuccGhost h@@14 k@@2)) (and ($HeapSucc h@@14 k@@2) (forall ((o@@1 T@U) (f@@4 T@U) ) (! (let ((alpha@@5 (FieldTypeInv0 (type f@@4)))) (=> (and (and (= (type o@@1) refType) (= (type f@@4) (FieldType alpha@@5))) (not ($IsGhostField f@@4))) (= (MapType1Select h@@14 o@@1 f@@4) (MapType1Select k@@2 o@@1 f@@4)))) :qid |DafnyPre.420:20| :skolemid |381| :pattern ( (MapType1Select k@@2 o@@1 f@@4)) )))) :qid |DafnyPre.417:15| :skolemid |382| :pattern ( ($HeapSuccGhost h@@14 k@@2)) )))
(assert (forall ((s@@3 T@U) ) (! (let ((T@@5 (MapType0TypeInv0 (type s@@3)))) (=> (= (type s@@3) (MapType0Type T@@5 boolType)) (<= 0 (|Set#Card| s@@3)))) :qid |DafnyPre.478:18| :skolemid |387| :pattern ( (|Set#Card| s@@3)) )))
(assert (forall ((T@@6 T@T) ) (! (= (type (|Set#Empty| T@@6)) (MapType0Type T@@6 boolType)) :qid |funType:Set#Empty| :pattern ( (|Set#Empty| T@@6)) )))
(assert (forall ((o@@2 T@U) ) (! (let ((T@@7 (type o@@2))) (not (U_2_bool (MapType0Select (|Set#Empty| T@@7) o@@2)))) :qid |DafnyPre.481:18| :skolemid |388| :pattern ( (let ((T@@7 (type o@@2))) (MapType0Select (|Set#Empty| T@@7) o@@2))) )))
(assert (forall ((s@@4 T@U) ) (! (let ((T@@8 (MapType0TypeInv0 (type s@@4)))) (=> (= (type s@@4) (MapType0Type T@@8 boolType)) (and (and (=> (= (|Set#Card| s@@4) 0) (= s@@4 (|Set#Empty| T@@8))) (=> (= s@@4 (|Set#Empty| T@@8)) (= (|Set#Card| s@@4) 0))) (=> (not (= (|Set#Card| s@@4) 0)) (exists ((x@@15 T@U) ) (!  (and (= (type x@@15) T@@8) (U_2_bool (MapType0Select s@@4 x@@15))) :qid |DafnyPre.484:33| :skolemid |389| :no-pattern (type x@@15) :no-pattern (U_2_int x@@15) :no-pattern (U_2_bool x@@15) )))))) :qid |DafnyPre.482:18| :skolemid |390| :pattern ( (|Set#Card| s@@4)) )))
(assert (forall ((arg0@@60 T@U) ) (! (let ((T@@9 (type arg0@@60))) (= (type (|Set#Singleton| arg0@@60)) (MapType0Type T@@9 boolType))) :qid |funType:Set#Singleton| :pattern ( (|Set#Singleton| arg0@@60)) )))
(assert (forall ((r@@0 T@U) ) (! (U_2_bool (MapType0Select (|Set#Singleton| r@@0) r@@0)) :qid |DafnyPre.490:18| :skolemid |391| :pattern ( (|Set#Singleton| r@@0)) )))
(assert (forall ((r@@1 T@U) (o@@3 T@U) ) (! (let ((T@@10 (type r@@1))) (=> (= (type o@@3) T@@10) (and (=> (U_2_bool (MapType0Select (|Set#Singleton| r@@1) o@@3)) (= r@@1 o@@3)) (=> (= r@@1 o@@3) (U_2_bool (MapType0Select (|Set#Singleton| r@@1) o@@3)))))) :qid |DafnyPre.491:18| :skolemid |392| :pattern ( (MapType0Select (|Set#Singleton| r@@1) o@@3)) )))
(assert (forall ((r@@2 T@U) ) (! (= (|Set#Card| (|Set#Singleton| r@@2)) 1) :qid |DafnyPre.492:18| :skolemid |393| :pattern ( (|Set#Card| (|Set#Singleton| r@@2))) )))
(assert (forall ((arg0@@61 T@U) (arg1@@19 T@U) ) (! (let ((T@@11 (type arg1@@19))) (= (type (|Set#UnionOne| arg0@@61 arg1@@19)) (MapType0Type T@@11 boolType))) :qid |funType:Set#UnionOne| :pattern ( (|Set#UnionOne| arg0@@61 arg1@@19)) )))
(assert (forall ((a@@1 T@U) (x@@16 T@U) (o@@4 T@U) ) (! (let ((T@@12 (type x@@16))) (=> (and (= (type a@@1) (MapType0Type T@@12 boolType)) (= (type o@@4) T@@12)) (and (=> (U_2_bool (MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)) (or (= o@@4 x@@16) (U_2_bool (MapType0Select a@@1 o@@4)))) (=> (or (= o@@4 x@@16) (U_2_bool (MapType0Select a@@1 o@@4))) (U_2_bool (MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)))))) :qid |DafnyPre.495:18| :skolemid |394| :pattern ( (MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)) )))
(assert (forall ((a@@2 T@U) (x@@17 T@U) ) (! (let ((T@@13 (type x@@17))) (=> (= (type a@@2) (MapType0Type T@@13 boolType)) (U_2_bool (MapType0Select (|Set#UnionOne| a@@2 x@@17) x@@17)))) :qid |DafnyPre.497:18| :skolemid |395| :pattern ( (|Set#UnionOne| a@@2 x@@17)) )))
(assert (forall ((a@@3 T@U) (x@@18 T@U) (y@@1 T@U) ) (! (let ((T@@14 (type x@@18))) (=> (and (and (= (type a@@3) (MapType0Type T@@14 boolType)) (= (type y@@1) T@@14)) (U_2_bool (MapType0Select a@@3 y@@1))) (U_2_bool (MapType0Select (|Set#UnionOne| a@@3 x@@18) y@@1)))) :qid |DafnyPre.499:18| :skolemid |396| :pattern ( (|Set#UnionOne| a@@3 x@@18) (MapType0Select a@@3 y@@1)) )))
(assert (forall ((a@@4 T@U) (x@@19 T@U) ) (! (let ((T@@15 (type x@@19))) (=> (and (= (type a@@4) (MapType0Type T@@15 boolType)) (U_2_bool (MapType0Select a@@4 x@@19))) (= (|Set#Card| (|Set#UnionOne| a@@4 x@@19)) (|Set#Card| a@@4)))) :qid |DafnyPre.501:18| :skolemid |397| :pattern ( (|Set#Card| (|Set#UnionOne| a@@4 x@@19))) )))
(assert (forall ((a@@5 T@U) (x@@20 T@U) ) (! (let ((T@@16 (type x@@20))) (=> (and (= (type a@@5) (MapType0Type T@@16 boolType)) (not (U_2_bool (MapType0Select a@@5 x@@20)))) (= (|Set#Card| (|Set#UnionOne| a@@5 x@@20)) (+ (|Set#Card| a@@5) 1)))) :qid |DafnyPre.503:18| :skolemid |398| :pattern ( (|Set#Card| (|Set#UnionOne| a@@5 x@@20))) )))
(assert (forall ((arg0@@62 T@U) (arg1@@20 T@U) ) (! (let ((T@@17 (MapType0TypeInv0 (type arg0@@62)))) (= (type (|Set#Union| arg0@@62 arg1@@20)) (MapType0Type T@@17 boolType))) :qid |funType:Set#Union| :pattern ( (|Set#Union| arg0@@62 arg1@@20)) )))
(assert (forall ((a@@6 T@U) (b@@1 T@U) (o@@5 T@U) ) (! (let ((T@@18 (type o@@5))) (=> (and (= (type a@@6) (MapType0Type T@@18 boolType)) (= (type b@@1) (MapType0Type T@@18 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Union| a@@6 b@@1) o@@5)) (or (U_2_bool (MapType0Select a@@6 o@@5)) (U_2_bool (MapType0Select b@@1 o@@5)))) (=> (or (U_2_bool (MapType0Select a@@6 o@@5)) (U_2_bool (MapType0Select b@@1 o@@5))) (U_2_bool (MapType0Select (|Set#Union| a@@6 b@@1) o@@5)))))) :qid |DafnyPre.507:18| :skolemid |399| :pattern ( (MapType0Select (|Set#Union| a@@6 b@@1) o@@5)) )))
(assert (forall ((a@@7 T@U) (b@@2 T@U) (y@@2 T@U) ) (! (let ((T@@19 (type y@@2))) (=> (and (and (= (type a@@7) (MapType0Type T@@19 boolType)) (= (type b@@2) (MapType0Type T@@19 boolType))) (U_2_bool (MapType0Select a@@7 y@@2))) (U_2_bool (MapType0Select (|Set#Union| a@@7 b@@2) y@@2)))) :qid |DafnyPre.509:18| :skolemid |400| :pattern ( (|Set#Union| a@@7 b@@2) (MapType0Select a@@7 y@@2)) )))
(assert (forall ((a@@8 T@U) (b@@3 T@U) (y@@3 T@U) ) (! (let ((T@@20 (type y@@3))) (=> (and (and (= (type a@@8) (MapType0Type T@@20 boolType)) (= (type b@@3) (MapType0Type T@@20 boolType))) (U_2_bool (MapType0Select b@@3 y@@3))) (U_2_bool (MapType0Select (|Set#Union| a@@8 b@@3) y@@3)))) :qid |DafnyPre.511:18| :skolemid |401| :pattern ( (|Set#Union| a@@8 b@@3) (MapType0Select b@@3 y@@3)) )))
(assert (forall ((arg0@@63 T@U) (arg1@@21 T@U) ) (! (let ((T@@21 (MapType0TypeInv0 (type arg0@@63)))) (= (type (|Set#Difference| arg0@@63 arg1@@21)) (MapType0Type T@@21 boolType))) :qid |funType:Set#Difference| :pattern ( (|Set#Difference| arg0@@63 arg1@@21)) )))
(assert (forall ((a@@9 T@U) (b@@4 T@U) ) (! (let ((T@@22 (MapType0TypeInv0 (type a@@9)))) (=> (and (and (= (type a@@9) (MapType0Type T@@22 boolType)) (= (type b@@4) (MapType0Type T@@22 boolType))) (|Set#Disjoint| a@@9 b@@4)) (and (= (|Set#Difference| (|Set#Union| a@@9 b@@4) a@@9) b@@4) (= (|Set#Difference| (|Set#Union| a@@9 b@@4) b@@4) a@@9)))) :qid |DafnyPre.513:18| :skolemid |402| :pattern ( (|Set#Union| a@@9 b@@4)) )))
(assert (forall ((arg0@@64 T@U) (arg1@@22 T@U) ) (! (let ((T@@23 (MapType0TypeInv0 (type arg0@@64)))) (= (type (|Set#Intersection| arg0@@64 arg1@@22)) (MapType0Type T@@23 boolType))) :qid |funType:Set#Intersection| :pattern ( (|Set#Intersection| arg0@@64 arg1@@22)) )))
(assert (forall ((a@@10 T@U) (b@@5 T@U) (o@@6 T@U) ) (! (let ((T@@24 (type o@@6))) (=> (and (= (type a@@10) (MapType0Type T@@24 boolType)) (= (type b@@5) (MapType0Type T@@24 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)) (and (U_2_bool (MapType0Select a@@10 o@@6)) (U_2_bool (MapType0Select b@@5 o@@6)))) (=> (and (U_2_bool (MapType0Select a@@10 o@@6)) (U_2_bool (MapType0Select b@@5 o@@6))) (U_2_bool (MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)))))) :qid |DafnyPre.523:18| :skolemid |403| :pattern ( (MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)) )))
(assert (forall ((a@@11 T@U) (b@@6 T@U) ) (! (let ((T@@25 (MapType0TypeInv0 (type a@@11)))) (=> (and (= (type a@@11) (MapType0Type T@@25 boolType)) (= (type b@@6) (MapType0Type T@@25 boolType))) (= (|Set#Union| (|Set#Union| a@@11 b@@6) b@@6) (|Set#Union| a@@11 b@@6)))) :qid |DafnyPre.526:18| :skolemid |404| :pattern ( (|Set#Union| (|Set#Union| a@@11 b@@6) b@@6)) )))
(assert (forall ((a@@12 T@U) (b@@7 T@U) ) (! (let ((T@@26 (MapType0TypeInv0 (type a@@12)))) (=> (and (= (type a@@12) (MapType0Type T@@26 boolType)) (= (type b@@7) (MapType0Type T@@26 boolType))) (= (|Set#Union| a@@12 (|Set#Union| a@@12 b@@7)) (|Set#Union| a@@12 b@@7)))) :qid |DafnyPre.528:18| :skolemid |405| :pattern ( (|Set#Union| a@@12 (|Set#Union| a@@12 b@@7))) )))
(assert (forall ((a@@13 T@U) (b@@8 T@U) ) (! (let ((T@@27 (MapType0TypeInv0 (type a@@13)))) (=> (and (= (type a@@13) (MapType0Type T@@27 boolType)) (= (type b@@8) (MapType0Type T@@27 boolType))) (= (|Set#Intersection| (|Set#Intersection| a@@13 b@@8) b@@8) (|Set#Intersection| a@@13 b@@8)))) :qid |DafnyPre.530:18| :skolemid |406| :pattern ( (|Set#Intersection| (|Set#Intersection| a@@13 b@@8) b@@8)) )))
(assert (forall ((a@@14 T@U) (b@@9 T@U) ) (! (let ((T@@28 (MapType0TypeInv0 (type a@@14)))) (=> (and (= (type a@@14) (MapType0Type T@@28 boolType)) (= (type b@@9) (MapType0Type T@@28 boolType))) (= (|Set#Intersection| a@@14 (|Set#Intersection| a@@14 b@@9)) (|Set#Intersection| a@@14 b@@9)))) :qid |DafnyPre.532:18| :skolemid |407| :pattern ( (|Set#Intersection| a@@14 (|Set#Intersection| a@@14 b@@9))) )))
(assert (forall ((a@@15 T@U) (b@@10 T@U) ) (! (let ((T@@29 (MapType0TypeInv0 (type a@@15)))) (=> (and (= (type a@@15) (MapType0Type T@@29 boolType)) (= (type b@@10) (MapType0Type T@@29 boolType))) (= (+ (|Set#Card| (|Set#Union| a@@15 b@@10)) (|Set#Card| (|Set#Intersection| a@@15 b@@10))) (+ (|Set#Card| a@@15) (|Set#Card| b@@10))))) :qid |DafnyPre.534:18| :skolemid |408| :pattern ( (|Set#Card| (|Set#Union| a@@15 b@@10))) :pattern ( (|Set#Card| (|Set#Intersection| a@@15 b@@10))) )))
(assert (forall ((a@@16 T@U) (b@@11 T@U) (o@@7 T@U) ) (! (let ((T@@30 (type o@@7))) (=> (and (= (type a@@16) (MapType0Type T@@30 boolType)) (= (type b@@11) (MapType0Type T@@30 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)) (and (U_2_bool (MapType0Select a@@16 o@@7)) (not (U_2_bool (MapType0Select b@@11 o@@7))))) (=> (and (U_2_bool (MapType0Select a@@16 o@@7)) (not (U_2_bool (MapType0Select b@@11 o@@7)))) (U_2_bool (MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)))))) :qid |DafnyPre.538:18| :skolemid |409| :pattern ( (MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)) )))
(assert (forall ((a@@17 T@U) (b@@12 T@U) (y@@4 T@U) ) (! (let ((T@@31 (type y@@4))) (=> (and (and (= (type a@@17) (MapType0Type T@@31 boolType)) (= (type b@@12) (MapType0Type T@@31 boolType))) (U_2_bool (MapType0Select b@@12 y@@4))) (not (U_2_bool (MapType0Select (|Set#Difference| a@@17 b@@12) y@@4))))) :qid |DafnyPre.540:18| :skolemid |410| :pattern ( (|Set#Difference| a@@17 b@@12) (MapType0Select b@@12 y@@4)) )))
(assert (forall ((a@@18 T@U) (b@@13 T@U) ) (! (let ((T@@32 (MapType0TypeInv0 (type a@@18)))) (=> (and (= (type a@@18) (MapType0Type T@@32 boolType)) (= (type b@@13) (MapType0Type T@@32 boolType))) (and (= (+ (+ (|Set#Card| (|Set#Difference| a@@18 b@@13)) (|Set#Card| (|Set#Difference| b@@13 a@@18))) (|Set#Card| (|Set#Intersection| a@@18 b@@13))) (|Set#Card| (|Set#Union| a@@18 b@@13))) (= (|Set#Card| (|Set#Difference| a@@18 b@@13)) (- (|Set#Card| a@@18) (|Set#Card| (|Set#Intersection| a@@18 b@@13))))))) :qid |DafnyPre.542:18| :skolemid |411| :pattern ( (|Set#Card| (|Set#Difference| a@@18 b@@13))) )))
(assert (forall ((a@@19 T@U) (b@@14 T@U) ) (! (let ((T@@33 (MapType0TypeInv0 (type a@@19)))) (=> (and (= (type a@@19) (MapType0Type T@@33 boolType)) (= (type b@@14) (MapType0Type T@@33 boolType))) (and (=> (|Set#Subset| a@@19 b@@14) (forall ((o@@8 T@U) ) (!  (=> (and (= (type o@@8) T@@33) (U_2_bool (MapType0Select a@@19 o@@8))) (U_2_bool (MapType0Select b@@14 o@@8))) :qid |DafnyPre.551:32| :skolemid |412| :pattern ( (MapType0Select a@@19 o@@8)) :pattern ( (MapType0Select b@@14 o@@8)) ))) (=> (forall ((o@@9 T@U) ) (!  (=> (and (= (type o@@9) T@@33) (U_2_bool (MapType0Select a@@19 o@@9))) (U_2_bool (MapType0Select b@@14 o@@9))) :qid |DafnyPre.551:32| :skolemid |412| :pattern ( (MapType0Select a@@19 o@@9)) :pattern ( (MapType0Select b@@14 o@@9)) )) (|Set#Subset| a@@19 b@@14))))) :qid |DafnyPre.550:17| :skolemid |413| :pattern ( (|Set#Subset| a@@19 b@@14)) )))
(assert (forall ((a@@20 T@U) (b@@15 T@U) ) (! (let ((T@@34 (MapType0TypeInv0 (type a@@20)))) (=> (and (= (type a@@20) (MapType0Type T@@34 boolType)) (= (type b@@15) (MapType0Type T@@34 boolType))) (and (=> (|Set#Equal| a@@20 b@@15) (forall ((o@@10 T@U) ) (!  (=> (= (type o@@10) T@@34) (and (=> (U_2_bool (MapType0Select a@@20 o@@10)) (U_2_bool (MapType0Select b@@15 o@@10))) (=> (U_2_bool (MapType0Select b@@15 o@@10)) (U_2_bool (MapType0Select a@@20 o@@10))))) :qid |DafnyPre.559:31| :skolemid |414| :pattern ( (MapType0Select a@@20 o@@10)) :pattern ( (MapType0Select b@@15 o@@10)) ))) (=> (forall ((o@@11 T@U) ) (!  (=> (= (type o@@11) T@@34) (and (=> (U_2_bool (MapType0Select a@@20 o@@11)) (U_2_bool (MapType0Select b@@15 o@@11))) (=> (U_2_bool (MapType0Select b@@15 o@@11)) (U_2_bool (MapType0Select a@@20 o@@11))))) :qid |DafnyPre.559:31| :skolemid |414| :pattern ( (MapType0Select a@@20 o@@11)) :pattern ( (MapType0Select b@@15 o@@11)) )) (|Set#Equal| a@@20 b@@15))))) :qid |DafnyPre.558:17| :skolemid |415| :pattern ( (|Set#Equal| a@@20 b@@15)) )))
(assert (forall ((a@@21 T@U) (b@@16 T@U) ) (! (let ((T@@35 (MapType0TypeInv0 (type a@@21)))) (=> (and (and (= (type a@@21) (MapType0Type T@@35 boolType)) (= (type b@@16) (MapType0Type T@@35 boolType))) (|Set#Equal| a@@21 b@@16)) (= a@@21 b@@16))) :qid |DafnyPre.560:17| :skolemid |416| :pattern ( (|Set#Equal| a@@21 b@@16)) )))
(assert (forall ((a@@22 T@U) (b@@17 T@U) ) (! (let ((T@@36 (MapType0TypeInv0 (type a@@22)))) (=> (and (= (type a@@22) (MapType0Type T@@36 boolType)) (= (type b@@17) (MapType0Type T@@36 boolType))) (and (=> (|Set#Disjoint| a@@22 b@@17) (forall ((o@@12 T@U) ) (!  (=> (= (type o@@12) T@@36) (or (not (U_2_bool (MapType0Select a@@22 o@@12))) (not (U_2_bool (MapType0Select b@@17 o@@12))))) :qid |DafnyPre.565:34| :skolemid |417| :pattern ( (MapType0Select a@@22 o@@12)) :pattern ( (MapType0Select b@@17 o@@12)) ))) (=> (forall ((o@@13 T@U) ) (!  (=> (= (type o@@13) T@@36) (or (not (U_2_bool (MapType0Select a@@22 o@@13))) (not (U_2_bool (MapType0Select b@@17 o@@13))))) :qid |DafnyPre.565:34| :skolemid |417| :pattern ( (MapType0Select a@@22 o@@13)) :pattern ( (MapType0Select b@@17 o@@13)) )) (|Set#Disjoint| a@@22 b@@17))))) :qid |DafnyPre.564:18| :skolemid |418| :pattern ( (|Set#Disjoint| a@@22 b@@17)) )))
(assert (forall ((T@@37 T@T) ) (! (= (type (|ISet#Empty| T@@37)) (MapType0Type T@@37 boolType)) :qid |funType:ISet#Empty| :pattern ( (|ISet#Empty| T@@37)) )))
(assert (forall ((o@@14 T@U) ) (! (let ((T@@38 (type o@@14))) (not (U_2_bool (MapType0Select (|ISet#Empty| T@@38) o@@14)))) :qid |DafnyPre.574:18| :skolemid |419| :pattern ( (let ((T@@38 (type o@@14))) (MapType0Select (|ISet#Empty| T@@38) o@@14))) )))
(assert (forall ((arg0@@65 T@U) (arg1@@23 T@U) ) (! (let ((T@@39 (type arg1@@23))) (= (type (|ISet#UnionOne| arg0@@65 arg1@@23)) (MapType0Type T@@39 boolType))) :qid |funType:ISet#UnionOne| :pattern ( (|ISet#UnionOne| arg0@@65 arg1@@23)) )))
(assert (forall ((a@@23 T@U) (x@@21 T@U) (o@@15 T@U) ) (! (let ((T@@40 (type x@@21))) (=> (and (= (type a@@23) (MapType0Type T@@40 boolType)) (= (type o@@15) T@@40)) (and (=> (U_2_bool (MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)) (or (= o@@15 x@@21) (U_2_bool (MapType0Select a@@23 o@@15)))) (=> (or (= o@@15 x@@21) (U_2_bool (MapType0Select a@@23 o@@15))) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)))))) :qid |DafnyPre.581:18| :skolemid |420| :pattern ( (MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)) )))
(assert (forall ((a@@24 T@U) (x@@22 T@U) ) (! (let ((T@@41 (type x@@22))) (=> (= (type a@@24) (MapType0Type T@@41 boolType)) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@24 x@@22) x@@22)))) :qid |DafnyPre.583:18| :skolemid |421| :pattern ( (|ISet#UnionOne| a@@24 x@@22)) )))
(assert (forall ((a@@25 T@U) (x@@23 T@U) (y@@5 T@U) ) (! (let ((T@@42 (type x@@23))) (=> (and (and (= (type a@@25) (MapType0Type T@@42 boolType)) (= (type y@@5) T@@42)) (U_2_bool (MapType0Select a@@25 y@@5))) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@25 x@@23) y@@5)))) :qid |DafnyPre.585:18| :skolemid |422| :pattern ( (|ISet#UnionOne| a@@25 x@@23) (MapType0Select a@@25 y@@5)) )))
(assert (forall ((arg0@@66 T@U) (arg1@@24 T@U) ) (! (let ((T@@43 (MapType0TypeInv0 (type arg0@@66)))) (= (type (|ISet#Union| arg0@@66 arg1@@24)) (MapType0Type T@@43 boolType))) :qid |funType:ISet#Union| :pattern ( (|ISet#Union| arg0@@66 arg1@@24)) )))
(assert (forall ((a@@26 T@U) (b@@18 T@U) (o@@16 T@U) ) (! (let ((T@@44 (type o@@16))) (=> (and (= (type a@@26) (MapType0Type T@@44 boolType)) (= (type b@@18) (MapType0Type T@@44 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)) (or (U_2_bool (MapType0Select a@@26 o@@16)) (U_2_bool (MapType0Select b@@18 o@@16)))) (=> (or (U_2_bool (MapType0Select a@@26 o@@16)) (U_2_bool (MapType0Select b@@18 o@@16))) (U_2_bool (MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)))))) :qid |DafnyPre.589:18| :skolemid |423| :pattern ( (MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)) )))
(assert (forall ((a@@27 T@U) (b@@19 T@U) (y@@6 T@U) ) (! (let ((T@@45 (type y@@6))) (=> (and (and (= (type a@@27) (MapType0Type T@@45 boolType)) (= (type b@@19) (MapType0Type T@@45 boolType))) (U_2_bool (MapType0Select a@@27 y@@6))) (U_2_bool (MapType0Select (|ISet#Union| a@@27 b@@19) y@@6)))) :qid |DafnyPre.591:18| :skolemid |424| :pattern ( (|ISet#Union| a@@27 b@@19) (MapType0Select a@@27 y@@6)) )))
(assert (forall ((a@@28 T@U) (b@@20 T@U) (y@@7 T@U) ) (! (let ((T@@46 (type y@@7))) (=> (and (and (= (type a@@28) (MapType0Type T@@46 boolType)) (= (type b@@20) (MapType0Type T@@46 boolType))) (U_2_bool (MapType0Select b@@20 y@@7))) (U_2_bool (MapType0Select (|ISet#Union| a@@28 b@@20) y@@7)))) :qid |DafnyPre.593:18| :skolemid |425| :pattern ( (|ISet#Union| a@@28 b@@20) (MapType0Select b@@20 y@@7)) )))
(assert (forall ((arg0@@67 T@U) (arg1@@25 T@U) ) (! (let ((T@@47 (MapType0TypeInv0 (type arg0@@67)))) (= (type (|ISet#Difference| arg0@@67 arg1@@25)) (MapType0Type T@@47 boolType))) :qid |funType:ISet#Difference| :pattern ( (|ISet#Difference| arg0@@67 arg1@@25)) )))
(assert (forall ((a@@29 T@U) (b@@21 T@U) ) (! (let ((T@@48 (MapType0TypeInv0 (type a@@29)))) (=> (and (and (= (type a@@29) (MapType0Type T@@48 boolType)) (= (type b@@21) (MapType0Type T@@48 boolType))) (|ISet#Disjoint| a@@29 b@@21)) (and (= (|ISet#Difference| (|ISet#Union| a@@29 b@@21) a@@29) b@@21) (= (|ISet#Difference| (|ISet#Union| a@@29 b@@21) b@@21) a@@29)))) :qid |DafnyPre.595:18| :skolemid |426| :pattern ( (|ISet#Union| a@@29 b@@21)) )))
(assert (forall ((arg0@@68 T@U) (arg1@@26 T@U) ) (! (let ((T@@49 (MapType0TypeInv0 (type arg0@@68)))) (= (type (|ISet#Intersection| arg0@@68 arg1@@26)) (MapType0Type T@@49 boolType))) :qid |funType:ISet#Intersection| :pattern ( (|ISet#Intersection| arg0@@68 arg1@@26)) )))
(assert (forall ((a@@30 T@U) (b@@22 T@U) (o@@17 T@U) ) (! (let ((T@@50 (type o@@17))) (=> (and (= (type a@@30) (MapType0Type T@@50 boolType)) (= (type b@@22) (MapType0Type T@@50 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)) (and (U_2_bool (MapType0Select a@@30 o@@17)) (U_2_bool (MapType0Select b@@22 o@@17)))) (=> (and (U_2_bool (MapType0Select a@@30 o@@17)) (U_2_bool (MapType0Select b@@22 o@@17))) (U_2_bool (MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)))))) :qid |DafnyPre.605:18| :skolemid |427| :pattern ( (MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)) )))
(assert (forall ((a@@31 T@U) (b@@23 T@U) ) (! (let ((T@@51 (MapType0TypeInv0 (type a@@31)))) (=> (and (= (type a@@31) (MapType0Type T@@51 boolType)) (= (type b@@23) (MapType0Type T@@51 boolType))) (= (|ISet#Union| (|ISet#Union| a@@31 b@@23) b@@23) (|ISet#Union| a@@31 b@@23)))) :qid |DafnyPre.608:18| :skolemid |428| :pattern ( (|ISet#Union| (|ISet#Union| a@@31 b@@23) b@@23)) )))
(assert (forall ((a@@32 T@U) (b@@24 T@U) ) (! (let ((T@@52 (MapType0TypeInv0 (type a@@32)))) (=> (and (= (type a@@32) (MapType0Type T@@52 boolType)) (= (type b@@24) (MapType0Type T@@52 boolType))) (= (|ISet#Union| a@@32 (|ISet#Union| a@@32 b@@24)) (|ISet#Union| a@@32 b@@24)))) :qid |DafnyPre.610:18| :skolemid |429| :pattern ( (|ISet#Union| a@@32 (|ISet#Union| a@@32 b@@24))) )))
(assert (forall ((a@@33 T@U) (b@@25 T@U) ) (! (let ((T@@53 (MapType0TypeInv0 (type a@@33)))) (=> (and (= (type a@@33) (MapType0Type T@@53 boolType)) (= (type b@@25) (MapType0Type T@@53 boolType))) (= (|ISet#Intersection| (|ISet#Intersection| a@@33 b@@25) b@@25) (|ISet#Intersection| a@@33 b@@25)))) :qid |DafnyPre.612:18| :skolemid |430| :pattern ( (|ISet#Intersection| (|ISet#Intersection| a@@33 b@@25) b@@25)) )))
(assert (forall ((a@@34 T@U) (b@@26 T@U) ) (! (let ((T@@54 (MapType0TypeInv0 (type a@@34)))) (=> (and (= (type a@@34) (MapType0Type T@@54 boolType)) (= (type b@@26) (MapType0Type T@@54 boolType))) (= (|ISet#Intersection| a@@34 (|ISet#Intersection| a@@34 b@@26)) (|ISet#Intersection| a@@34 b@@26)))) :qid |DafnyPre.614:18| :skolemid |431| :pattern ( (|ISet#Intersection| a@@34 (|ISet#Intersection| a@@34 b@@26))) )))
(assert (forall ((a@@35 T@U) (b@@27 T@U) (o@@18 T@U) ) (! (let ((T@@55 (type o@@18))) (=> (and (= (type a@@35) (MapType0Type T@@55 boolType)) (= (type b@@27) (MapType0Type T@@55 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)) (and (U_2_bool (MapType0Select a@@35 o@@18)) (not (U_2_bool (MapType0Select b@@27 o@@18))))) (=> (and (U_2_bool (MapType0Select a@@35 o@@18)) (not (U_2_bool (MapType0Select b@@27 o@@18)))) (U_2_bool (MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)))))) :qid |DafnyPre.619:18| :skolemid |432| :pattern ( (MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)) )))
(assert (forall ((a@@36 T@U) (b@@28 T@U) (y@@8 T@U) ) (! (let ((T@@56 (type y@@8))) (=> (and (and (= (type a@@36) (MapType0Type T@@56 boolType)) (= (type b@@28) (MapType0Type T@@56 boolType))) (U_2_bool (MapType0Select b@@28 y@@8))) (not (U_2_bool (MapType0Select (|ISet#Difference| a@@36 b@@28) y@@8))))) :qid |DafnyPre.621:18| :skolemid |433| :pattern ( (|ISet#Difference| a@@36 b@@28) (MapType0Select b@@28 y@@8)) )))
(assert (forall ((a@@37 T@U) (b@@29 T@U) ) (! (let ((T@@57 (MapType0TypeInv0 (type a@@37)))) (=> (and (= (type a@@37) (MapType0Type T@@57 boolType)) (= (type b@@29) (MapType0Type T@@57 boolType))) (and (=> (|ISet#Subset| a@@37 b@@29) (forall ((o@@19 T@U) ) (!  (=> (and (= (type o@@19) T@@57) (U_2_bool (MapType0Select a@@37 o@@19))) (U_2_bool (MapType0Select b@@29 o@@19))) :qid |DafnyPre.626:33| :skolemid |434| :pattern ( (MapType0Select a@@37 o@@19)) :pattern ( (MapType0Select b@@29 o@@19)) ))) (=> (forall ((o@@20 T@U) ) (!  (=> (and (= (type o@@20) T@@57) (U_2_bool (MapType0Select a@@37 o@@20))) (U_2_bool (MapType0Select b@@29 o@@20))) :qid |DafnyPre.626:33| :skolemid |434| :pattern ( (MapType0Select a@@37 o@@20)) :pattern ( (MapType0Select b@@29 o@@20)) )) (|ISet#Subset| a@@37 b@@29))))) :qid |DafnyPre.625:17| :skolemid |435| :pattern ( (|ISet#Subset| a@@37 b@@29)) )))
(assert (forall ((a@@38 T@U) (b@@30 T@U) ) (! (let ((T@@58 (MapType0TypeInv0 (type a@@38)))) (=> (and (= (type a@@38) (MapType0Type T@@58 boolType)) (= (type b@@30) (MapType0Type T@@58 boolType))) (and (=> (|ISet#Equal| a@@38 b@@30) (forall ((o@@21 T@U) ) (!  (=> (= (type o@@21) T@@58) (and (=> (U_2_bool (MapType0Select a@@38 o@@21)) (U_2_bool (MapType0Select b@@30 o@@21))) (=> (U_2_bool (MapType0Select b@@30 o@@21)) (U_2_bool (MapType0Select a@@38 o@@21))))) :qid |DafnyPre.634:32| :skolemid |436| :pattern ( (MapType0Select a@@38 o@@21)) :pattern ( (MapType0Select b@@30 o@@21)) ))) (=> (forall ((o@@22 T@U) ) (!  (=> (= (type o@@22) T@@58) (and (=> (U_2_bool (MapType0Select a@@38 o@@22)) (U_2_bool (MapType0Select b@@30 o@@22))) (=> (U_2_bool (MapType0Select b@@30 o@@22)) (U_2_bool (MapType0Select a@@38 o@@22))))) :qid |DafnyPre.634:32| :skolemid |436| :pattern ( (MapType0Select a@@38 o@@22)) :pattern ( (MapType0Select b@@30 o@@22)) )) (|ISet#Equal| a@@38 b@@30))))) :qid |DafnyPre.633:17| :skolemid |437| :pattern ( (|ISet#Equal| a@@38 b@@30)) )))
(assert (forall ((a@@39 T@U) (b@@31 T@U) ) (! (let ((T@@59 (MapType0TypeInv0 (type a@@39)))) (=> (and (and (= (type a@@39) (MapType0Type T@@59 boolType)) (= (type b@@31) (MapType0Type T@@59 boolType))) (|ISet#Equal| a@@39 b@@31)) (= a@@39 b@@31))) :qid |DafnyPre.635:17| :skolemid |438| :pattern ( (|ISet#Equal| a@@39 b@@31)) )))
(assert (forall ((a@@40 T@U) (b@@32 T@U) ) (! (let ((T@@60 (MapType0TypeInv0 (type a@@40)))) (=> (and (= (type a@@40) (MapType0Type T@@60 boolType)) (= (type b@@32) (MapType0Type T@@60 boolType))) (and (=> (|ISet#Disjoint| a@@40 b@@32) (forall ((o@@23 T@U) ) (!  (=> (= (type o@@23) T@@60) (or (not (U_2_bool (MapType0Select a@@40 o@@23))) (not (U_2_bool (MapType0Select b@@32 o@@23))))) :qid |DafnyPre.640:35| :skolemid |439| :pattern ( (MapType0Select a@@40 o@@23)) :pattern ( (MapType0Select b@@32 o@@23)) ))) (=> (forall ((o@@24 T@U) ) (!  (=> (= (type o@@24) T@@60) (or (not (U_2_bool (MapType0Select a@@40 o@@24))) (not (U_2_bool (MapType0Select b@@32 o@@24))))) :qid |DafnyPre.640:35| :skolemid |439| :pattern ( (MapType0Select a@@40 o@@24)) :pattern ( (MapType0Select b@@32 o@@24)) )) (|ISet#Disjoint| a@@40 b@@32))))) :qid |DafnyPre.639:18| :skolemid |440| :pattern ( (|ISet#Disjoint| a@@40 b@@32)) )))
(assert (forall ((a@@41 Int) (b@@33 Int) ) (!  (and (=> (<= a@@41 b@@33) (= (|Math#min| a@@41 b@@33) a@@41)) (=> (= (|Math#min| a@@41 b@@33) a@@41) (<= a@@41 b@@33))) :qid |DafnyPre.647:15| :skolemid |441| :pattern ( (|Math#min| a@@41 b@@33)) )))
(assert (forall ((a@@42 Int) (b@@34 Int) ) (!  (and (=> (<= b@@34 a@@42) (= (|Math#min| a@@42 b@@34) b@@34)) (=> (= (|Math#min| a@@42 b@@34) b@@34) (<= b@@34 a@@42))) :qid |DafnyPre.648:15| :skolemid |442| :pattern ( (|Math#min| a@@42 b@@34)) )))
(assert (forall ((a@@43 Int) (b@@35 Int) ) (!  (or (= (|Math#min| a@@43 b@@35) a@@43) (= (|Math#min| a@@43 b@@35) b@@35)) :qid |DafnyPre.649:15| :skolemid |443| :pattern ( (|Math#min| a@@43 b@@35)) )))
(assert (forall ((a@@44 Int) ) (!  (=> (<= 0 a@@44) (= (|Math#clip| a@@44) a@@44)) :qid |DafnyPre.652:15| :skolemid |444| :pattern ( (|Math#clip| a@@44)) )))
(assert (forall ((a@@45 Int) ) (!  (=> (< a@@45 0) (= (|Math#clip| a@@45) 0)) :qid |DafnyPre.653:15| :skolemid |445| :pattern ( (|Math#clip| a@@45)) )))
(assert (forall ((ms T@U) ) (! (let ((T@@61 (MapType0TypeInv0 (type ms)))) (=> (= (type ms) (MapType0Type T@@61 intType)) (and (=> ($IsGoodMultiSet ms) (forall ((bx@@31 T@U) ) (!  (=> (= (type bx@@31) T@@61) (and (<= 0 (U_2_int (MapType0Select ms bx@@31))) (<= (U_2_int (MapType0Select ms bx@@31)) (|MultiSet#Card| ms)))) :qid |DafnyPre.661:11| :skolemid |446| :pattern ( (MapType0Select ms bx@@31)) ))) (=> (forall ((bx@@32 T@U) ) (!  (=> (= (type bx@@32) T@@61) (and (<= 0 (U_2_int (MapType0Select ms bx@@32))) (<= (U_2_int (MapType0Select ms bx@@32)) (|MultiSet#Card| ms)))) :qid |DafnyPre.661:11| :skolemid |446| :pattern ( (MapType0Select ms bx@@32)) )) ($IsGoodMultiSet ms))))) :qid |DafnyPre.659:18| :skolemid |447| :pattern ( ($IsGoodMultiSet ms)) )))
(assert (forall ((s@@5 T@U) ) (! (let ((T@@62 (MapType0TypeInv0 (type s@@5)))) (=> (= (type s@@5) (MapType0Type T@@62 intType)) (<= 0 (|MultiSet#Card| s@@5)))) :qid |DafnyPre.664:18| :skolemid |448| :pattern ( (|MultiSet#Card| s@@5)) )))
(assert (forall ((s@@6 T@U) (x@@24 T@U) (n@@0 T@U) ) (! (let ((T@@63 (type x@@24))) (=> (and (and (= (type s@@6) (MapType0Type T@@63 intType)) (= (type n@@0) intType)) (<= 0 (U_2_int n@@0))) (= (|MultiSet#Card| (MapType0Store s@@6 x@@24 n@@0)) (+ (- (|MultiSet#Card| s@@6) (U_2_int (MapType0Select s@@6 x@@24))) (U_2_int n@@0))))) :qid |DafnyPre.665:18| :skolemid |449| :pattern ( (|MultiSet#Card| (MapType0Store s@@6 x@@24 n@@0))) )))
(assert (forall ((T@@64 T@T) ) (! (= (type (|MultiSet#Empty| T@@64)) (MapType0Type T@@64 intType)) :qid |funType:MultiSet#Empty| :pattern ( (|MultiSet#Empty| T@@64)) )))
(assert (forall ((o@@25 T@U) ) (! (let ((T@@65 (type o@@25))) (= (U_2_int (MapType0Select (|MultiSet#Empty| T@@65) o@@25)) 0)) :qid |DafnyPre.669:18| :skolemid |450| :pattern ( (let ((T@@65 (type o@@25))) (MapType0Select (|MultiSet#Empty| T@@65) o@@25))) )))
(assert (forall ((s@@7 T@U) ) (! (let ((T@@66 (MapType0TypeInv0 (type s@@7)))) (=> (= (type s@@7) (MapType0Type T@@66 intType)) (and (and (=> (= (|MultiSet#Card| s@@7) 0) (= s@@7 (|MultiSet#Empty| T@@66))) (=> (= s@@7 (|MultiSet#Empty| T@@66)) (= (|MultiSet#Card| s@@7) 0))) (=> (not (= (|MultiSet#Card| s@@7) 0)) (exists ((x@@25 T@U) ) (!  (and (= (type x@@25) T@@66) (< 0 (U_2_int (MapType0Select s@@7 x@@25)))) :qid |DafnyPre.672:38| :skolemid |451| :no-pattern (type x@@25) :no-pattern (U_2_int x@@25) :no-pattern (U_2_bool x@@25) )))))) :qid |DafnyPre.670:18| :skolemid |452| :pattern ( (|MultiSet#Card| s@@7)) )))
(assert (forall ((arg0@@69 T@U) ) (! (let ((T@@67 (type arg0@@69))) (= (type (|MultiSet#Singleton| arg0@@69)) (MapType0Type T@@67 intType))) :qid |funType:MultiSet#Singleton| :pattern ( (|MultiSet#Singleton| arg0@@69)) )))
(assert (forall ((r@@3 T@U) (o@@26 T@U) ) (! (let ((T@@68 (type r@@3))) (=> (= (type o@@26) T@@68) (and (and (=> (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 1) (= r@@3 o@@26)) (=> (= r@@3 o@@26) (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 1))) (and (=> (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 0) (not (= r@@3 o@@26))) (=> (not (= r@@3 o@@26)) (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 0)))))) :qid |DafnyPre.675:18| :skolemid |453| :pattern ( (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) )))
(assert (forall ((arg0@@70 T@U) (arg1@@27 T@U) ) (! (let ((T@@69 (type arg1@@27))) (= (type (|MultiSet#UnionOne| arg0@@70 arg1@@27)) (MapType0Type T@@69 intType))) :qid |funType:MultiSet#UnionOne| :pattern ( (|MultiSet#UnionOne| arg0@@70 arg1@@27)) )))
(assert (forall ((r@@4 T@U) ) (! (let ((T@@70 (type r@@4))) (= (|MultiSet#Singleton| r@@4) (|MultiSet#UnionOne| (|MultiSet#Empty| T@@70) r@@4))) :qid |DafnyPre.677:18| :skolemid |454| :pattern ( (|MultiSet#Singleton| r@@4)) )))
(assert (forall ((a@@46 T@U) (x@@26 T@U) (o@@27 T@U) ) (! (let ((T@@71 (type x@@26))) (=> (and (= (type a@@46) (MapType0Type T@@71 intType)) (= (type o@@27) T@@71)) (and (=> (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27))) (or (= o@@27 x@@26) (< 0 (U_2_int (MapType0Select a@@46 o@@27))))) (=> (or (= o@@27 x@@26) (< 0 (U_2_int (MapType0Select a@@46 o@@27)))) (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27))))))) :qid |DafnyPre.681:18| :skolemid |455| :pattern ( (MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27)) )))
(assert (forall ((a@@47 T@U) (x@@27 T@U) ) (! (let ((T@@72 (type x@@27))) (=> (= (type a@@47) (MapType0Type T@@72 intType)) (= (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@47 x@@27) x@@27)) (+ (U_2_int (MapType0Select a@@47 x@@27)) 1)))) :qid |DafnyPre.684:18| :skolemid |456| :pattern ( (|MultiSet#UnionOne| a@@47 x@@27)) )))
(assert (forall ((a@@48 T@U) (x@@28 T@U) (y@@9 T@U) ) (! (let ((T@@73 (type x@@28))) (=> (and (and (= (type a@@48) (MapType0Type T@@73 intType)) (= (type y@@9) T@@73)) (< 0 (U_2_int (MapType0Select a@@48 y@@9)))) (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@48 x@@28) y@@9))))) :qid |DafnyPre.687:18| :skolemid |457| :pattern ( (|MultiSet#UnionOne| a@@48 x@@28) (MapType0Select a@@48 y@@9)) )))
(assert (forall ((a@@49 T@U) (x@@29 T@U) (y@@10 T@U) ) (! (let ((T@@74 (type x@@29))) (=> (and (and (= (type a@@49) (MapType0Type T@@74 intType)) (= (type y@@10) T@@74)) (not (= x@@29 y@@10))) (= (U_2_int (MapType0Select a@@49 y@@10)) (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@49 x@@29) y@@10))))) :qid |DafnyPre.690:18| :skolemid |458| :pattern ( (|MultiSet#UnionOne| a@@49 x@@29) (MapType0Select a@@49 y@@10)) )))
(assert (forall ((a@@50 T@U) (x@@30 T@U) ) (! (let ((T@@75 (type x@@30))) (=> (= (type a@@50) (MapType0Type T@@75 intType)) (= (|MultiSet#Card| (|MultiSet#UnionOne| a@@50 x@@30)) (+ (|MultiSet#Card| a@@50) 1)))) :qid |DafnyPre.692:18| :skolemid |459| :pattern ( (|MultiSet#Card| (|MultiSet#UnionOne| a@@50 x@@30))) )))
(assert (forall ((arg0@@71 T@U) (arg1@@28 T@U) ) (! (let ((T@@76 (MapType0TypeInv0 (type arg0@@71)))) (= (type (|MultiSet#Union| arg0@@71 arg1@@28)) (MapType0Type T@@76 intType))) :qid |funType:MultiSet#Union| :pattern ( (|MultiSet#Union| arg0@@71 arg1@@28)) )))
(assert (forall ((a@@51 T@U) (b@@36 T@U) (o@@28 T@U) ) (! (let ((T@@77 (type o@@28))) (=> (and (= (type a@@51) (MapType0Type T@@77 intType)) (= (type b@@36) (MapType0Type T@@77 intType))) (= (U_2_int (MapType0Select (|MultiSet#Union| a@@51 b@@36) o@@28)) (+ (U_2_int (MapType0Select a@@51 o@@28)) (U_2_int (MapType0Select b@@36 o@@28)))))) :qid |DafnyPre.698:18| :skolemid |460| :pattern ( (MapType0Select (|MultiSet#Union| a@@51 b@@36) o@@28)) )))
(assert (forall ((a@@52 T@U) (b@@37 T@U) ) (! (let ((T@@78 (MapType0TypeInv0 (type a@@52)))) (=> (and (= (type a@@52) (MapType0Type T@@78 intType)) (= (type b@@37) (MapType0Type T@@78 intType))) (= (|MultiSet#Card| (|MultiSet#Union| a@@52 b@@37)) (+ (|MultiSet#Card| a@@52) (|MultiSet#Card| b@@37))))) :qid |DafnyPre.700:18| :skolemid |461| :pattern ( (|MultiSet#Card| (|MultiSet#Union| a@@52 b@@37))) )))
(assert (forall ((arg0@@72 T@U) (arg1@@29 T@U) ) (! (let ((T@@79 (MapType0TypeInv0 (type arg0@@72)))) (= (type (|MultiSet#Intersection| arg0@@72 arg1@@29)) (MapType0Type T@@79 intType))) :qid |funType:MultiSet#Intersection| :pattern ( (|MultiSet#Intersection| arg0@@72 arg1@@29)) )))
(assert (forall ((a@@53 T@U) (b@@38 T@U) (o@@29 T@U) ) (! (let ((T@@80 (type o@@29))) (=> (and (= (type a@@53) (MapType0Type T@@80 intType)) (= (type b@@38) (MapType0Type T@@80 intType))) (= (U_2_int (MapType0Select (|MultiSet#Intersection| a@@53 b@@38) o@@29)) (|Math#min| (U_2_int (MapType0Select a@@53 o@@29)) (U_2_int (MapType0Select b@@38 o@@29)))))) :qid |DafnyPre.704:18| :skolemid |462| :pattern ( (MapType0Select (|MultiSet#Intersection| a@@53 b@@38) o@@29)) )))
(assert (forall ((a@@54 T@U) (b@@39 T@U) ) (! (let ((T@@81 (MapType0TypeInv0 (type a@@54)))) (=> (and (= (type a@@54) (MapType0Type T@@81 intType)) (= (type b@@39) (MapType0Type T@@81 intType))) (= (|MultiSet#Intersection| (|MultiSet#Intersection| a@@54 b@@39) b@@39) (|MultiSet#Intersection| a@@54 b@@39)))) :qid |DafnyPre.708:18| :skolemid |463| :pattern ( (|MultiSet#Intersection| (|MultiSet#Intersection| a@@54 b@@39) b@@39)) )))
(assert (forall ((a@@55 T@U) (b@@40 T@U) ) (! (let ((T@@82 (MapType0TypeInv0 (type a@@55)))) (=> (and (= (type a@@55) (MapType0Type T@@82 intType)) (= (type b@@40) (MapType0Type T@@82 intType))) (= (|MultiSet#Intersection| a@@55 (|MultiSet#Intersection| a@@55 b@@40)) (|MultiSet#Intersection| a@@55 b@@40)))) :qid |DafnyPre.710:18| :skolemid |464| :pattern ( (|MultiSet#Intersection| a@@55 (|MultiSet#Intersection| a@@55 b@@40))) )))
(assert (forall ((arg0@@73 T@U) (arg1@@30 T@U) ) (! (let ((T@@83 (MapType0TypeInv0 (type arg0@@73)))) (= (type (|MultiSet#Difference| arg0@@73 arg1@@30)) (MapType0Type T@@83 intType))) :qid |funType:MultiSet#Difference| :pattern ( (|MultiSet#Difference| arg0@@73 arg1@@30)) )))
(assert (forall ((a@@56 T@U) (b@@41 T@U) (o@@30 T@U) ) (! (let ((T@@84 (type o@@30))) (=> (and (= (type a@@56) (MapType0Type T@@84 intType)) (= (type b@@41) (MapType0Type T@@84 intType))) (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@56 b@@41) o@@30)) (|Math#clip| (- (U_2_int (MapType0Select a@@56 o@@30)) (U_2_int (MapType0Select b@@41 o@@30))))))) :qid |DafnyPre.715:18| :skolemid |465| :pattern ( (MapType0Select (|MultiSet#Difference| a@@56 b@@41) o@@30)) )))
(assert (forall ((a@@57 T@U) (b@@42 T@U) (y@@11 T@U) ) (! (let ((T@@85 (type y@@11))) (=> (and (and (= (type a@@57) (MapType0Type T@@85 intType)) (= (type b@@42) (MapType0Type T@@85 intType))) (<= (U_2_int (MapType0Select a@@57 y@@11)) (U_2_int (MapType0Select b@@42 y@@11)))) (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@57 b@@42) y@@11)) 0))) :qid |DafnyPre.717:18| :skolemid |466| :pattern ( (|MultiSet#Difference| a@@57 b@@42) (MapType0Select b@@42 y@@11) (MapType0Select a@@57 y@@11)) )))
(assert (forall ((a@@58 T@U) (b@@43 T@U) ) (! (let ((T@@86 (MapType0TypeInv0 (type a@@58)))) (=> (and (= (type a@@58) (MapType0Type T@@86 intType)) (= (type b@@43) (MapType0Type T@@86 intType))) (and (= (+ (+ (|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43)) (|MultiSet#Card| (|MultiSet#Difference| b@@43 a@@58))) (* 2 (|MultiSet#Card| (|MultiSet#Intersection| a@@58 b@@43)))) (|MultiSet#Card| (|MultiSet#Union| a@@58 b@@43))) (= (|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43)) (- (|MultiSet#Card| a@@58) (|MultiSet#Card| (|MultiSet#Intersection| a@@58 b@@43))))))) :qid |DafnyPre.719:18| :skolemid |467| :pattern ( (|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43))) )))
(assert (forall ((a@@59 T@U) (b@@44 T@U) ) (! (let ((T@@87 (MapType0TypeInv0 (type a@@59)))) (=> (and (= (type a@@59) (MapType0Type T@@87 intType)) (= (type b@@44) (MapType0Type T@@87 intType))) (and (=> (|MultiSet#Subset| a@@59 b@@44) (forall ((o@@31 T@U) ) (!  (=> (= (type o@@31) T@@87) (<= (U_2_int (MapType0Select a@@59 o@@31)) (U_2_int (MapType0Select b@@44 o@@31)))) :qid |DafnyPre.729:37| :skolemid |468| :pattern ( (MapType0Select a@@59 o@@31)) :pattern ( (MapType0Select b@@44 o@@31)) ))) (=> (forall ((o@@32 T@U) ) (!  (=> (= (type o@@32) T@@87) (<= (U_2_int (MapType0Select a@@59 o@@32)) (U_2_int (MapType0Select b@@44 o@@32)))) :qid |DafnyPre.729:37| :skolemid |468| :pattern ( (MapType0Select a@@59 o@@32)) :pattern ( (MapType0Select b@@44 o@@32)) )) (|MultiSet#Subset| a@@59 b@@44))))) :qid |DafnyPre.728:17| :skolemid |469| :pattern ( (|MultiSet#Subset| a@@59 b@@44)) )))
(assert (forall ((a@@60 T@U) (b@@45 T@U) ) (! (let ((T@@88 (MapType0TypeInv0 (type a@@60)))) (=> (and (= (type a@@60) (MapType0Type T@@88 intType)) (= (type b@@45) (MapType0Type T@@88 intType))) (and (=> (|MultiSet#Equal| a@@60 b@@45) (forall ((o@@33 T@U) ) (!  (=> (= (type o@@33) T@@88) (= (U_2_int (MapType0Select a@@60 o@@33)) (U_2_int (MapType0Select b@@45 o@@33)))) :qid |DafnyPre.733:36| :skolemid |470| :pattern ( (MapType0Select a@@60 o@@33)) :pattern ( (MapType0Select b@@45 o@@33)) ))) (=> (forall ((o@@34 T@U) ) (!  (=> (= (type o@@34) T@@88) (= (U_2_int (MapType0Select a@@60 o@@34)) (U_2_int (MapType0Select b@@45 o@@34)))) :qid |DafnyPre.733:36| :skolemid |470| :pattern ( (MapType0Select a@@60 o@@34)) :pattern ( (MapType0Select b@@45 o@@34)) )) (|MultiSet#Equal| a@@60 b@@45))))) :qid |DafnyPre.732:17| :skolemid |471| :pattern ( (|MultiSet#Equal| a@@60 b@@45)) )))
(assert (forall ((a@@61 T@U) (b@@46 T@U) ) (! (let ((T@@89 (MapType0TypeInv0 (type a@@61)))) (=> (and (and (= (type a@@61) (MapType0Type T@@89 intType)) (= (type b@@46) (MapType0Type T@@89 intType))) (|MultiSet#Equal| a@@61 b@@46)) (= a@@61 b@@46))) :qid |DafnyPre.735:17| :skolemid |472| :pattern ( (|MultiSet#Equal| a@@61 b@@46)) )))
(assert (forall ((a@@62 T@U) (b@@47 T@U) ) (! (let ((T@@90 (MapType0TypeInv0 (type a@@62)))) (=> (and (= (type a@@62) (MapType0Type T@@90 intType)) (= (type b@@47) (MapType0Type T@@90 intType))) (and (=> (|MultiSet#Disjoint| a@@62 b@@47) (forall ((o@@35 T@U) ) (!  (=> (= (type o@@35) T@@90) (or (= (U_2_int (MapType0Select a@@62 o@@35)) 0) (= (U_2_int (MapType0Select b@@47 o@@35)) 0))) :qid |DafnyPre.740:39| :skolemid |473| :pattern ( (MapType0Select a@@62 o@@35)) :pattern ( (MapType0Select b@@47 o@@35)) ))) (=> (forall ((o@@36 T@U) ) (!  (=> (= (type o@@36) T@@90) (or (= (U_2_int (MapType0Select a@@62 o@@36)) 0) (= (U_2_int (MapType0Select b@@47 o@@36)) 0))) :qid |DafnyPre.740:39| :skolemid |473| :pattern ( (MapType0Select a@@62 o@@36)) :pattern ( (MapType0Select b@@47 o@@36)) )) (|MultiSet#Disjoint| a@@62 b@@47))))) :qid |DafnyPre.739:18| :skolemid |474| :pattern ( (|MultiSet#Disjoint| a@@62 b@@47)) )))
(assert (forall ((arg0@@74 T@U) ) (! (let ((T@@91 (MapType0TypeInv0 (type arg0@@74)))) (= (type (|MultiSet#FromSet| arg0@@74)) (MapType0Type T@@91 intType))) :qid |funType:MultiSet#FromSet| :pattern ( (|MultiSet#FromSet| arg0@@74)) )))
(assert (forall ((s@@8 T@U) (a@@63 T@U) ) (! (let ((T@@92 (type a@@63))) (=> (= (type s@@8) (MapType0Type T@@92 boolType)) (and (and (=> (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 0) (not (U_2_bool (MapType0Select s@@8 a@@63)))) (=> (not (U_2_bool (MapType0Select s@@8 a@@63))) (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 0))) (and (=> (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 1) (U_2_bool (MapType0Select s@@8 a@@63))) (=> (U_2_bool (MapType0Select s@@8 a@@63)) (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 1)))))) :qid |DafnyPre.744:18| :skolemid |475| :pattern ( (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) )))
(assert (forall ((s@@9 T@U) ) (! (let ((T@@93 (MapType0TypeInv0 (type s@@9)))) (=> (= (type s@@9) (MapType0Type T@@93 boolType)) (= (|MultiSet#Card| (|MultiSet#FromSet| s@@9)) (|Set#Card| s@@9)))) :qid |DafnyPre.747:18| :skolemid |476| :pattern ( (|MultiSet#Card| (|MultiSet#FromSet| s@@9))) )))
(assert (forall ((arg0@@75 T@U) ) (! (let ((T@@94 (SeqTypeInv0 (type arg0@@75)))) (= (type (|MultiSet#FromSeq| arg0@@75)) (MapType0Type T@@94 intType))) :qid |funType:MultiSet#FromSeq| :pattern ( (|MultiSet#FromSeq| arg0@@75)) )))
(assert (forall ((s@@10 T@U) ) (! (let ((T@@95 (SeqTypeInv0 (type s@@10)))) (=> (= (type s@@10) (SeqType T@@95)) ($IsGoodMultiSet (|MultiSet#FromSeq| s@@10)))) :qid |DafnyPre.753:18| :skolemid |477| :pattern ( (|MultiSet#FromSeq| s@@10)) )))
(assert (forall ((s@@11 T@U) ) (! (let ((T@@96 (SeqTypeInv0 (type s@@11)))) (=> (= (type s@@11) (SeqType T@@96)) (= (|MultiSet#Card| (|MultiSet#FromSeq| s@@11)) (|Seq#Length| s@@11)))) :qid |DafnyPre.755:18| :skolemid |478| :pattern ( (|MultiSet#Card| (|MultiSet#FromSeq| s@@11))) )))
(assert (forall ((arg0@@76 T@U) (arg1@@31 T@U) ) (! (let ((T@@97 (type arg1@@31))) (= (type (|Seq#Build| arg0@@76 arg1@@31)) (SeqType T@@97))) :qid |funType:Seq#Build| :pattern ( (|Seq#Build| arg0@@76 arg1@@31)) )))
(assert (forall ((s@@12 T@U) (v@@23 T@U) ) (! (let ((T@@98 (type v@@23))) (=> (= (type s@@12) (SeqType T@@98)) (= (|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@23)) (|MultiSet#UnionOne| (|MultiSet#FromSeq| s@@12) v@@23)))) :qid |DafnyPre.759:18| :skolemid |479| :pattern ( (|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@23))) )))
(assert (forall ((T@@99 T@T) ) (! (= (type (|Seq#Empty| T@@99)) (SeqType T@@99)) :qid |funType:Seq#Empty| :pattern ( (|Seq#Empty| T@@99)) )))
(assert (forall ((T@@100 T@T) ) (! (= (|MultiSet#FromSeq| (|Seq#Empty| T@@100)) (|MultiSet#Empty| T@@100)) :skolemid |480| )))
(assert (forall ((arg0@@77 T@U) (arg1@@32 T@U) ) (! (let ((T@@101 (SeqTypeInv0 (type arg0@@77)))) (= (type (|Seq#Append| arg0@@77 arg1@@32)) (SeqType T@@101))) :qid |funType:Seq#Append| :pattern ( (|Seq#Append| arg0@@77 arg1@@32)) )))
(assert (forall ((a@@64 T@U) (b@@48 T@U) ) (! (let ((T@@102 (SeqTypeInv0 (type a@@64)))) (=> (and (= (type a@@64) (SeqType T@@102)) (= (type b@@48) (SeqType T@@102))) (= (|MultiSet#FromSeq| (|Seq#Append| a@@64 b@@48)) (|MultiSet#Union| (|MultiSet#FromSeq| a@@64) (|MultiSet#FromSeq| b@@48))))) :qid |DafnyPre.766:18| :skolemid |481| :pattern ( (|MultiSet#FromSeq| (|Seq#Append| a@@64 b@@48))) )))
(assert (forall ((arg0@@78 T@U) (arg1@@33 Int) (arg2@@2 T@U) ) (! (let ((T@@103 (type arg2@@2))) (= (type (|Seq#Update| arg0@@78 arg1@@33 arg2@@2)) (SeqType T@@103))) :qid |funType:Seq#Update| :pattern ( (|Seq#Update| arg0@@78 arg1@@33 arg2@@2)) )))
(assert (forall ((s@@13 T@U) (i@@8 Int) (v@@24 T@U) (x@@31 T@U) ) (! (let ((T@@104 (type v@@24))) (=> (and (and (= (type s@@13) (SeqType T@@104)) (= (type x@@31) T@@104)) (and (<= 0 i@@8) (< i@@8 (|Seq#Length| s@@13)))) (= (U_2_int (MapType0Select (|MultiSet#FromSeq| (|Seq#Update| s@@13 i@@8 v@@24)) x@@31)) (U_2_int (MapType0Select (|MultiSet#Union| (|MultiSet#Difference| (|MultiSet#FromSeq| s@@13) (|MultiSet#Singleton| (|Seq#Index| s@@13 i@@8))) (|MultiSet#Singleton| v@@24)) x@@31))))) :qid |DafnyPre.771:18| :skolemid |482| :pattern ( (MapType0Select (|MultiSet#FromSeq| (|Seq#Update| s@@13 i@@8 v@@24)) x@@31)) )))
(assert (forall ((s@@14 T@U) (x@@32 T@U) ) (! (let ((T@@105 (type x@@32))) (=> (= (type s@@14) (SeqType T@@105)) (and (=> (exists ((i@@9 Int) ) (!  (and (and (<= 0 i@@9) (< i@@9 (|Seq#Length| s@@14))) (= x@@32 (|Seq#Index| s@@14 i@@9))) :qid |DafnyPre.778:11| :skolemid |483| :pattern ( (|Seq#Index| s@@14 i@@9)) )) (< 0 (U_2_int (MapType0Select (|MultiSet#FromSeq| s@@14) x@@32)))) (=> (< 0 (U_2_int (MapType0Select (|MultiSet#FromSeq| s@@14) x@@32))) (exists ((i@@10 Int) ) (!  (and (and (<= 0 i@@10) (< i@@10 (|Seq#Length| s@@14))) (= x@@32 (|Seq#Index| s@@14 i@@10))) :qid |DafnyPre.778:11| :skolemid |483| :pattern ( (|Seq#Index| s@@14 i@@10)) )))))) :qid |DafnyPre.777:18| :skolemid |484| :pattern ( (MapType0Select (|MultiSet#FromSeq| s@@14) x@@32)) )))
(assert (forall ((s@@15 T@U) ) (! (let ((T@@106 (SeqTypeInv0 (type s@@15)))) (=> (= (type s@@15) (SeqType T@@106)) (<= 0 (|Seq#Length| s@@15)))) :qid |DafnyPre.787:18| :skolemid |485| :pattern ( (|Seq#Length| s@@15)) )))
(assert (forall ((T@@107 T@T) ) (! (= (|Seq#Length| (|Seq#Empty| T@@107)) 0) :skolemid |486| )))
(assert (forall ((s@@16 T@U) ) (! (let ((T@@108 (SeqTypeInv0 (type s@@16)))) (=> (and (= (type s@@16) (SeqType T@@108)) (= (|Seq#Length| s@@16) 0)) (= s@@16 (|Seq#Empty| T@@108)))) :qid |DafnyPre.791:18| :skolemid |487| :pattern ( (|Seq#Length| s@@16)) )))
(assert (forall ((t@@23 T@U) (T@@109 T@T) ) (!  (=> (= (type t@@23) TyType) ($Is (|Seq#Empty| T@@109) t@@23)) :qid |DafnyPre.801:18| :skolemid |488| :pattern ( ($Is (|Seq#Empty| T@@109) t@@23)) )))
(assert (forall ((arg0@@79 T@U) ) (! (let ((T@@110 (type arg0@@79))) (= (type (|Seq#Singleton| arg0@@79)) (SeqType T@@110))) :qid |funType:Seq#Singleton| :pattern ( (|Seq#Singleton| arg0@@79)) )))
(assert (forall ((t@@24 T@U) ) (! (= (|Seq#Length| (|Seq#Singleton| t@@24)) 1) :qid |DafnyPre.804:18| :skolemid |489| :pattern ( (|Seq#Length| (|Seq#Singleton| t@@24))) )))
(assert  (and (forall ((arg0@@80 T@U) ) (! (let ((T@@111 (SeqTypeInv0 (type arg0@@80)))) (= (type (|Seq#Build_inv0| arg0@@80)) (SeqType T@@111))) :qid |funType:Seq#Build_inv0| :pattern ( (|Seq#Build_inv0| arg0@@80)) )) (forall ((arg0@@81 T@U) ) (! (let ((T@@112 (SeqTypeInv0 (type arg0@@81)))) (= (type (|Seq#Build_inv1| arg0@@81)) T@@112)) :qid |funType:Seq#Build_inv1| :pattern ( (|Seq#Build_inv1| arg0@@81)) ))))
(assert (forall ((s@@17 T@U) (val@@6 T@U) ) (! (let ((T@@113 (type val@@6))) (=> (= (type s@@17) (SeqType T@@113)) (and (= (|Seq#Build_inv0| (|Seq#Build| s@@17 val@@6)) s@@17) (= (|Seq#Build_inv1| (|Seq#Build| s@@17 val@@6)) val@@6)))) :qid |DafnyPre.809:18| :skolemid |490| :pattern ( (|Seq#Build| s@@17 val@@6)) )))
(assert (forall ((s@@18 T@U) (v@@25 T@U) ) (! (let ((T@@114 (type v@@25))) (=> (= (type s@@18) (SeqType T@@114)) (= (|Seq#Length| (|Seq#Build| s@@18 v@@25)) (+ 1 (|Seq#Length| s@@18))))) :qid |DafnyPre.814:18| :skolemid |491| :pattern ( (|Seq#Length| (|Seq#Build| s@@18 v@@25))) )))
(assert (forall ((s@@19 T@U) (i@@11 Int) (v@@26 T@U) ) (! (let ((T@@115 (type v@@26))) (=> (= (type s@@19) (SeqType T@@115)) (and (=> (= i@@11 (|Seq#Length| s@@19)) (= (|Seq#Index| (|Seq#Build| s@@19 v@@26) i@@11) v@@26)) (=> (not (= i@@11 (|Seq#Length| s@@19))) (= (|Seq#Index| (|Seq#Build| s@@19 v@@26) i@@11) (|Seq#Index| s@@19 i@@11)))))) :qid |DafnyPre.816:18| :skolemid |492| :pattern ( (|Seq#Index| (|Seq#Build| s@@19 v@@26) i@@11)) )))
(assert (forall ((s@@20 T@U) (bx@@33 T@U) (t@@25 T@U) ) (!  (=> (and (and (and (= (type s@@20) (SeqType BoxType)) (= (type bx@@33) BoxType)) (= (type t@@25) TyType)) (and ($Is s@@20 (TSeq t@@25)) ($IsBox bx@@33 t@@25))) ($Is (|Seq#Build| s@@20 bx@@33) (TSeq t@@25))) :qid |DafnyPre.821:15| :skolemid |493| :pattern ( ($Is (|Seq#Build| s@@20 bx@@33) (TSeq t@@25))) )))
(assert (forall ((s0 T@U) (s1 T@U) ) (! (let ((T@@116 (SeqTypeInv0 (type s0)))) (=> (and (= (type s0) (SeqType T@@116)) (= (type s1) (SeqType T@@116))) (= (|Seq#Length| (|Seq#Append| s0 s1)) (+ (|Seq#Length| s0) (|Seq#Length| s1))))) :qid |DafnyPre.825:18| :skolemid |494| :pattern ( (|Seq#Length| (|Seq#Append| s0 s1))) )))
(assert (forall ((s0@@0 T@U) (s1@@0 T@U) (t@@26 T@U) ) (!  (=> (and (and (and (= (type s0@@0) (SeqType BoxType)) (= (type s1@@0) (SeqType BoxType))) (= (type t@@26) TyType)) (and ($Is s0@@0 t@@26) ($Is s1@@0 t@@26))) ($Is (|Seq#Append| s0@@0 s1@@0) t@@26)) :qid |DafnyPre.829:15| :skolemid |495| :pattern ( ($Is (|Seq#Append| s0@@0 s1@@0) t@@26)) )))
(assert (forall ((t@@27 T@U) ) (! (= (|Seq#Index| (|Seq#Singleton| t@@27) 0) t@@27) :qid |DafnyPre.833:18| :skolemid |496| :pattern ( (|Seq#Index| (|Seq#Singleton| t@@27) 0)) )))
(assert (forall ((s0@@1 T@U) (s1@@1 T@U) (n@@1 Int) ) (! (let ((T@@117 (SeqTypeInv0 (type s0@@1)))) (=> (and (= (type s0@@1) (SeqType T@@117)) (= (type s1@@1) (SeqType T@@117))) (and (=> (< n@@1 (|Seq#Length| s0@@1)) (= (|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1) (|Seq#Index| s0@@1 n@@1))) (=> (<= (|Seq#Length| s0@@1) n@@1) (= (|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1) (|Seq#Index| s1@@1 (- n@@1 (|Seq#Length| s0@@1)))))))) :qid |DafnyPre.834:18| :skolemid |497| :pattern ( (|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1)) )))
(assert (forall ((s@@21 T@U) (i@@12 Int) (v@@27 T@U) ) (! (let ((T@@118 (type v@@27))) (=> (= (type s@@21) (SeqType T@@118)) (=> (and (<= 0 i@@12) (< i@@12 (|Seq#Length| s@@21))) (= (|Seq#Length| (|Seq#Update| s@@21 i@@12 v@@27)) (|Seq#Length| s@@21))))) :qid |DafnyPre.839:18| :skolemid |498| :pattern ( (|Seq#Length| (|Seq#Update| s@@21 i@@12 v@@27))) )))
(assert (forall ((s@@22 T@U) (i@@13 Int) (v@@28 T@U) (n@@2 Int) ) (! (let ((T@@119 (type v@@28))) (=> (= (type s@@22) (SeqType T@@119)) (=> (and (<= 0 n@@2) (< n@@2 (|Seq#Length| s@@22))) (and (=> (= i@@13 n@@2) (= (|Seq#Index| (|Seq#Update| s@@22 i@@13 v@@28) n@@2) v@@28)) (=> (not (= i@@13 n@@2)) (= (|Seq#Index| (|Seq#Update| s@@22 i@@13 v@@28) n@@2) (|Seq#Index| s@@22 n@@2))))))) :qid |DafnyPre.841:18| :skolemid |499| :pattern ( (|Seq#Index| (|Seq#Update| s@@22 i@@13 v@@28) n@@2)) )))
(assert (forall ((s@@23 T@U) (x@@33 T@U) ) (! (let ((T@@120 (type x@@33))) (=> (= (type s@@23) (SeqType T@@120)) (and (=> (|Seq#Contains| s@@23 x@@33) (exists ((i@@14 Int) ) (!  (and (and (<= 0 i@@14) (< i@@14 (|Seq#Length| s@@23))) (= (|Seq#Index| s@@23 i@@14) x@@33)) :qid |DafnyPre.849:13| :skolemid |500| :pattern ( (|Seq#Index| s@@23 i@@14)) ))) (=> (exists ((i@@15 Int) ) (!  (and (and (<= 0 i@@15) (< i@@15 (|Seq#Length| s@@23))) (= (|Seq#Index| s@@23 i@@15) x@@33)) :qid |DafnyPre.849:13| :skolemid |500| :pattern ( (|Seq#Index| s@@23 i@@15)) )) (|Seq#Contains| s@@23 x@@33))))) :qid |DafnyPre.847:18| :skolemid |501| :pattern ( (|Seq#Contains| s@@23 x@@33)) )))
(assert (forall ((x@@34 T@U) ) (! (let ((T@@121 (type x@@34))) (not (|Seq#Contains| (|Seq#Empty| T@@121) x@@34))) :qid |DafnyPre.850:18| :skolemid |502| :pattern ( (let ((T@@121 (type x@@34))) (|Seq#Contains| (|Seq#Empty| T@@121) x@@34))) )))
(assert (forall ((s0@@2 T@U) (s1@@2 T@U) (x@@35 T@U) ) (! (let ((T@@122 (type x@@35))) (=> (and (= (type s0@@2) (SeqType T@@122)) (= (type s1@@2) (SeqType T@@122))) (and (=> (|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35) (or (|Seq#Contains| s0@@2 x@@35) (|Seq#Contains| s1@@2 x@@35))) (=> (or (|Seq#Contains| s0@@2 x@@35) (|Seq#Contains| s1@@2 x@@35)) (|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35))))) :qid |DafnyPre.854:18| :skolemid |503| :pattern ( (|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35)) )))
(assert (forall ((s@@24 T@U) (v@@29 T@U) (x@@36 T@U) ) (! (let ((T@@123 (type v@@29))) (=> (and (= (type s@@24) (SeqType T@@123)) (= (type x@@36) T@@123)) (and (=> (|Seq#Contains| (|Seq#Build| s@@24 v@@29) x@@36) (or (= v@@29 x@@36) (|Seq#Contains| s@@24 x@@36))) (=> (or (= v@@29 x@@36) (|Seq#Contains| s@@24 x@@36)) (|Seq#Contains| (|Seq#Build| s@@24 v@@29) x@@36))))) :qid |DafnyPre.859:18| :skolemid |504| :pattern ( (|Seq#Contains| (|Seq#Build| s@@24 v@@29) x@@36)) )))
(assert (forall ((arg0@@82 T@U) (arg1@@34 Int) ) (! (let ((T@@124 (SeqTypeInv0 (type arg0@@82)))) (= (type (|Seq#Take| arg0@@82 arg1@@34)) (SeqType T@@124))) :qid |funType:Seq#Take| :pattern ( (|Seq#Take| arg0@@82 arg1@@34)) )))
(assert (forall ((s@@25 T@U) (n@@3 Int) (x@@37 T@U) ) (! (let ((T@@125 (type x@@37))) (=> (= (type s@@25) (SeqType T@@125)) (and (=> (|Seq#Contains| (|Seq#Take| s@@25 n@@3) x@@37) (exists ((i@@16 Int) ) (!  (and (and (and (<= 0 i@@16) (< i@@16 n@@3)) (< i@@16 (|Seq#Length| s@@25))) (= (|Seq#Index| s@@25 i@@16) x@@37)) :qid |DafnyPre.866:13| :skolemid |505| :pattern ( (|Seq#Index| s@@25 i@@16)) ))) (=> (exists ((i@@17 Int) ) (!  (and (and (and (<= 0 i@@17) (< i@@17 n@@3)) (< i@@17 (|Seq#Length| s@@25))) (= (|Seq#Index| s@@25 i@@17) x@@37)) :qid |DafnyPre.866:13| :skolemid |505| :pattern ( (|Seq#Index| s@@25 i@@17)) )) (|Seq#Contains| (|Seq#Take| s@@25 n@@3) x@@37))))) :qid |DafnyPre.863:18| :skolemid |506| :pattern ( (|Seq#Contains| (|Seq#Take| s@@25 n@@3) x@@37)) )))
(assert (forall ((arg0@@83 T@U) (arg1@@35 Int) ) (! (let ((T@@126 (SeqTypeInv0 (type arg0@@83)))) (= (type (|Seq#Drop| arg0@@83 arg1@@35)) (SeqType T@@126))) :qid |funType:Seq#Drop| :pattern ( (|Seq#Drop| arg0@@83 arg1@@35)) )))
(assert (forall ((s@@26 T@U) (n@@4 Int) (x@@38 T@U) ) (! (let ((T@@127 (type x@@38))) (=> (= (type s@@26) (SeqType T@@127)) (and (=> (|Seq#Contains| (|Seq#Drop| s@@26 n@@4) x@@38) (exists ((i@@18 Int) ) (!  (and (and (and (<= 0 n@@4) (<= n@@4 i@@18)) (< i@@18 (|Seq#Length| s@@26))) (= (|Seq#Index| s@@26 i@@18) x@@38)) :qid |DafnyPre.871:13| :skolemid |507| :pattern ( (|Seq#Index| s@@26 i@@18)) ))) (=> (exists ((i@@19 Int) ) (!  (and (and (and (<= 0 n@@4) (<= n@@4 i@@19)) (< i@@19 (|Seq#Length| s@@26))) (= (|Seq#Index| s@@26 i@@19) x@@38)) :qid |DafnyPre.871:13| :skolemid |507| :pattern ( (|Seq#Index| s@@26 i@@19)) )) (|Seq#Contains| (|Seq#Drop| s@@26 n@@4) x@@38))))) :qid |DafnyPre.868:18| :skolemid |508| :pattern ( (|Seq#Contains| (|Seq#Drop| s@@26 n@@4) x@@38)) )))
(assert (forall ((s0@@3 T@U) (s1@@3 T@U) ) (! (let ((T@@128 (SeqTypeInv0 (type s0@@3)))) (=> (and (= (type s0@@3) (SeqType T@@128)) (= (type s1@@3) (SeqType T@@128))) (and (=> (|Seq#Equal| s0@@3 s1@@3) (and (= (|Seq#Length| s0@@3) (|Seq#Length| s1@@3)) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|Seq#Length| s0@@3))) (= (|Seq#Index| s0@@3 j) (|Seq#Index| s1@@3 j))) :qid |DafnyPre.878:13| :skolemid |509| :pattern ( (|Seq#Index| s0@@3 j)) :pattern ( (|Seq#Index| s1@@3 j)) )))) (=> (and (= (|Seq#Length| s0@@3) (|Seq#Length| s1@@3)) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|Seq#Length| s0@@3))) (= (|Seq#Index| s0@@3 j@@0) (|Seq#Index| s1@@3 j@@0))) :qid |DafnyPre.878:13| :skolemid |509| :pattern ( (|Seq#Index| s0@@3 j@@0)) :pattern ( (|Seq#Index| s1@@3 j@@0)) ))) (|Seq#Equal| s0@@3 s1@@3))))) :qid |DafnyPre.875:18| :skolemid |510| :pattern ( (|Seq#Equal| s0@@3 s1@@3)) )))
(assert (forall ((a@@65 T@U) (b@@49 T@U) ) (! (let ((T@@129 (SeqTypeInv0 (type a@@65)))) (=> (and (and (= (type a@@65) (SeqType T@@129)) (= (type b@@49) (SeqType T@@129))) (|Seq#Equal| a@@65 b@@49)) (= a@@65 b@@49))) :qid |DafnyPre.880:18| :skolemid |511| :pattern ( (|Seq#Equal| a@@65 b@@49)) )))
(assert (forall ((s0@@4 T@U) (s1@@4 T@U) (n@@5 Int) ) (! (let ((T@@130 (SeqTypeInv0 (type s0@@4)))) (=> (and (= (type s0@@4) (SeqType T@@130)) (= (type s1@@4) (SeqType T@@130))) (and (=> (|Seq#SameUntil| s0@@4 s1@@4 n@@5) (forall ((j@@1 Int) ) (!  (=> (and (<= 0 j@@1) (< j@@1 n@@5)) (= (|Seq#Index| s0@@4 j@@1) (|Seq#Index| s1@@4 j@@1))) :qid |DafnyPre.886:13| :skolemid |512| :pattern ( (|Seq#Index| s0@@4 j@@1)) :pattern ( (|Seq#Index| s1@@4 j@@1)) ))) (=> (forall ((j@@2 Int) ) (!  (=> (and (<= 0 j@@2) (< j@@2 n@@5)) (= (|Seq#Index| s0@@4 j@@2) (|Seq#Index| s1@@4 j@@2))) :qid |DafnyPre.886:13| :skolemid |512| :pattern ( (|Seq#Index| s0@@4 j@@2)) :pattern ( (|Seq#Index| s1@@4 j@@2)) )) (|Seq#SameUntil| s0@@4 s1@@4 n@@5))))) :qid |DafnyPre.884:18| :skolemid |513| :pattern ( (|Seq#SameUntil| s0@@4 s1@@4 n@@5)) )))
(assert (forall ((s@@27 T@U) (n@@6 Int) ) (! (let ((T@@131 (SeqTypeInv0 (type s@@27)))) (=> (= (type s@@27) (SeqType T@@131)) (=> (and (<= 0 n@@6) (<= n@@6 (|Seq#Length| s@@27))) (= (|Seq#Length| (|Seq#Take| s@@27 n@@6)) n@@6)))) :qid |DafnyPre.890:18| :skolemid |514| :pattern ( (|Seq#Length| (|Seq#Take| s@@27 n@@6))) )))
(assert (forall ((s@@28 T@U) (n@@7 Int) (j@@3 Int) ) (! (let ((T@@132 (SeqTypeInv0 (type s@@28)))) (=> (= (type s@@28) (SeqType T@@132)) (=> (and (and (<= 0 j@@3) (< j@@3 n@@7)) (< j@@3 (|Seq#Length| s@@28))) (= (|Seq#Index| (|Seq#Take| s@@28 n@@7) j@@3) (|Seq#Index| s@@28 j@@3))))) :qid |DafnyPre.892:18| :weight 25 :skolemid |515| :pattern ( (|Seq#Index| (|Seq#Take| s@@28 n@@7) j@@3)) :pattern ( (|Seq#Index| s@@28 j@@3) (|Seq#Take| s@@28 n@@7)) )))
(assert (forall ((s@@29 T@U) (n@@8 Int) ) (! (let ((T@@133 (SeqTypeInv0 (type s@@29)))) (=> (= (type s@@29) (SeqType T@@133)) (=> (and (<= 0 n@@8) (<= n@@8 (|Seq#Length| s@@29))) (= (|Seq#Length| (|Seq#Drop| s@@29 n@@8)) (- (|Seq#Length| s@@29) n@@8))))) :qid |DafnyPre.900:18| :skolemid |516| :pattern ( (|Seq#Length| (|Seq#Drop| s@@29 n@@8))) )))
(assert (forall ((s@@30 T@U) (n@@9 Int) (j@@4 Int) ) (! (let ((T@@134 (SeqTypeInv0 (type s@@30)))) (=> (= (type s@@30) (SeqType T@@134)) (=> (and (and (<= 0 n@@9) (<= 0 j@@4)) (< j@@4 (- (|Seq#Length| s@@30) n@@9))) (= (|Seq#Index| (|Seq#Drop| s@@30 n@@9) j@@4) (|Seq#Index| s@@30 (+ j@@4 n@@9)))))) :qid |DafnyPre.902:18| :weight 25 :skolemid |517| :pattern ( (|Seq#Index| (|Seq#Drop| s@@30 n@@9) j@@4)) )))
(assert (forall ((s@@31 T@U) (n@@10 Int) (k@@3 Int) ) (! (let ((T@@135 (SeqTypeInv0 (type s@@31)))) (=> (= (type s@@31) (SeqType T@@135)) (=> (and (and (<= 0 n@@10) (<= n@@10 k@@3)) (< k@@3 (|Seq#Length| s@@31))) (= (|Seq#Index| (|Seq#Drop| s@@31 n@@10) (- k@@3 n@@10)) (|Seq#Index| s@@31 k@@3))))) :qid |DafnyPre.907:18| :weight 25 :skolemid |518| :pattern ( (|Seq#Index| s@@31 k@@3) (|Seq#Drop| s@@31 n@@10)) )))
(assert (forall ((s@@32 T@U) (t@@28 T@U) ) (! (let ((T@@136 (SeqTypeInv0 (type s@@32)))) (=> (and (= (type s@@32) (SeqType T@@136)) (= (type t@@28) (SeqType T@@136))) (and (= (|Seq#Take| (|Seq#Append| s@@32 t@@28) (|Seq#Length| s@@32)) s@@32) (= (|Seq#Drop| (|Seq#Append| s@@32 t@@28) (|Seq#Length| s@@32)) t@@28)))) :qid |DafnyPre.913:18| :skolemid |519| :pattern ( (|Seq#Append| s@@32 t@@28)) )))
(assert (forall ((arg0@@84 T@U) (arg1@@36 T@U) ) (! (= (type (|Seq#FromArray| arg0@@84 arg1@@36)) (SeqType BoxType)) :qid |funType:Seq#FromArray| :pattern ( (|Seq#FromArray| arg0@@84 arg1@@36)) )))
(assert (forall ((h@@15 T@U) (a@@66 T@U) ) (!  (=> (and (= (type h@@15) (MapType1Type refType)) (= (type a@@66) refType)) (= (|Seq#Length| (|Seq#FromArray| h@@15 a@@66)) (_System.array.Length a@@66))) :qid |DafnyPre.919:15| :skolemid |520| :pattern ( (|Seq#Length| (|Seq#FromArray| h@@15 a@@66))) )))
(assert (forall ((h@@16 T@U) (a@@67 T@U) ) (!  (=> (and (= (type h@@16) (MapType1Type refType)) (= (type a@@67) refType)) (forall ((i@@20 Int) ) (!  (=> (and (<= 0 i@@20) (< i@@20 (|Seq#Length| (|Seq#FromArray| h@@16 a@@67)))) (= (|Seq#Index| (|Seq#FromArray| h@@16 a@@67) i@@20) (MapType1Select h@@16 a@@67 (IndexField i@@20)))) :qid |DafnyPre.924:11| :skolemid |521| :pattern ( (MapType1Select h@@16 a@@67 (IndexField i@@20))) :pattern ( (|Seq#Index| (|Seq#FromArray| h@@16 a@@67) i@@20)) ))) :qid |DafnyPre.922:15| :skolemid |522| :pattern ( (|Seq#FromArray| h@@16 a@@67)) )))
(assert (forall ((h0 T@U) (h1 T@U) (a@@68 T@U) ) (!  (=> (and (and (= (type h0) (MapType1Type refType)) (= (type h1) (MapType1Type refType))) (= (type a@@68) refType)) (=> (and (and (and ($IsGoodHeap h0) ($IsGoodHeap h1)) ($HeapSucc h0 h1)) (forall ((i@@21 Int) ) (!  (=> (and (<= 0 i@@21) (< i@@21 (_System.array.Length a@@68))) (= (MapType1Select h0 a@@68 (IndexField i@@21)) (MapType1Select h1 a@@68 (IndexField i@@21)))) :qid |DafnyPre.937:11| :skolemid |523| ))) (= (|Seq#FromArray| h0 a@@68) (|Seq#FromArray| h1 a@@68)))) :qid |DafnyPre.934:15| :skolemid |524| :pattern ( (|Seq#FromArray| h1 a@@68) ($HeapSucc h0 h1)) )))
(assert (forall ((h@@17 T@U) (i@@22 Int) (v@@30 T@U) (a@@69 T@U) ) (!  (=> (and (and (and (= (type h@@17) (MapType1Type refType)) (= (type v@@30) BoxType)) (= (type a@@69) refType)) (and (<= 0 i@@22) (< i@@22 (_System.array.Length a@@69)))) (= (|Seq#FromArray| (MapType1Store h@@17 a@@69 (IndexField i@@22) v@@30) a@@69) (|Seq#Update| (|Seq#FromArray| h@@17 a@@69) i@@22 v@@30))) :qid |DafnyPre.941:15| :skolemid |525| :pattern ( (|Seq#FromArray| (MapType1Store h@@17 a@@69 (IndexField i@@22) v@@30) a@@69)) )))
(assert (forall ((s@@33 T@U) (i@@23 Int) (v@@31 T@U) (n@@11 Int) ) (! (let ((T@@137 (type v@@31))) (=> (= (type s@@33) (SeqType T@@137)) (=> (and (and (<= 0 i@@23) (< i@@23 n@@11)) (<= n@@11 (|Seq#Length| s@@33))) (= (|Seq#Take| (|Seq#Update| s@@33 i@@23 v@@31) n@@11) (|Seq#Update| (|Seq#Take| s@@33 n@@11) i@@23 v@@31))))) :qid |DafnyPre.946:18| :skolemid |526| :pattern ( (|Seq#Take| (|Seq#Update| s@@33 i@@23 v@@31) n@@11)) )))
(assert (forall ((s@@34 T@U) (i@@24 Int) (v@@32 T@U) (n@@12 Int) ) (! (let ((T@@138 (type v@@32))) (=> (= (type s@@34) (SeqType T@@138)) (=> (and (<= n@@12 i@@24) (< i@@24 (|Seq#Length| s@@34))) (= (|Seq#Take| (|Seq#Update| s@@34 i@@24 v@@32) n@@12) (|Seq#Take| s@@34 n@@12))))) :qid |DafnyPre.949:18| :skolemid |527| :pattern ( (|Seq#Take| (|Seq#Update| s@@34 i@@24 v@@32) n@@12)) )))
(assert (forall ((s@@35 T@U) (i@@25 Int) (v@@33 T@U) (n@@13 Int) ) (! (let ((T@@139 (type v@@33))) (=> (= (type s@@35) (SeqType T@@139)) (=> (and (and (<= 0 n@@13) (<= n@@13 i@@25)) (< i@@25 (|Seq#Length| s@@35))) (= (|Seq#Drop| (|Seq#Update| s@@35 i@@25 v@@33) n@@13) (|Seq#Update| (|Seq#Drop| s@@35 n@@13) (- i@@25 n@@13) v@@33))))) :qid |DafnyPre.952:18| :skolemid |528| :pattern ( (|Seq#Drop| (|Seq#Update| s@@35 i@@25 v@@33) n@@13)) )))
(assert (forall ((s@@36 T@U) (i@@26 Int) (v@@34 T@U) (n@@14 Int) ) (! (let ((T@@140 (type v@@34))) (=> (= (type s@@36) (SeqType T@@140)) (=> (and (and (<= 0 i@@26) (< i@@26 n@@14)) (< n@@14 (|Seq#Length| s@@36))) (= (|Seq#Drop| (|Seq#Update| s@@36 i@@26 v@@34) n@@14) (|Seq#Drop| s@@36 n@@14))))) :qid |DafnyPre.955:18| :skolemid |529| :pattern ( (|Seq#Drop| (|Seq#Update| s@@36 i@@26 v@@34) n@@14)) )))
(assert (forall ((h@@18 T@U) (a@@70 T@U) (n0 Int) (n1 Int) ) (!  (=> (and (= (type h@@18) (MapType1Type refType)) (= (type a@@70) refType)) (=> (and (and (= (+ n0 1) n1) (<= 0 n0)) (<= n1 (_System.array.Length a@@70))) (= (|Seq#Take| (|Seq#FromArray| h@@18 a@@70) n1) (|Seq#Build| (|Seq#Take| (|Seq#FromArray| h@@18 a@@70) n0) (MapType1Select h@@18 a@@70 (IndexField n0)))))) :qid |DafnyPre.959:15| :skolemid |530| :pattern ( (|Seq#Take| (|Seq#FromArray| h@@18 a@@70) n0) (|Seq#Take| (|Seq#FromArray| h@@18 a@@70) n1)) )))
(assert (forall ((s@@37 T@U) (v@@35 T@U) (n@@15 Int) ) (! (let ((T@@141 (type v@@35))) (=> (= (type s@@37) (SeqType T@@141)) (=> (and (<= 0 n@@15) (<= n@@15 (|Seq#Length| s@@37))) (= (|Seq#Drop| (|Seq#Build| s@@37 v@@35) n@@15) (|Seq#Build| (|Seq#Drop| s@@37 n@@15) v@@35))))) :qid |DafnyPre.963:18| :skolemid |531| :pattern ( (|Seq#Drop| (|Seq#Build| s@@37 v@@35) n@@15)) )))
(assert (forall ((s@@38 T@U) (i@@27 Int) ) (!  (=> (= (type s@@38) (SeqType BoxType)) (=> (and (<= 0 i@@27) (< i@@27 (|Seq#Length| s@@38))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@38 i@@27))) (|Seq#Rank| s@@38)))) :qid |DafnyPre.968:15| :skolemid |532| :pattern ( (DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@38 i@@27)))) )))
(assert (forall ((s@@39 T@U) (i@@28 Int) ) (! (let ((T@@142 (SeqTypeInv0 (type s@@39)))) (=> (= (type s@@39) (SeqType T@@142)) (=> (and (< 0 i@@28) (<= i@@28 (|Seq#Length| s@@39))) (< (|Seq#Rank| (|Seq#Drop| s@@39 i@@28)) (|Seq#Rank| s@@39))))) :qid |DafnyPre.971:18| :skolemid |533| :pattern ( (|Seq#Rank| (|Seq#Drop| s@@39 i@@28))) )))
(assert (forall ((s@@40 T@U) (i@@29 Int) ) (! (let ((T@@143 (SeqTypeInv0 (type s@@40)))) (=> (= (type s@@40) (SeqType T@@143)) (=> (and (<= 0 i@@29) (< i@@29 (|Seq#Length| s@@40))) (< (|Seq#Rank| (|Seq#Take| s@@40 i@@29)) (|Seq#Rank| s@@40))))) :qid |DafnyPre.974:18| :skolemid |534| :pattern ( (|Seq#Rank| (|Seq#Take| s@@40 i@@29))) )))
(assert (forall ((s@@41 T@U) (i@@30 Int) (j@@5 Int) ) (! (let ((T@@144 (SeqTypeInv0 (type s@@41)))) (=> (= (type s@@41) (SeqType T@@144)) (=> (and (and (<= 0 i@@30) (< i@@30 j@@5)) (<= j@@5 (|Seq#Length| s@@41))) (< (|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@41 i@@30) (|Seq#Drop| s@@41 j@@5))) (|Seq#Rank| s@@41))))) :qid |DafnyPre.977:18| :skolemid |535| :pattern ( (|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@41 i@@30) (|Seq#Drop| s@@41 j@@5)))) )))
(assert (forall ((s@@42 T@U) (n@@16 Int) ) (! (let ((T@@145 (SeqTypeInv0 (type s@@42)))) (=> (and (= (type s@@42) (SeqType T@@145)) (= n@@16 0)) (= (|Seq#Drop| s@@42 n@@16) s@@42))) :qid |DafnyPre.982:18| :skolemid |536| :pattern ( (|Seq#Drop| s@@42 n@@16)) )))
(assert (forall ((s@@43 T@U) (n@@17 Int) ) (! (let ((T@@146 (SeqTypeInv0 (type s@@43)))) (=> (and (= (type s@@43) (SeqType T@@146)) (= n@@17 0)) (= (|Seq#Take| s@@43 n@@17) (|Seq#Empty| T@@146)))) :qid |DafnyPre.984:18| :skolemid |537| :pattern ( (|Seq#Take| s@@43 n@@17)) )))
(assert (forall ((s@@44 T@U) (m@@6 Int) (n@@18 Int) ) (! (let ((T@@147 (SeqTypeInv0 (type s@@44)))) (=> (= (type s@@44) (SeqType T@@147)) (=> (and (and (<= 0 m@@6) (<= 0 n@@18)) (<= (+ m@@6 n@@18) (|Seq#Length| s@@44))) (= (|Seq#Drop| (|Seq#Drop| s@@44 m@@6) n@@18) (|Seq#Drop| s@@44 (+ m@@6 n@@18)))))) :qid |DafnyPre.986:18| :skolemid |538| :pattern ( (|Seq#Drop| (|Seq#Drop| s@@44 m@@6) n@@18)) )))
(assert (forall ((m@@7 T@U) ) (! (let ((V@@1 (MapTypeInv1 (type m@@7)))) (let ((U@@3 (MapTypeInv0 (type m@@7)))) (=> (= (type m@@7) (MapType U@@3 V@@1)) (<= 0 (|Map#Card| m@@7))))) :qid |DafnyPre.1004:20| :skolemid |539| :pattern ( (|Map#Card| m@@7)) )))
(assert (forall ((m@@8 T@U) ) (! (let ((V@@2 (MapTypeInv1 (type m@@8)))) (let ((U@@4 (MapTypeInv0 (type m@@8)))) (=> (= (type m@@8) (MapType U@@4 V@@2)) (= (|Set#Card| (|Map#Domain| m@@8)) (|Map#Card| m@@8))))) :qid |DafnyPre.1009:20| :skolemid |540| :pattern ( (|Set#Card| (|Map#Domain| m@@8))) )))
(assert (forall ((arg0@@85 T@U) ) (! (let ((V@@3 (MapTypeInv1 (type arg0@@85)))) (= (type (|Map#Values| arg0@@85)) (MapType0Type V@@3 boolType))) :qid |funType:Map#Values| :pattern ( (|Map#Values| arg0@@85)) )))
(assert (forall ((m@@9 T@U) ) (! (let ((V@@4 (MapTypeInv1 (type m@@9)))) (let ((U@@5 (MapTypeInv0 (type m@@9)))) (=> (= (type m@@9) (MapType U@@5 V@@4)) (= (|Set#Card| (|Map#Values| m@@9)) (|Map#Card| m@@9))))) :qid |DafnyPre.1019:20| :skolemid |541| :pattern ( (|Set#Card| (|Map#Values| m@@9))) )))
(assert (forall ((m@@10 T@U) (v@@36 T@U) ) (! (let ((V@@5 (type v@@36))) (let ((U@@6 (MapTypeInv0 (type m@@10)))) (=> (= (type m@@10) (MapType U@@6 V@@5)) (and (=> (U_2_bool (MapType0Select (|Map#Values| m@@10) v@@36)) (exists ((u@@5 T@U) ) (!  (and (= (type u@@5) U@@6) (and (U_2_bool (MapType0Select (|Map#Domain| m@@10) u@@5)) (= v@@36 (MapType0Select (|Map#Elements| m@@10) u@@5)))) :qid |DafnyPre.1024:10| :skolemid |542| :pattern ( (MapType0Select (|Map#Domain| m@@10) u@@5)) :pattern ( (MapType0Select (|Map#Elements| m@@10) u@@5)) ))) (=> (exists ((u@@6 T@U) ) (!  (and (= (type u@@6) U@@6) (and (U_2_bool (MapType0Select (|Map#Domain| m@@10) u@@6)) (= v@@36 (MapType0Select (|Map#Elements| m@@10) u@@6)))) :qid |DafnyPre.1024:10| :skolemid |542| :pattern ( (MapType0Select (|Map#Domain| m@@10) u@@6)) :pattern ( (MapType0Select (|Map#Elements| m@@10) u@@6)) )) (U_2_bool (MapType0Select (|Map#Values| m@@10) v@@36))))))) :qid |DafnyPre.1022:20| :skolemid |543| :pattern ( (MapType0Select (|Map#Values| m@@10) v@@36)) )))
(assert (forall ((arg0@@86 T@U) ) (! (= (type (|Map#Items| arg0@@86)) (MapType0Type BoxType boolType)) :qid |funType:Map#Items| :pattern ( (|Map#Items| arg0@@86)) )))
(assert (forall ((m@@11 T@U) ) (! (let ((V@@6 (MapTypeInv1 (type m@@11)))) (let ((U@@7 (MapTypeInv0 (type m@@11)))) (=> (= (type m@@11) (MapType U@@7 V@@6)) (= (|Set#Card| (|Map#Items| m@@11)) (|Map#Card| m@@11))))) :qid |DafnyPre.1043:20| :skolemid |544| :pattern ( (|Set#Card| (|Map#Items| m@@11))) )))
(assert  (and (forall ((arg0@@87 T@U) ) (! (= (type (_System.__tuple_h2._0 arg0@@87)) BoxType) :qid |funType:_System.__tuple_h2._0| :pattern ( (_System.__tuple_h2._0 arg0@@87)) )) (forall ((arg0@@88 T@U) ) (! (= (type (_System.__tuple_h2._1 arg0@@88)) BoxType) :qid |funType:_System.__tuple_h2._1| :pattern ( (_System.__tuple_h2._1 arg0@@88)) ))))
(assert (forall ((m@@12 T@U) (item T@U) ) (!  (=> (and (= (type m@@12) (MapType BoxType BoxType)) (= (type item) BoxType)) (and (=> (U_2_bool (MapType0Select (|Map#Items| m@@12) item)) (and (U_2_bool (MapType0Select (|Map#Domain| m@@12) (_System.__tuple_h2._0 ($Unbox DatatypeTypeType item)))) (= (MapType0Select (|Map#Elements| m@@12) (_System.__tuple_h2._0 ($Unbox DatatypeTypeType item))) (_System.__tuple_h2._1 ($Unbox DatatypeTypeType item))))) (=> (and (U_2_bool (MapType0Select (|Map#Domain| m@@12) (_System.__tuple_h2._0 ($Unbox DatatypeTypeType item)))) (= (MapType0Select (|Map#Elements| m@@12) (_System.__tuple_h2._0 ($Unbox DatatypeTypeType item))) (_System.__tuple_h2._1 ($Unbox DatatypeTypeType item)))) (U_2_bool (MapType0Select (|Map#Items| m@@12) item))))) :qid |DafnyPre.1046:15| :skolemid |545| :pattern ( (MapType0Select (|Map#Items| m@@12) item)) )))
(assert (forall ((U@@8 T@T) (V@@7 T@T) ) (! (= (type (|Map#Empty| U@@8 V@@7)) (MapType U@@8 V@@7)) :qid |funType:Map#Empty| :pattern ( (|Map#Empty| U@@8 V@@7)) )))
(assert (forall ((u@@7 T@U) (V@@8 T@T) ) (! (let ((U@@9 (type u@@7))) (not (U_2_bool (MapType0Select (|Map#Domain| (|Map#Empty| U@@9 V@@8)) u@@7)))) :qid |DafnyPre.1054:21| :skolemid |546| :pattern ( (let ((U@@9 (type u@@7))) (MapType0Select (|Map#Domain| (|Map#Empty| U@@9 V@@8)) u@@7))) )))
(assert (forall ((m@@13 T@U) ) (! (let ((V@@9 (MapTypeInv1 (type m@@13)))) (let ((U@@10 (MapTypeInv0 (type m@@13)))) (=> (= (type m@@13) (MapType U@@10 V@@9)) (and (and (=> (= (|Map#Card| m@@13) 0) (= m@@13 (|Map#Empty| U@@10 V@@9))) (=> (= m@@13 (|Map#Empty| U@@10 V@@9)) (= (|Map#Card| m@@13) 0))) (=> (not (= (|Map#Card| m@@13) 0)) (exists ((x@@39 T@U) ) (!  (and (= (type x@@39) U@@10) (U_2_bool (MapType0Select (|Map#Domain| m@@13) x@@39))) :qid |DafnyPre.1059:32| :skolemid |547| :no-pattern (type x@@39) :no-pattern (U_2_int x@@39) :no-pattern (U_2_bool x@@39) ))))))) :qid |DafnyPre.1057:21| :skolemid |548| :pattern ( (|Map#Card| m@@13)) )))
(assert (forall ((arg0@@89 T@U) (arg1@@37 T@U) (arg2@@3 T@U) ) (! (let ((V@@10 (MapType0TypeInv1 (type arg1@@37)))) (let ((U@@11 (MapType0TypeInv0 (type arg0@@89)))) (= (type (|Map#Glue| arg0@@89 arg1@@37 arg2@@3)) (MapType U@@11 V@@10)))) :qid |funType:Map#Glue| :pattern ( (|Map#Glue| arg0@@89 arg1@@37 arg2@@3)) )))
(assert (forall ((a@@71 T@U) (b@@50 T@U) (t@@29 T@U) ) (! (let ((V@@11 (MapType0TypeInv1 (type b@@50)))) (let ((U@@12 (MapType0TypeInv0 (type a@@71)))) (=> (and (and (= (type a@@71) (MapType0Type U@@12 boolType)) (= (type b@@50) (MapType0Type U@@12 V@@11))) (= (type t@@29) TyType)) (= (|Map#Domain| (|Map#Glue| a@@71 b@@50 t@@29)) a@@71)))) :qid |DafnyPre.1062:21| :skolemid |549| :pattern ( (|Map#Domain| (|Map#Glue| a@@71 b@@50 t@@29))) )))
(assert (forall ((a@@72 T@U) (b@@51 T@U) (t@@30 T@U) ) (! (let ((V@@12 (MapType0TypeInv1 (type b@@51)))) (let ((U@@13 (MapType0TypeInv0 (type a@@72)))) (=> (and (and (= (type a@@72) (MapType0Type U@@13 boolType)) (= (type b@@51) (MapType0Type U@@13 V@@12))) (= (type t@@30) TyType)) (= (|Map#Elements| (|Map#Glue| a@@72 b@@51 t@@30)) b@@51)))) :qid |DafnyPre.1065:21| :skolemid |550| :pattern ( (|Map#Elements| (|Map#Glue| a@@72 b@@51 t@@30))) )))
(assert (forall ((a@@73 T@U) (b@@52 T@U) (t@@31 T@U) ) (! (let ((V@@13 (MapType0TypeInv1 (type b@@52)))) (let ((U@@14 (MapType0TypeInv0 (type a@@73)))) (=> (and (and (= (type a@@73) (MapType0Type U@@14 boolType)) (= (type b@@52) (MapType0Type U@@14 V@@13))) (= (type t@@31) TyType)) ($Is (|Map#Glue| a@@73 b@@52 t@@31) t@@31)))) :qid |DafnyPre.1068:21| :skolemid |551| :pattern ( ($Is (|Map#Glue| a@@73 b@@52 t@@31) t@@31)) )))
(assert (forall ((arg0@@90 T@U) (arg1@@38 T@U) (arg2@@4 T@U) ) (! (let ((V@@14 (type arg2@@4))) (let ((U@@15 (type arg1@@38))) (= (type (|Map#Build| arg0@@90 arg1@@38 arg2@@4)) (MapType U@@15 V@@14)))) :qid |funType:Map#Build| :pattern ( (|Map#Build| arg0@@90 arg1@@38 arg2@@4)) )))
(assert (forall ((m@@14 T@U) (u@@8 T@U) (|u'| T@U) (v@@37 T@U) ) (! (let ((V@@15 (type v@@37))) (let ((U@@16 (type u@@8))) (=> (and (= (type m@@14) (MapType U@@16 V@@15)) (= (type |u'|) U@@16)) (and (=> (= |u'| u@@8) (and (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@14 u@@8 v@@37)) |u'|)) (= (MapType0Select (|Map#Elements| (|Map#Build| m@@14 u@@8 v@@37)) |u'|) v@@37))) (=> (not (= |u'| u@@8)) (and (and (=> (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@14 u@@8 v@@37)) |u'|)) (U_2_bool (MapType0Select (|Map#Domain| m@@14) |u'|))) (=> (U_2_bool (MapType0Select (|Map#Domain| m@@14) |u'|)) (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@14 u@@8 v@@37)) |u'|)))) (= (MapType0Select (|Map#Elements| (|Map#Build| m@@14 u@@8 v@@37)) |u'|) (MapType0Select (|Map#Elements| m@@14) |u'|)))))))) :qid |DafnyPre.1079:21| :skolemid |552| :pattern ( (MapType0Select (|Map#Domain| (|Map#Build| m@@14 u@@8 v@@37)) |u'|)) :pattern ( (MapType0Select (|Map#Elements| (|Map#Build| m@@14 u@@8 v@@37)) |u'|)) )))
(assert (forall ((m@@15 T@U) (u@@9 T@U) (v@@38 T@U) ) (! (let ((V@@16 (type v@@38))) (let ((U@@17 (type u@@9))) (=> (and (= (type m@@15) (MapType U@@17 V@@16)) (U_2_bool (MapType0Select (|Map#Domain| m@@15) u@@9))) (= (|Map#Card| (|Map#Build| m@@15 u@@9 v@@38)) (|Map#Card| m@@15))))) :qid |DafnyPre.1085:21| :skolemid |553| :pattern ( (|Map#Card| (|Map#Build| m@@15 u@@9 v@@38))) )))
(assert (forall ((m@@16 T@U) (u@@10 T@U) (v@@39 T@U) ) (! (let ((V@@17 (type v@@39))) (let ((U@@18 (type u@@10))) (=> (and (= (type m@@16) (MapType U@@18 V@@17)) (not (U_2_bool (MapType0Select (|Map#Domain| m@@16) u@@10)))) (= (|Map#Card| (|Map#Build| m@@16 u@@10 v@@39)) (+ (|Map#Card| m@@16) 1))))) :qid |DafnyPre.1087:21| :skolemid |554| :pattern ( (|Map#Card| (|Map#Build| m@@16 u@@10 v@@39))) )))
(assert (forall ((m@@17 T@U) (u@@11 T@U) (v@@40 T@U) ) (! (let ((V@@18 (type v@@40))) (let ((U@@19 (type u@@11))) (=> (= (type m@@17) (MapType U@@19 V@@18)) (= (|Map#Values| (|Map#Build| m@@17 u@@11 v@@40)) (|Set#UnionOne| (|Map#Values| m@@17) v@@40))))) :qid |DafnyPre.1089:21| :skolemid |555| :pattern ( (|Map#Values| (|Map#Build| m@@17 u@@11 v@@40))) )))
(assert (forall ((m@@18 T@U) (|m'| T@U) ) (! (let ((V@@19 (MapTypeInv1 (type m@@18)))) (let ((U@@20 (MapTypeInv0 (type m@@18)))) (=> (and (= (type m@@18) (MapType U@@20 V@@19)) (= (type |m'|) (MapType U@@20 V@@19))) (and (=> (|Map#Equal| m@@18 |m'|) (and (forall ((u@@12 T@U) ) (!  (=> (= (type u@@12) U@@20) (and (=> (U_2_bool (MapType0Select (|Map#Domain| m@@18) u@@12)) (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@12))) (=> (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@12)) (U_2_bool (MapType0Select (|Map#Domain| m@@18) u@@12))))) :qid |DafnyPre.1097:35| :skolemid |556| :no-pattern (type u@@12) :no-pattern (U_2_int u@@12) :no-pattern (U_2_bool u@@12) )) (forall ((u@@13 T@U) ) (!  (=> (and (= (type u@@13) U@@20) (U_2_bool (MapType0Select (|Map#Domain| m@@18) u@@13))) (= (MapType0Select (|Map#Elements| m@@18) u@@13) (MapType0Select (|Map#Elements| |m'|) u@@13))) :qid |DafnyPre.1098:35| :skolemid |557| :no-pattern (type u@@13) :no-pattern (U_2_int u@@13) :no-pattern (U_2_bool u@@13) )))) (=> (and (forall ((u@@14 T@U) ) (!  (=> (= (type u@@14) U@@20) (and (=> (U_2_bool (MapType0Select (|Map#Domain| m@@18) u@@14)) (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@14))) (=> (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@14)) (U_2_bool (MapType0Select (|Map#Domain| m@@18) u@@14))))) :qid |DafnyPre.1097:35| :skolemid |556| :no-pattern (type u@@14) :no-pattern (U_2_int u@@14) :no-pattern (U_2_bool u@@14) )) (forall ((u@@15 T@U) ) (!  (=> (and (= (type u@@15) U@@20) (U_2_bool (MapType0Select (|Map#Domain| m@@18) u@@15))) (= (MapType0Select (|Map#Elements| m@@18) u@@15) (MapType0Select (|Map#Elements| |m'|) u@@15))) :qid |DafnyPre.1098:35| :skolemid |557| :no-pattern (type u@@15) :no-pattern (U_2_int u@@15) :no-pattern (U_2_bool u@@15) ))) (|Map#Equal| m@@18 |m'|)))))) :qid |DafnyPre.1095:21| :skolemid |558| :pattern ( (|Map#Equal| m@@18 |m'|)) )))
(assert (forall ((m@@19 T@U) (|m'@@0| T@U) ) (! (let ((V@@20 (MapTypeInv1 (type m@@19)))) (let ((U@@21 (MapTypeInv0 (type m@@19)))) (=> (and (and (= (type m@@19) (MapType U@@21 V@@20)) (= (type |m'@@0|) (MapType U@@21 V@@20))) (|Map#Equal| m@@19 |m'@@0|)) (= m@@19 |m'@@0|)))) :qid |DafnyPre.1100:21| :skolemid |559| :pattern ( (|Map#Equal| m@@19 |m'@@0|)) )))
(assert (forall ((m@@20 T@U) (|m'@@1| T@U) ) (! (let ((V@@21 (MapTypeInv1 (type m@@20)))) (let ((U@@22 (MapTypeInv0 (type m@@20)))) (=> (and (= (type m@@20) (MapType U@@22 V@@21)) (= (type |m'@@1|) (MapType U@@22 V@@21))) (and (=> (|Map#Disjoint| m@@20 |m'@@1|) (forall ((o@@37 T@U) ) (!  (=> (= (type o@@37) U@@22) (or (not (U_2_bool (MapType0Select (|Map#Domain| m@@20) o@@37))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'@@1|) o@@37))))) :qid |DafnyPre.1107:38| :skolemid |560| :pattern ( (MapType0Select (|Map#Domain| m@@20) o@@37)) :pattern ( (MapType0Select (|Map#Domain| |m'@@1|) o@@37)) ))) (=> (forall ((o@@38 T@U) ) (!  (=> (= (type o@@38) U@@22) (or (not (U_2_bool (MapType0Select (|Map#Domain| m@@20) o@@38))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'@@1|) o@@38))))) :qid |DafnyPre.1107:38| :skolemid |560| :pattern ( (MapType0Select (|Map#Domain| m@@20) o@@38)) :pattern ( (MapType0Select (|Map#Domain| |m'@@1|) o@@38)) )) (|Map#Disjoint| m@@20 |m'@@1|)))))) :qid |DafnyPre.1105:21| :skolemid |561| :pattern ( (|Map#Disjoint| m@@20 |m'@@1|)) )))
(assert (forall ((arg0@@91 T@U) ) (! (let ((V@@22 (IMapTypeInv1 (type arg0@@91)))) (= (type (|IMap#Values| arg0@@91)) (MapType0Type V@@22 boolType))) :qid |funType:IMap#Values| :pattern ( (|IMap#Values| arg0@@91)) )))
(assert (forall ((m@@21 T@U) (v@@41 T@U) ) (! (let ((V@@23 (type v@@41))) (let ((U@@23 (IMapTypeInv0 (type m@@21)))) (=> (= (type m@@21) (IMapType U@@23 V@@23)) (and (=> (U_2_bool (MapType0Select (|IMap#Values| m@@21) v@@41)) (exists ((u@@16 T@U) ) (!  (and (= (type u@@16) U@@23) (and (U_2_bool (MapType0Select (|IMap#Domain| m@@21) u@@16)) (= v@@41 (MapType0Select (|IMap#Elements| m@@21) u@@16)))) :qid |DafnyPre.1130:10| :skolemid |562| :pattern ( (MapType0Select (|IMap#Domain| m@@21) u@@16)) :pattern ( (MapType0Select (|IMap#Elements| m@@21) u@@16)) ))) (=> (exists ((u@@17 T@U) ) (!  (and (= (type u@@17) U@@23) (and (U_2_bool (MapType0Select (|IMap#Domain| m@@21) u@@17)) (= v@@41 (MapType0Select (|IMap#Elements| m@@21) u@@17)))) :qid |DafnyPre.1130:10| :skolemid |562| :pattern ( (MapType0Select (|IMap#Domain| m@@21) u@@17)) :pattern ( (MapType0Select (|IMap#Elements| m@@21) u@@17)) )) (U_2_bool (MapType0Select (|IMap#Values| m@@21) v@@41))))))) :qid |DafnyPre.1128:20| :skolemid |563| :pattern ( (MapType0Select (|IMap#Values| m@@21) v@@41)) )))
(assert (forall ((arg0@@92 T@U) ) (! (= (type (|IMap#Items| arg0@@92)) (MapType0Type BoxType boolType)) :qid |funType:IMap#Items| :pattern ( (|IMap#Items| arg0@@92)) )))
(assert (forall ((m@@22 T@U) (item@@0 T@U) ) (!  (=> (and (= (type m@@22) (IMapType BoxType BoxType)) (= (type item@@0) BoxType)) (and (=> (U_2_bool (MapType0Select (|IMap#Items| m@@22) item@@0)) (and (U_2_bool (MapType0Select (|IMap#Domain| m@@22) (_System.__tuple_h2._0 ($Unbox DatatypeTypeType item@@0)))) (= (MapType0Select (|IMap#Elements| m@@22) (_System.__tuple_h2._0 ($Unbox DatatypeTypeType item@@0))) (_System.__tuple_h2._1 ($Unbox DatatypeTypeType item@@0))))) (=> (and (U_2_bool (MapType0Select (|IMap#Domain| m@@22) (_System.__tuple_h2._0 ($Unbox DatatypeTypeType item@@0)))) (= (MapType0Select (|IMap#Elements| m@@22) (_System.__tuple_h2._0 ($Unbox DatatypeTypeType item@@0))) (_System.__tuple_h2._1 ($Unbox DatatypeTypeType item@@0)))) (U_2_bool (MapType0Select (|IMap#Items| m@@22) item@@0))))) :qid |DafnyPre.1145:15| :skolemid |564| :pattern ( (MapType0Select (|IMap#Items| m@@22) item@@0)) )))
(assert (forall ((U@@24 T@T) (V@@24 T@T) ) (! (= (type (|IMap#Empty| U@@24 V@@24)) (IMapType U@@24 V@@24)) :qid |funType:IMap#Empty| :pattern ( (|IMap#Empty| U@@24 V@@24)) )))
(assert (forall ((u@@18 T@U) (V@@25 T@T) ) (! (let ((U@@25 (type u@@18))) (not (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Empty| U@@25 V@@25)) u@@18)))) :qid |DafnyPre.1152:21| :skolemid |565| :pattern ( (let ((U@@25 (type u@@18))) (MapType0Select (|IMap#Domain| (|IMap#Empty| U@@25 V@@25)) u@@18))) )))
(assert (forall ((arg0@@93 T@U) (arg1@@39 T@U) (arg2@@5 T@U) ) (! (let ((V@@26 (MapType0TypeInv1 (type arg1@@39)))) (let ((U@@26 (MapType0TypeInv0 (type arg0@@93)))) (= (type (|IMap#Glue| arg0@@93 arg1@@39 arg2@@5)) (IMapType U@@26 V@@26)))) :qid |funType:IMap#Glue| :pattern ( (|IMap#Glue| arg0@@93 arg1@@39 arg2@@5)) )))
(assert (forall ((a@@74 T@U) (b@@53 T@U) (t@@32 T@U) ) (! (let ((V@@27 (MapType0TypeInv1 (type b@@53)))) (let ((U@@27 (MapType0TypeInv0 (type a@@74)))) (=> (and (and (= (type a@@74) (MapType0Type U@@27 boolType)) (= (type b@@53) (MapType0Type U@@27 V@@27))) (= (type t@@32) TyType)) (= (|IMap#Domain| (|IMap#Glue| a@@74 b@@53 t@@32)) a@@74)))) :qid |DafnyPre.1157:21| :skolemid |566| :pattern ( (|IMap#Domain| (|IMap#Glue| a@@74 b@@53 t@@32))) )))
(assert (forall ((a@@75 T@U) (b@@54 T@U) (t@@33 T@U) ) (! (let ((V@@28 (MapType0TypeInv1 (type b@@54)))) (let ((U@@28 (MapType0TypeInv0 (type a@@75)))) (=> (and (and (= (type a@@75) (MapType0Type U@@28 boolType)) (= (type b@@54) (MapType0Type U@@28 V@@28))) (= (type t@@33) TyType)) (= (|IMap#Elements| (|IMap#Glue| a@@75 b@@54 t@@33)) b@@54)))) :qid |DafnyPre.1160:21| :skolemid |567| :pattern ( (|IMap#Elements| (|IMap#Glue| a@@75 b@@54 t@@33))) )))
(assert (forall ((a@@76 T@U) (b@@55 T@U) (t@@34 T@U) ) (! (let ((V@@29 (MapType0TypeInv1 (type b@@55)))) (let ((U@@29 (MapType0TypeInv0 (type a@@76)))) (=> (and (and (= (type a@@76) (MapType0Type U@@29 boolType)) (= (type b@@55) (MapType0Type U@@29 V@@29))) (= (type t@@34) TyType)) ($Is (|IMap#Glue| a@@76 b@@55 t@@34) t@@34)))) :qid |DafnyPre.1163:21| :skolemid |568| :pattern ( ($Is (|IMap#Glue| a@@76 b@@55 t@@34) t@@34)) )))
(assert (forall ((arg0@@94 T@U) (arg1@@40 T@U) (arg2@@6 T@U) ) (! (let ((V@@30 (type arg2@@6))) (let ((U@@30 (type arg1@@40))) (= (type (|IMap#Build| arg0@@94 arg1@@40 arg2@@6)) (IMapType U@@30 V@@30)))) :qid |funType:IMap#Build| :pattern ( (|IMap#Build| arg0@@94 arg1@@40 arg2@@6)) )))
(assert (forall ((m@@23 T@U) (u@@19 T@U) (|u'@@0| T@U) (v@@42 T@U) ) (! (let ((V@@31 (type v@@42))) (let ((U@@31 (type u@@19))) (=> (and (= (type m@@23) (IMapType U@@31 V@@31)) (= (type |u'@@0|) U@@31)) (and (=> (= |u'@@0| u@@19) (and (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@23 u@@19 v@@42)) |u'@@0|)) (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@23 u@@19 v@@42)) |u'@@0|) v@@42))) (=> (not (= |u'@@0| u@@19)) (and (and (=> (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@23 u@@19 v@@42)) |u'@@0|)) (U_2_bool (MapType0Select (|IMap#Domain| m@@23) |u'@@0|))) (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@23) |u'@@0|)) (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@23 u@@19 v@@42)) |u'@@0|)))) (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@23 u@@19 v@@42)) |u'@@0|) (MapType0Select (|IMap#Elements| m@@23) |u'@@0|)))))))) :qid |DafnyPre.1173:21| :skolemid |569| :pattern ( (MapType0Select (|IMap#Domain| (|IMap#Build| m@@23 u@@19 v@@42)) |u'@@0|)) :pattern ( (MapType0Select (|IMap#Elements| (|IMap#Build| m@@23 u@@19 v@@42)) |u'@@0|)) )))
(assert (forall ((m@@24 T@U) (u@@20 T@U) (v@@43 T@U) ) (! (let ((V@@32 (type v@@43))) (let ((U@@32 (type u@@20))) (=> (= (type m@@24) (IMapType U@@32 V@@32)) (= (|IMap#Values| (|IMap#Build| m@@24 u@@20 v@@43)) (|Set#UnionOne| (|IMap#Values| m@@24) v@@43))))) :qid |DafnyPre.1180:21| :skolemid |570| :pattern ( (|IMap#Values| (|IMap#Build| m@@24 u@@20 v@@43))) )))
(assert (forall ((m@@25 T@U) (|m'@@2| T@U) ) (! (let ((V@@33 (IMapTypeInv1 (type m@@25)))) (let ((U@@33 (IMapTypeInv0 (type m@@25)))) (=> (and (= (type m@@25) (IMapType U@@33 V@@33)) (= (type |m'@@2|) (IMapType U@@33 V@@33))) (and (=> (|IMap#Equal| m@@25 |m'@@2|) (and (forall ((u@@21 T@U) ) (!  (=> (= (type u@@21) U@@33) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@25) u@@21)) (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@21))) (=> (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@21)) (U_2_bool (MapType0Select (|IMap#Domain| m@@25) u@@21))))) :qid |DafnyPre.1187:36| :skolemid |571| :no-pattern (type u@@21) :no-pattern (U_2_int u@@21) :no-pattern (U_2_bool u@@21) )) (forall ((u@@22 T@U) ) (!  (=> (and (= (type u@@22) U@@33) (U_2_bool (MapType0Select (|IMap#Domain| m@@25) u@@22))) (= (MapType0Select (|IMap#Elements| m@@25) u@@22) (MapType0Select (|IMap#Elements| |m'@@2|) u@@22))) :qid |DafnyPre.1188:35| :skolemid |572| :no-pattern (type u@@22) :no-pattern (U_2_int u@@22) :no-pattern (U_2_bool u@@22) )))) (=> (and (forall ((u@@23 T@U) ) (!  (=> (= (type u@@23) U@@33) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@25) u@@23)) (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@23))) (=> (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@23)) (U_2_bool (MapType0Select (|IMap#Domain| m@@25) u@@23))))) :qid |DafnyPre.1187:36| :skolemid |571| :no-pattern (type u@@23) :no-pattern (U_2_int u@@23) :no-pattern (U_2_bool u@@23) )) (forall ((u@@24 T@U) ) (!  (=> (and (= (type u@@24) U@@33) (U_2_bool (MapType0Select (|IMap#Domain| m@@25) u@@24))) (= (MapType0Select (|IMap#Elements| m@@25) u@@24) (MapType0Select (|IMap#Elements| |m'@@2|) u@@24))) :qid |DafnyPre.1188:35| :skolemid |572| :no-pattern (type u@@24) :no-pattern (U_2_int u@@24) :no-pattern (U_2_bool u@@24) ))) (|IMap#Equal| m@@25 |m'@@2|)))))) :qid |DafnyPre.1185:21| :skolemid |573| :pattern ( (|IMap#Equal| m@@25 |m'@@2|)) )))
(assert (forall ((m@@26 T@U) (|m'@@3| T@U) ) (! (let ((V@@34 (IMapTypeInv1 (type m@@26)))) (let ((U@@34 (IMapTypeInv0 (type m@@26)))) (=> (and (and (= (type m@@26) (IMapType U@@34 V@@34)) (= (type |m'@@3|) (IMapType U@@34 V@@34))) (|IMap#Equal| m@@26 |m'@@3|)) (= m@@26 |m'@@3|)))) :qid |DafnyPre.1190:21| :skolemid |574| :pattern ( (|IMap#Equal| m@@26 |m'@@3|)) )))
(assert (forall ((x@@40 Int) (y@@12 Int) ) (! (= (INTERNAL_add_boogie x@@40 y@@12) (+ x@@40 y@@12)) :qid |DafnyPre.1198:30| :skolemid |575| :pattern ( (INTERNAL_add_boogie x@@40 y@@12)) )))
(assert (forall ((x@@41 Int) (y@@13 Int) ) (! (= (INTERNAL_sub_boogie x@@41 y@@13) (- x@@41 y@@13)) :qid |DafnyPre.1199:30| :skolemid |576| :pattern ( (INTERNAL_sub_boogie x@@41 y@@13)) )))
(assert (forall ((x@@42 Int) (y@@14 Int) ) (! (= (INTERNAL_mul_boogie x@@42 y@@14) (* x@@42 y@@14)) :qid |DafnyPre.1200:30| :skolemid |577| :pattern ( (INTERNAL_mul_boogie x@@42 y@@14)) )))
(assert (forall ((x@@43 Int) (y@@15 Int) ) (! (= (INTERNAL_div_boogie x@@43 y@@15) (div x@@43 y@@15)) :qid |DafnyPre.1201:30| :skolemid |578| :pattern ( (INTERNAL_div_boogie x@@43 y@@15)) )))
(assert (forall ((x@@44 Int) (y@@16 Int) ) (! (= (INTERNAL_mod_boogie x@@44 y@@16) (mod x@@44 y@@16)) :qid |DafnyPre.1202:30| :skolemid |579| :pattern ( (INTERNAL_mod_boogie x@@44 y@@16)) )))
(assert (forall ((x@@45 Int) (y@@17 Int) ) (!  (and (=> (INTERNAL_lt_boogie x@@45 y@@17) (< x@@45 y@@17)) (=> (< x@@45 y@@17) (INTERNAL_lt_boogie x@@45 y@@17))) :qid |DafnyPre.1203:51| :skolemid |580| :pattern ( (INTERNAL_lt_boogie x@@45 y@@17)) )))
(assert (forall ((x@@46 Int) (y@@18 Int) ) (!  (and (=> (INTERNAL_le_boogie x@@46 y@@18) (<= x@@46 y@@18)) (=> (<= x@@46 y@@18) (INTERNAL_le_boogie x@@46 y@@18))) :qid |DafnyPre.1204:51| :skolemid |581| :pattern ( (INTERNAL_le_boogie x@@46 y@@18)) )))
(assert (forall ((x@@47 Int) (y@@19 Int) ) (!  (and (=> (INTERNAL_gt_boogie x@@47 y@@19) (> x@@47 y@@19)) (=> (> x@@47 y@@19) (INTERNAL_gt_boogie x@@47 y@@19))) :qid |DafnyPre.1205:51| :skolemid |582| :pattern ( (INTERNAL_gt_boogie x@@47 y@@19)) )))
(assert (forall ((x@@48 Int) (y@@20 Int) ) (!  (and (=> (INTERNAL_ge_boogie x@@48 y@@20) (>= x@@48 y@@20)) (=> (>= x@@48 y@@20) (INTERNAL_ge_boogie x@@48 y@@20))) :qid |DafnyPre.1206:51| :skolemid |583| :pattern ( (INTERNAL_ge_boogie x@@48 y@@20)) )))
(assert (forall ((b@@56 (_ BitVec 32)) ) (!  (and (and (<= 0 (nat_from_bv32 b@@56)) (< (nat_from_bv32 b@@56) 4294967296)) (= (nat_from_bv32 b@@56) (bv2int b@@56))) :qid |unknown.0:0| :skolemid |584| :pattern ( (nat_from_bv32 b@@56)) )))
(assert (= (type Tclass._System.nat) TyType))
(assert (= (Tag Tclass._System.nat) Tagclass._System.nat))
(assert (forall ((bx@@34 T@U) ) (!  (=> (and (= (type bx@@34) BoxType) ($IsBox bx@@34 Tclass._System.nat)) (and (= ($Box ($Unbox intType bx@@34)) bx@@34) ($Is ($Unbox intType bx@@34) Tclass._System.nat))) :qid |unknown.0:0| :skolemid |585| :pattern ( ($IsBox bx@@34 Tclass._System.nat)) )))
(assert (forall ((|x#0| T@U) ) (!  (=> (= (type |x#0|) intType) (and (=> ($Is |x#0| Tclass._System.nat) (INTERNAL_le_boogie 0 (U_2_int |x#0|))) (=> (INTERNAL_le_boogie 0 (U_2_int |x#0|)) ($Is |x#0| Tclass._System.nat)))) :qid |unknown.0:0| :skolemid |586| :pattern ( ($Is |x#0| Tclass._System.nat)) )))
(assert (forall ((|x#0@@0| T@U) ($h T@U) ) (!  (=> (and (= (type |x#0@@0|) intType) (= (type $h) (MapType1Type refType))) ($IsAlloc |x#0@@0| Tclass._System.nat $h)) :qid |unknown.0:0| :skolemid |587| :pattern ( ($IsAlloc |x#0@@0| Tclass._System.nat $h)) )))
(assert (= (Tag Tclass._System.object) Tagclass._System.object))
(assert (forall ((bx@@35 T@U) ) (!  (=> (and (= (type bx@@35) BoxType) ($IsBox bx@@35 Tclass._System.object)) (and (= ($Box ($Unbox refType bx@@35)) bx@@35) ($Is ($Unbox refType bx@@35) Tclass._System.object))) :qid |unknown.0:0| :skolemid |588| :pattern ( ($IsBox bx@@35 Tclass._System.object)) )))
(assert (forall (($o T@U) ) (!  (=> (= (type $o) refType) ($Is $o Tclass._System.object)) :qid |unknown.0:0| :skolemid |589| :pattern ( ($Is $o Tclass._System.object)) )))
(assert (= (type null) refType))
(assert (forall (($o@@0 T@U) ($h@@0 T@U) ) (!  (=> (and (= (type $o@@0) refType) (= (type $h@@0) (MapType1Type refType))) (and (=> ($IsAlloc $o@@0 Tclass._System.object $h@@0) (or (= $o@@0 null) (U_2_bool (MapType1Select $h@@0 $o@@0 alloc)))) (=> (or (= $o@@0 null) (U_2_bool (MapType1Select $h@@0 $o@@0 alloc))) ($IsAlloc $o@@0 Tclass._System.object $h@@0)))) :qid |unknown.0:0| :skolemid |590| :pattern ( ($IsAlloc $o@@0 Tclass._System.object $h@@0)) )))
(assert (forall ((arg0@@95 T@U) ) (! (= (type (Tclass._System.array arg0@@95)) TyType) :qid |funType:Tclass._System.array| :pattern ( (Tclass._System.array arg0@@95)) )))
(assert (forall ((|#$arg| T@U) ) (!  (=> (= (type |#$arg|) TyType) (= (Tag (Tclass._System.array |#$arg|)) Tagclass._System.array)) :qid |unknown.0:0| :skolemid |591| :pattern ( (Tclass._System.array |#$arg|)) )))
(assert (forall ((arg0@@96 T@U) ) (! (= (type (Tclass._System.array_0 arg0@@96)) TyType) :qid |funType:Tclass._System.array_0| :pattern ( (Tclass._System.array_0 arg0@@96)) )))
(assert (forall ((|#$arg@@0| T@U) ) (!  (=> (= (type |#$arg@@0|) TyType) (= (Tclass._System.array_0 (Tclass._System.array |#$arg@@0|)) |#$arg@@0|)) :qid |unknown.0:0| :skolemid |592| :pattern ( (Tclass._System.array |#$arg@@0|)) )))
(assert (forall ((|#$arg@@1| T@U) (bx@@36 T@U) ) (!  (=> (and (and (= (type |#$arg@@1|) TyType) (= (type bx@@36) BoxType)) ($IsBox bx@@36 (Tclass._System.array |#$arg@@1|))) (and (= ($Box ($Unbox refType bx@@36)) bx@@36) ($Is ($Unbox refType bx@@36) (Tclass._System.array |#$arg@@1|)))) :qid |unknown.0:0| :skolemid |593| :pattern ( ($IsBox bx@@36 (Tclass._System.array |#$arg@@1|))) )))
(assert (forall ((arg0@@97 T@U) ) (! (= (type (dtype arg0@@97)) TyType) :qid |funType:dtype| :pattern ( (dtype arg0@@97)) )))
(assert (forall ((|#$arg@@2| T@U) ($i0 Int) ($h@@1 T@U) ($o@@1 T@U) ) (!  (=> (and (and (= (type |#$arg@@2|) TyType) (= (type $h@@1) (MapType1Type refType))) (= (type $o@@1) refType)) (=> (and (and (and ($IsGoodHeap $h@@1) (not (= $o@@1 null))) (= (dtype $o@@1) (Tclass._System.array |#$arg@@2|))) (and (<= 0 $i0) (< $i0 (_System.array.Length $o@@1)))) (and ($IsBox (MapType1Select $h@@1 $o@@1 (IndexField $i0)) |#$arg@@2|) (=> (U_2_bool (MapType1Select $h@@1 $o@@1 alloc)) ($IsAllocBox (MapType1Select $h@@1 $o@@1 (IndexField $i0)) |#$arg@@2| $h@@1))))) :qid |unknown.0:0| :skolemid |594| :pattern ( (MapType1Select $h@@1 $o@@1 (IndexField $i0)) (Tclass._System.array |#$arg@@2|)) )))
(assert (forall ((|#$arg@@3| T@U) ($o@@2 T@U) ) (!  (=> (and (= (type |#$arg@@3|) TyType) (= (type $o@@2) refType)) (and (=> ($Is $o@@2 (Tclass._System.array |#$arg@@3|)) (or (= $o@@2 null) (= (dtype $o@@2) (Tclass._System.array |#$arg@@3|)))) (=> (or (= $o@@2 null) (= (dtype $o@@2) (Tclass._System.array |#$arg@@3|))) ($Is $o@@2 (Tclass._System.array |#$arg@@3|))))) :qid |unknown.0:0| :skolemid |595| :pattern ( ($Is $o@@2 (Tclass._System.array |#$arg@@3|))) )))
(assert (forall ((|#$arg@@4| T@U) ($o@@3 T@U) ($h@@2 T@U) ) (!  (=> (and (and (= (type |#$arg@@4|) TyType) (= (type $o@@3) refType)) (= (type $h@@2) (MapType1Type refType))) (and (=> ($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@2) (or (= $o@@3 null) (U_2_bool (MapType1Select $h@@2 $o@@3 alloc)))) (=> (or (= $o@@3 null) (U_2_bool (MapType1Select $h@@2 $o@@3 alloc))) ($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@2)))) :qid |unknown.0:0| :skolemid |596| :pattern ( ($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@2)) )))
(assert (forall ((|#$arg@@5| T@U) ($h@@3 T@U) ($o@@4 T@U) ) (!  (=> (and (and (and (= (type |#$arg@@5|) TyType) (= (type $h@@3) (MapType1Type refType))) (= (type $o@@4) refType)) (and (and ($IsGoodHeap $h@@3) (not (= $o@@4 null))) (= (dtype $o@@4) (Tclass._System.array |#$arg@@5|)))) (and ($Is (int_2_U (_System.array.Length $o@@4)) TInt) (=> (U_2_bool (MapType1Select $h@@3 $o@@4 alloc)) ($IsAlloc (int_2_U (_System.array.Length $o@@4)) TInt $h@@3)))) :qid |unknown.0:0| :skolemid |597| :no-pattern (type |#$arg@@5|) :no-pattern (type $h@@3) :no-pattern (type $o@@4) :no-pattern (U_2_int |#$arg@@5|) :no-pattern (U_2_bool |#$arg@@5|) :no-pattern (U_2_int $h@@3) :no-pattern (U_2_bool $h@@3) :no-pattern (U_2_int $o@@4) :no-pattern (U_2_bool $o@@4) )))
(assert (forall ((arg0@@98 T@U) ) (! (= (type (Tclass._System.___hFunc0 arg0@@98)) TyType) :qid |funType:Tclass._System.___hFunc0| :pattern ( (Tclass._System.___hFunc0 arg0@@98)) )))
(assert (forall ((|#$T0| T@U) ) (!  (=> (= (type |#$T0|) TyType) (= (Tag (Tclass._System.___hFunc0 |#$T0|)) Tagclass._System.___hFunc0)) :qid |unknown.0:0| :skolemid |598| :pattern ( (Tclass._System.___hFunc0 |#$T0|)) )))
(assert (forall ((arg0@@99 T@U) ) (! (= (type (Tclass._System.___hFunc0_0 arg0@@99)) TyType) :qid |funType:Tclass._System.___hFunc0_0| :pattern ( (Tclass._System.___hFunc0_0 arg0@@99)) )))
(assert (forall ((|#$T0@@0| T@U) ) (!  (=> (= (type |#$T0@@0|) TyType) (= (Tclass._System.___hFunc0_0 (Tclass._System.___hFunc0 |#$T0@@0|)) |#$T0@@0|)) :qid |unknown.0:0| :skolemid |599| :pattern ( (Tclass._System.___hFunc0 |#$T0@@0|)) )))
(assert (= (Ctor HandleTypeType) 19))
(assert (forall ((|#$T0@@1| T@U) (bx@@37 T@U) ) (!  (=> (and (and (= (type |#$T0@@1|) TyType) (= (type bx@@37) BoxType)) ($IsBox bx@@37 (Tclass._System.___hFunc0 |#$T0@@1|))) (and (= ($Box ($Unbox HandleTypeType bx@@37)) bx@@37) ($Is ($Unbox HandleTypeType bx@@37) (Tclass._System.___hFunc0 |#$T0@@1|)))) :qid |unknown.0:0| :skolemid |600| :pattern ( ($IsBox bx@@37 (Tclass._System.___hFunc0 |#$T0@@1|))) )))
(assert  (and (forall ((arg0@@100 T@U) (arg1@@41 T@U) (arg2@@7 T@U) ) (! (= (type (Apply0 arg0@@100 arg1@@41 arg2@@7)) BoxType) :qid |funType:Apply0| :pattern ( (Apply0 arg0@@100 arg1@@41 arg2@@7)) )) (forall ((arg0@@101 T@U) (arg1@@42 T@U) (arg2@@8 T@U) ) (! (= (type (Handle0 arg0@@101 arg1@@42 arg2@@8)) HandleTypeType) :qid |funType:Handle0| :pattern ( (Handle0 arg0@@101 arg1@@42 arg2@@8)) ))))
(assert (forall ((t0@@12 T@U) (heap T@U) (h@@19 T@U) (r@@5 T@U) (rd T@U) ) (!  (=> (and (and (and (and (= (type t0@@12) TyType) (= (type heap) (MapType1Type refType))) (= (type h@@19) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@5) (MapType0Type (MapType1Type refType) boolType))) (= (type rd) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (= (Apply0 t0@@12 (Handle0 h@@19 r@@5 rd) heap) (MapType0Select h@@19 heap))) :qid |unknown.0:0| :skolemid |601| :pattern ( (Apply0 t0@@12 (Handle0 h@@19 r@@5 rd) heap)) )))
(assert (forall ((t0@@13 T@U) (heap@@0 T@U) (h@@20 T@U) (r@@6 T@U) (rd@@0 T@U) ) (!  (=> (and (and (and (and (and (= (type t0@@13) TyType) (= (type heap@@0) (MapType1Type refType))) (= (type h@@20) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@6) (MapType0Type (MapType1Type refType) boolType))) (= (type rd@@0) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (U_2_bool (MapType0Select r@@6 heap@@0))) (Requires0 t0@@13 (Handle0 h@@20 r@@6 rd@@0) heap@@0)) :qid |unknown.0:0| :skolemid |602| :pattern ( (Requires0 t0@@13 (Handle0 h@@20 r@@6 rd@@0) heap@@0)) )))
(assert (forall ((arg0@@102 T@U) (arg1@@43 T@U) (arg2@@9 T@U) ) (! (= (type (Reads0 arg0@@102 arg1@@43 arg2@@9)) (MapType0Type BoxType boolType)) :qid |funType:Reads0| :pattern ( (Reads0 arg0@@102 arg1@@43 arg2@@9)) )))
(assert (forall ((t0@@14 T@U) (heap@@1 T@U) (h@@21 T@U) (r@@7 T@U) (rd@@1 T@U) (bx@@38 T@U) ) (!  (=> (and (and (and (and (and (= (type t0@@14) TyType) (= (type heap@@1) (MapType1Type refType))) (= (type h@@21) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@7) (MapType0Type (MapType1Type refType) boolType))) (= (type rd@@1) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (= (type bx@@38) BoxType)) (and (=> (U_2_bool (MapType0Select (Reads0 t0@@14 (Handle0 h@@21 r@@7 rd@@1) heap@@1) bx@@38)) (U_2_bool (MapType0Select (MapType0Select rd@@1 heap@@1) bx@@38))) (=> (U_2_bool (MapType0Select (MapType0Select rd@@1 heap@@1) bx@@38)) (U_2_bool (MapType0Select (Reads0 t0@@14 (Handle0 h@@21 r@@7 rd@@1) heap@@1) bx@@38))))) :qid |unknown.0:0| :skolemid |603| :pattern ( (MapType0Select (Reads0 t0@@14 (Handle0 h@@21 r@@7 rd@@1) heap@@1) bx@@38)) )))
(assert (forall ((t0@@15 T@U) (h0@@0 T@U) (h1@@0 T@U) (f@@5 T@U) ) (!  (=> (and (and (and (and (= (type t0@@15) TyType) (= (type h0@@0) (MapType1Type refType))) (= (type h1@@0) (MapType1Type refType))) (= (type f@@5) HandleTypeType)) (and (and (and ($HeapSucc h0@@0 h1@@0) (and ($IsGoodHeap h0@@0) ($IsGoodHeap h1@@0))) ($Is f@@5 (Tclass._System.___hFunc0 t0@@15))) (forall ((o@@39 T@U) (fld T@U) ) (! (let ((a@@77 (FieldTypeInv0 (type fld)))) (=> (and (and (= (type o@@39) refType) (= (type fld) (FieldType a@@77))) (and (not (= o@@39 null)) (U_2_bool (MapType0Select (Reads0 t0@@15 f@@5 h0@@0) ($Box o@@39))))) (= (MapType1Select h0@@0 o@@39 fld) (MapType1Select h1@@0 o@@39 fld)))) :qid |unknown.0:0| :skolemid |604| :no-pattern (type o@@39) :no-pattern (type fld) :no-pattern (U_2_int o@@39) :no-pattern (U_2_bool o@@39) :no-pattern (U_2_int fld) :no-pattern (U_2_bool fld) )))) (= (Reads0 t0@@15 f@@5 h0@@0) (Reads0 t0@@15 f@@5 h1@@0))) :qid |unknown.0:0| :skolemid |605| :pattern ( ($HeapSucc h0@@0 h1@@0) (Reads0 t0@@15 f@@5 h1@@0)) )))
(assert (forall ((t0@@16 T@U) (h0@@1 T@U) (h1@@1 T@U) (f@@6 T@U) ) (!  (=> (and (and (and (and (= (type t0@@16) TyType) (= (type h0@@1) (MapType1Type refType))) (= (type h1@@1) (MapType1Type refType))) (= (type f@@6) HandleTypeType)) (and (and (and ($HeapSucc h0@@1 h1@@1) (and ($IsGoodHeap h0@@1) ($IsGoodHeap h1@@1))) ($Is f@@6 (Tclass._System.___hFunc0 t0@@16))) (forall ((o@@40 T@U) (fld@@0 T@U) ) (! (let ((a@@78 (FieldTypeInv0 (type fld@@0)))) (=> (and (and (= (type o@@40) refType) (= (type fld@@0) (FieldType a@@78))) (and (not (= o@@40 null)) (U_2_bool (MapType0Select (Reads0 t0@@16 f@@6 h1@@1) ($Box o@@40))))) (= (MapType1Select h0@@1 o@@40 fld@@0) (MapType1Select h1@@1 o@@40 fld@@0)))) :qid |unknown.0:0| :skolemid |606| :no-pattern (type o@@40) :no-pattern (type fld@@0) :no-pattern (U_2_int o@@40) :no-pattern (U_2_bool o@@40) :no-pattern (U_2_int fld@@0) :no-pattern (U_2_bool fld@@0) )))) (= (Reads0 t0@@16 f@@6 h0@@1) (Reads0 t0@@16 f@@6 h1@@1))) :qid |unknown.0:0| :skolemid |607| :pattern ( ($HeapSucc h0@@1 h1@@1) (Reads0 t0@@16 f@@6 h1@@1)) )))
(assert (forall ((t0@@17 T@U) (h0@@2 T@U) (h1@@2 T@U) (f@@7 T@U) ) (!  (=> (and (and (and (and (= (type t0@@17) TyType) (= (type h0@@2) (MapType1Type refType))) (= (type h1@@2) (MapType1Type refType))) (= (type f@@7) HandleTypeType)) (and (and (and ($HeapSucc h0@@2 h1@@2) (and ($IsGoodHeap h0@@2) ($IsGoodHeap h1@@2))) ($Is f@@7 (Tclass._System.___hFunc0 t0@@17))) (forall ((o@@41 T@U) (fld@@1 T@U) ) (! (let ((a@@79 (FieldTypeInv0 (type fld@@1)))) (=> (and (and (= (type o@@41) refType) (= (type fld@@1) (FieldType a@@79))) (and (not (= o@@41 null)) (U_2_bool (MapType0Select (Reads0 t0@@17 f@@7 h0@@2) ($Box o@@41))))) (= (MapType1Select h0@@2 o@@41 fld@@1) (MapType1Select h1@@2 o@@41 fld@@1)))) :qid |unknown.0:0| :skolemid |608| :no-pattern (type o@@41) :no-pattern (type fld@@1) :no-pattern (U_2_int o@@41) :no-pattern (U_2_bool o@@41) :no-pattern (U_2_int fld@@1) :no-pattern (U_2_bool fld@@1) )))) (and (=> (Requires0 t0@@17 f@@7 h0@@2) (Requires0 t0@@17 f@@7 h1@@2)) (=> (Requires0 t0@@17 f@@7 h1@@2) (Requires0 t0@@17 f@@7 h0@@2)))) :qid |unknown.0:0| :skolemid |609| :pattern ( ($HeapSucc h0@@2 h1@@2) (Requires0 t0@@17 f@@7 h1@@2)) )))
(assert (forall ((t0@@18 T@U) (h0@@3 T@U) (h1@@3 T@U) (f@@8 T@U) ) (!  (=> (and (and (and (and (= (type t0@@18) TyType) (= (type h0@@3) (MapType1Type refType))) (= (type h1@@3) (MapType1Type refType))) (= (type f@@8) HandleTypeType)) (and (and (and ($HeapSucc h0@@3 h1@@3) (and ($IsGoodHeap h0@@3) ($IsGoodHeap h1@@3))) ($Is f@@8 (Tclass._System.___hFunc0 t0@@18))) (forall ((o@@42 T@U) (fld@@2 T@U) ) (! (let ((a@@80 (FieldTypeInv0 (type fld@@2)))) (=> (and (and (= (type o@@42) refType) (= (type fld@@2) (FieldType a@@80))) (and (not (= o@@42 null)) (U_2_bool (MapType0Select (Reads0 t0@@18 f@@8 h1@@3) ($Box o@@42))))) (= (MapType1Select h0@@3 o@@42 fld@@2) (MapType1Select h1@@3 o@@42 fld@@2)))) :qid |unknown.0:0| :skolemid |610| :no-pattern (type o@@42) :no-pattern (type fld@@2) :no-pattern (U_2_int o@@42) :no-pattern (U_2_bool o@@42) :no-pattern (U_2_int fld@@2) :no-pattern (U_2_bool fld@@2) )))) (and (=> (Requires0 t0@@18 f@@8 h0@@3) (Requires0 t0@@18 f@@8 h1@@3)) (=> (Requires0 t0@@18 f@@8 h1@@3) (Requires0 t0@@18 f@@8 h0@@3)))) :qid |unknown.0:0| :skolemid |611| :pattern ( ($HeapSucc h0@@3 h1@@3) (Requires0 t0@@18 f@@8 h1@@3)) )))
(assert (forall ((t0@@19 T@U) (h0@@4 T@U) (h1@@4 T@U) (f@@9 T@U) ) (!  (=> (and (and (and (and (= (type t0@@19) TyType) (= (type h0@@4) (MapType1Type refType))) (= (type h1@@4) (MapType1Type refType))) (= (type f@@9) HandleTypeType)) (and (and (and ($HeapSucc h0@@4 h1@@4) (and ($IsGoodHeap h0@@4) ($IsGoodHeap h1@@4))) ($Is f@@9 (Tclass._System.___hFunc0 t0@@19))) (forall ((o@@43 T@U) (fld@@3 T@U) ) (! (let ((a@@81 (FieldTypeInv0 (type fld@@3)))) (=> (and (and (= (type o@@43) refType) (= (type fld@@3) (FieldType a@@81))) (and (not (= o@@43 null)) (U_2_bool (MapType0Select (Reads0 t0@@19 f@@9 h0@@4) ($Box o@@43))))) (= (MapType1Select h0@@4 o@@43 fld@@3) (MapType1Select h1@@4 o@@43 fld@@3)))) :qid |unknown.0:0| :skolemid |612| :no-pattern (type o@@43) :no-pattern (type fld@@3) :no-pattern (U_2_int o@@43) :no-pattern (U_2_bool o@@43) :no-pattern (U_2_int fld@@3) :no-pattern (U_2_bool fld@@3) )))) (= (Apply0 t0@@19 f@@9 h0@@4) (Apply0 t0@@19 f@@9 h1@@4))) :qid |unknown.0:0| :skolemid |613| :pattern ( ($HeapSucc h0@@4 h1@@4) (Apply0 t0@@19 f@@9 h1@@4)) )))
(assert (forall ((t0@@20 T@U) (h0@@5 T@U) (h1@@5 T@U) (f@@10 T@U) ) (!  (=> (and (and (and (and (= (type t0@@20) TyType) (= (type h0@@5) (MapType1Type refType))) (= (type h1@@5) (MapType1Type refType))) (= (type f@@10) HandleTypeType)) (and (and (and ($HeapSucc h0@@5 h1@@5) (and ($IsGoodHeap h0@@5) ($IsGoodHeap h1@@5))) ($Is f@@10 (Tclass._System.___hFunc0 t0@@20))) (forall ((o@@44 T@U) (fld@@4 T@U) ) (! (let ((a@@82 (FieldTypeInv0 (type fld@@4)))) (=> (and (and (= (type o@@44) refType) (= (type fld@@4) (FieldType a@@82))) (and (not (= o@@44 null)) (U_2_bool (MapType0Select (Reads0 t0@@20 f@@10 h1@@5) ($Box o@@44))))) (= (MapType1Select h0@@5 o@@44 fld@@4) (MapType1Select h1@@5 o@@44 fld@@4)))) :qid |unknown.0:0| :skolemid |614| :no-pattern (type o@@44) :no-pattern (type fld@@4) :no-pattern (U_2_int o@@44) :no-pattern (U_2_bool o@@44) :no-pattern (U_2_int fld@@4) :no-pattern (U_2_bool fld@@4) )))) (= (Apply0 t0@@20 f@@10 h0@@5) (Apply0 t0@@20 f@@10 h1@@5))) :qid |unknown.0:0| :skolemid |615| :pattern ( ($HeapSucc h0@@5 h1@@5) (Apply0 t0@@20 f@@10 h1@@5)) )))
(assert (forall ((f@@11 T@U) (t0@@21 T@U) ) (!  (=> (and (= (type f@@11) HandleTypeType) (= (type t0@@21) TyType)) (and (=> ($Is f@@11 (Tclass._System.___hFunc0 t0@@21)) (forall ((h@@22 T@U) ) (!  (=> (= (type h@@22) (MapType1Type refType)) (=> (and ($IsGoodHeap h@@22) (Requires0 t0@@21 f@@11 h@@22)) ($IsBox (Apply0 t0@@21 f@@11 h@@22) t0@@21))) :qid |DafnyPre.405:12| :skolemid |616| :pattern ( (Apply0 t0@@21 f@@11 h@@22)) ))) (=> (forall ((h@@23 T@U) ) (!  (=> (= (type h@@23) (MapType1Type refType)) (=> (and ($IsGoodHeap h@@23) (Requires0 t0@@21 f@@11 h@@23)) ($IsBox (Apply0 t0@@21 f@@11 h@@23) t0@@21))) :qid |DafnyPre.405:12| :skolemid |616| :pattern ( (Apply0 t0@@21 f@@11 h@@23)) )) ($Is f@@11 (Tclass._System.___hFunc0 t0@@21))))) :qid |unknown.0:0| :skolemid |617| :pattern ( ($Is f@@11 (Tclass._System.___hFunc0 t0@@21))) )))
(assert (forall ((f@@12 T@U) (t0@@22 T@U) (u0 T@U) ) (!  (=> (and (and (and (= (type f@@12) HandleTypeType) (= (type t0@@22) TyType)) (= (type u0) TyType)) (and ($Is f@@12 (Tclass._System.___hFunc0 t0@@22)) (forall ((bx@@39 T@U) ) (!  (=> (and (= (type bx@@39) BoxType) ($IsBox bx@@39 t0@@22)) ($IsBox bx@@39 u0)) :qid |unknown.0:0| :skolemid |618| :pattern ( ($IsBox bx@@39 t0@@22)) :pattern ( ($IsBox bx@@39 u0)) )))) ($Is f@@12 (Tclass._System.___hFunc0 u0))) :qid |unknown.0:0| :skolemid |619| :pattern ( ($Is f@@12 (Tclass._System.___hFunc0 t0@@22)) ($Is f@@12 (Tclass._System.___hFunc0 u0))) )))
(assert (forall ((f@@13 T@U) (t0@@23 T@U) (h@@24 T@U) ) (!  (=> (and (and (and (= (type f@@13) HandleTypeType) (= (type t0@@23) TyType)) (= (type h@@24) (MapType1Type refType))) ($IsGoodHeap h@@24)) ($IsAlloc f@@13 (Tclass._System.___hFunc0 t0@@23) h@@24)) :qid |unknown.0:0| :skolemid |621| :pattern ( ($IsAlloc f@@13 (Tclass._System.___hFunc0 t0@@23) h@@24)) )))
(assert  (and (forall ((arg0@@103 T@U) (arg1@@44 T@U) ) (! (= (type (|#_System._tuple#2._#Make2| arg0@@103 arg1@@44)) DatatypeTypeType) :qid |funType:#_System._tuple#2._#Make2| :pattern ( (|#_System._tuple#2._#Make2| arg0@@103 arg1@@44)) )) (forall ((arg0@@104 T@U) ) (! (= (type (DatatypeCtorId arg0@@104)) DtCtorIdType) :qid |funType:DatatypeCtorId| :pattern ( (DatatypeCtorId arg0@@104)) ))))
(assert (forall ((|a#0#0#0| T@U) (|a#0#1#0| T@U) ) (!  (=> (and (= (type |a#0#0#0|) BoxType) (= (type |a#0#1#0|) BoxType)) (= (DatatypeCtorId (|#_System._tuple#2._#Make2| |a#0#0#0| |a#0#1#0|)) |##_System._tuple#2._#Make2|)) :qid |unknown.0:0| :skolemid |622| :pattern ( (|#_System._tuple#2._#Make2| |a#0#0#0| |a#0#1#0|)) )))
(assert (forall ((d@@0 T@U) ) (!  (=> (= (type d@@0) DatatypeTypeType) (and (=> (_System.__tuple_h2.___hMake2_q d@@0) (= (DatatypeCtorId d@@0) |##_System._tuple#2._#Make2|)) (=> (= (DatatypeCtorId d@@0) |##_System._tuple#2._#Make2|) (_System.__tuple_h2.___hMake2_q d@@0)))) :qid |unknown.0:0| :skolemid |623| :pattern ( (_System.__tuple_h2.___hMake2_q d@@0)) )))
(assert (forall ((d@@1 T@U) ) (!  (=> (and (= (type d@@1) DatatypeTypeType) (_System.__tuple_h2.___hMake2_q d@@1)) (exists ((|a#1#0#0| T@U) (|a#1#1#0| T@U) ) (!  (and (and (= (type |a#1#0#0|) BoxType) (= (type |a#1#1#0|) BoxType)) (= d@@1 (|#_System._tuple#2._#Make2| |a#1#0#0| |a#1#1#0|))) :qid |unknown.0:0| :skolemid |624| :no-pattern (type |a#1#0#0|) :no-pattern (type |a#1#1#0|) :no-pattern (U_2_int |a#1#0#0|) :no-pattern (U_2_bool |a#1#0#0|) :no-pattern (U_2_int |a#1#1#0|) :no-pattern (U_2_bool |a#1#1#0|) ))) :qid |unknown.0:0| :skolemid |625| :pattern ( (_System.__tuple_h2.___hMake2_q d@@1)) )))
(assert (forall ((arg0@@105 T@U) (arg1@@45 T@U) ) (! (= (type (Tclass._System.__tuple_h2 arg0@@105 arg1@@45)) TyType) :qid |funType:Tclass._System.__tuple_h2| :pattern ( (Tclass._System.__tuple_h2 arg0@@105 arg1@@45)) )))
(assert (forall ((|#$T0@@2| T@U) (|#$T1| T@U) ) (!  (=> (and (= (type |#$T0@@2|) TyType) (= (type |#$T1|) TyType)) (= (Tag (Tclass._System.__tuple_h2 |#$T0@@2| |#$T1|)) Tagclass._System.__tuple_h2)) :qid |unknown.0:0| :skolemid |626| :pattern ( (Tclass._System.__tuple_h2 |#$T0@@2| |#$T1|)) )))
(assert (forall ((arg0@@106 T@U) ) (! (= (type (Tclass._System.__tuple_h2_0 arg0@@106)) TyType) :qid |funType:Tclass._System.__tuple_h2_0| :pattern ( (Tclass._System.__tuple_h2_0 arg0@@106)) )))
(assert (forall ((|#$T0@@3| T@U) (|#$T1@@0| T@U) ) (!  (=> (and (= (type |#$T0@@3|) TyType) (= (type |#$T1@@0|) TyType)) (= (Tclass._System.__tuple_h2_0 (Tclass._System.__tuple_h2 |#$T0@@3| |#$T1@@0|)) |#$T0@@3|)) :qid |unknown.0:0| :skolemid |627| :pattern ( (Tclass._System.__tuple_h2 |#$T0@@3| |#$T1@@0|)) )))
(assert (forall ((arg0@@107 T@U) ) (! (= (type (Tclass._System.__tuple_h2_1 arg0@@107)) TyType) :qid |funType:Tclass._System.__tuple_h2_1| :pattern ( (Tclass._System.__tuple_h2_1 arg0@@107)) )))
(assert (forall ((|#$T0@@4| T@U) (|#$T1@@1| T@U) ) (!  (=> (and (= (type |#$T0@@4|) TyType) (= (type |#$T1@@1|) TyType)) (= (Tclass._System.__tuple_h2_1 (Tclass._System.__tuple_h2 |#$T0@@4| |#$T1@@1|)) |#$T1@@1|)) :qid |unknown.0:0| :skolemid |628| :pattern ( (Tclass._System.__tuple_h2 |#$T0@@4| |#$T1@@1|)) )))
(assert (forall ((|#$T0@@5| T@U) (|#$T1@@2| T@U) (bx@@40 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@5|) TyType) (= (type |#$T1@@2|) TyType)) (= (type bx@@40) BoxType)) ($IsBox bx@@40 (Tclass._System.__tuple_h2 |#$T0@@5| |#$T1@@2|))) (and (= ($Box ($Unbox DatatypeTypeType bx@@40)) bx@@40) ($Is ($Unbox DatatypeTypeType bx@@40) (Tclass._System.__tuple_h2 |#$T0@@5| |#$T1@@2|)))) :qid |unknown.0:0| :skolemid |629| :pattern ( ($IsBox bx@@40 (Tclass._System.__tuple_h2 |#$T0@@5| |#$T1@@2|))) )))
(assert (forall ((|#$T0@@6| T@U) (|#$T1@@3| T@U) (|a#2#0#0| T@U) (|a#2#1#0| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@6|) TyType) (= (type |#$T1@@3|) TyType)) (= (type |a#2#0#0|) BoxType)) (= (type |a#2#1#0|) BoxType)) (and (=> ($Is (|#_System._tuple#2._#Make2| |a#2#0#0| |a#2#1#0|) (Tclass._System.__tuple_h2 |#$T0@@6| |#$T1@@3|)) (and ($IsBox |a#2#0#0| |#$T0@@6|) ($IsBox |a#2#1#0| |#$T1@@3|))) (=> (and ($IsBox |a#2#0#0| |#$T0@@6|) ($IsBox |a#2#1#0| |#$T1@@3|)) ($Is (|#_System._tuple#2._#Make2| |a#2#0#0| |a#2#1#0|) (Tclass._System.__tuple_h2 |#$T0@@6| |#$T1@@3|))))) :qid |unknown.0:0| :skolemid |630| :pattern ( ($Is (|#_System._tuple#2._#Make2| |a#2#0#0| |a#2#1#0|) (Tclass._System.__tuple_h2 |#$T0@@6| |#$T1@@3|))) )))
(assert (forall ((|#$T0@@7| T@U) (|#$T1@@4| T@U) (|a#3#0#0| T@U) (|a#3#1#0| T@U) ($h@@4 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@7|) TyType) (= (type |#$T1@@4|) TyType)) (= (type |a#3#0#0|) BoxType)) (= (type |a#3#1#0|) BoxType)) (= (type $h@@4) (MapType1Type refType))) ($IsGoodHeap $h@@4)) (and (=> ($IsAlloc (|#_System._tuple#2._#Make2| |a#3#0#0| |a#3#1#0|) (Tclass._System.__tuple_h2 |#$T0@@7| |#$T1@@4|) $h@@4) (and ($IsAllocBox |a#3#0#0| |#$T0@@7| $h@@4) ($IsAllocBox |a#3#1#0| |#$T1@@4| $h@@4))) (=> (and ($IsAllocBox |a#3#0#0| |#$T0@@7| $h@@4) ($IsAllocBox |a#3#1#0| |#$T1@@4| $h@@4)) ($IsAlloc (|#_System._tuple#2._#Make2| |a#3#0#0| |a#3#1#0|) (Tclass._System.__tuple_h2 |#$T0@@7| |#$T1@@4|) $h@@4)))) :qid |unknown.0:0| :skolemid |631| :pattern ( ($IsAlloc (|#_System._tuple#2._#Make2| |a#3#0#0| |a#3#1#0|) (Tclass._System.__tuple_h2 |#$T0@@7| |#$T1@@4|) $h@@4)) )))
(assert (forall ((|a#4#0#0| T@U) (|a#4#1#0| T@U) ) (!  (=> (and (= (type |a#4#0#0|) BoxType) (= (type |a#4#1#0|) BoxType)) (= (|#_System._tuple#2._#Make2| (Lit |a#4#0#0|) (Lit |a#4#1#0|)) (Lit (|#_System._tuple#2._#Make2| |a#4#0#0| |a#4#1#0|)))) :qid |unknown.0:0| :skolemid |632| :pattern ( (|#_System._tuple#2._#Make2| (Lit |a#4#0#0|) (Lit |a#4#1#0|))) )))
(assert (forall ((|a#5#0#0| T@U) (|a#5#1#0| T@U) ) (!  (=> (and (= (type |a#5#0#0|) BoxType) (= (type |a#5#1#0|) BoxType)) (= (_System.__tuple_h2._0 (|#_System._tuple#2._#Make2| |a#5#0#0| |a#5#1#0|)) |a#5#0#0|)) :qid |unknown.0:0| :skolemid |633| :pattern ( (|#_System._tuple#2._#Make2| |a#5#0#0| |a#5#1#0|)) )))
(assert (forall ((|a#6#0#0| T@U) (|a#6#1#0| T@U) ) (!  (=> (and (= (type |a#6#0#0|) BoxType) (= (type |a#6#1#0|) BoxType)) (< (BoxRank |a#6#0#0|) (DtRank (|#_System._tuple#2._#Make2| |a#6#0#0| |a#6#1#0|)))) :qid |unknown.0:0| :skolemid |634| :pattern ( (|#_System._tuple#2._#Make2| |a#6#0#0| |a#6#1#0|)) )))
(assert (forall ((|a#7#0#0| T@U) (|a#7#1#0| T@U) ) (!  (=> (and (= (type |a#7#0#0|) BoxType) (= (type |a#7#1#0|) BoxType)) (= (_System.__tuple_h2._1 (|#_System._tuple#2._#Make2| |a#7#0#0| |a#7#1#0|)) |a#7#1#0|)) :qid |unknown.0:0| :skolemid |635| :pattern ( (|#_System._tuple#2._#Make2| |a#7#0#0| |a#7#1#0|)) )))
(assert (forall ((|a#8#0#0| T@U) (|a#8#1#0| T@U) ) (!  (=> (and (= (type |a#8#0#0|) BoxType) (= (type |a#8#1#0|) BoxType)) (< (BoxRank |a#8#1#0|) (DtRank (|#_System._tuple#2._#Make2| |a#8#0#0| |a#8#1#0|)))) :qid |unknown.0:0| :skolemid |636| :pattern ( (|#_System._tuple#2._#Make2| |a#8#0#0| |a#8#1#0|)) )))
(assert (forall ((d@@2 T@U) ) (!  (=> (and (= (type d@@2) DatatypeTypeType) (|$IsA#_System.__tuple_h2| d@@2)) (_System.__tuple_h2.___hMake2_q d@@2)) :qid |unknown.0:0| :skolemid |637| :pattern ( (|$IsA#_System.__tuple_h2| d@@2)) )))
(assert (forall ((|#$T0@@8| T@U) (|#$T1@@5| T@U) (d@@3 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@8|) TyType) (= (type |#$T1@@5|) TyType)) (= (type d@@3) DatatypeTypeType)) ($Is d@@3 (Tclass._System.__tuple_h2 |#$T0@@8| |#$T1@@5|))) (_System.__tuple_h2.___hMake2_q d@@3)) :qid |unknown.0:0| :skolemid |638| :pattern ( (_System.__tuple_h2.___hMake2_q d@@3) ($Is d@@3 (Tclass._System.__tuple_h2 |#$T0@@8| |#$T1@@5|))) )))
(assert (forall ((arg0@@108 T@U) (arg1@@46 T@U) ) (! (= (type (Tclass._System.___hFunc1 arg0@@108 arg1@@46)) TyType) :qid |funType:Tclass._System.___hFunc1| :pattern ( (Tclass._System.___hFunc1 arg0@@108 arg1@@46)) )))
(assert (forall ((|#$T0@@9| T@U) (|#$T1@@6| T@U) ) (!  (=> (and (= (type |#$T0@@9|) TyType) (= (type |#$T1@@6|) TyType)) (= (Tag (Tclass._System.___hFunc1 |#$T0@@9| |#$T1@@6|)) Tagclass._System.___hFunc1)) :qid |unknown.0:0| :skolemid |639| :pattern ( (Tclass._System.___hFunc1 |#$T0@@9| |#$T1@@6|)) )))
(assert (forall ((arg0@@109 T@U) ) (! (= (type (Tclass._System.___hFunc1_0 arg0@@109)) TyType) :qid |funType:Tclass._System.___hFunc1_0| :pattern ( (Tclass._System.___hFunc1_0 arg0@@109)) )))
(assert (forall ((|#$T0@@10| T@U) (|#$T1@@7| T@U) ) (!  (=> (and (= (type |#$T0@@10|) TyType) (= (type |#$T1@@7|) TyType)) (= (Tclass._System.___hFunc1_0 (Tclass._System.___hFunc1 |#$T0@@10| |#$T1@@7|)) |#$T0@@10|)) :qid |unknown.0:0| :skolemid |640| :pattern ( (Tclass._System.___hFunc1 |#$T0@@10| |#$T1@@7|)) )))
(assert (forall ((arg0@@110 T@U) ) (! (= (type (Tclass._System.___hFunc1_1 arg0@@110)) TyType) :qid |funType:Tclass._System.___hFunc1_1| :pattern ( (Tclass._System.___hFunc1_1 arg0@@110)) )))
(assert (forall ((|#$T0@@11| T@U) (|#$T1@@8| T@U) ) (!  (=> (and (= (type |#$T0@@11|) TyType) (= (type |#$T1@@8|) TyType)) (= (Tclass._System.___hFunc1_1 (Tclass._System.___hFunc1 |#$T0@@11| |#$T1@@8|)) |#$T1@@8|)) :qid |unknown.0:0| :skolemid |641| :pattern ( (Tclass._System.___hFunc1 |#$T0@@11| |#$T1@@8|)) )))
(assert (forall ((|#$T0@@12| T@U) (|#$T1@@9| T@U) (bx@@41 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@12|) TyType) (= (type |#$T1@@9|) TyType)) (= (type bx@@41) BoxType)) ($IsBox bx@@41 (Tclass._System.___hFunc1 |#$T0@@12| |#$T1@@9|))) (and (= ($Box ($Unbox HandleTypeType bx@@41)) bx@@41) ($Is ($Unbox HandleTypeType bx@@41) (Tclass._System.___hFunc1 |#$T0@@12| |#$T1@@9|)))) :qid |unknown.0:0| :skolemid |642| :pattern ( ($IsBox bx@@41 (Tclass._System.___hFunc1 |#$T0@@12| |#$T1@@9|))) )))
(assert  (and (and (and (and (and (and (and (and (and (forall ((arg0@@111 T@T) (arg1@@47 T@T) (arg2@@10 T@T) ) (! (= (Ctor (MapType2Type arg0@@111 arg1@@47 arg2@@10)) 20) :qid |ctor:MapType2Type| )) (forall ((arg0@@112 T@T) (arg1@@48 T@T) (arg2@@11 T@T) ) (! (= (MapType2TypeInv0 (MapType2Type arg0@@112 arg1@@48 arg2@@11)) arg0@@112) :qid |typeInv:MapType2TypeInv0| :pattern ( (MapType2Type arg0@@112 arg1@@48 arg2@@11)) ))) (forall ((arg0@@113 T@T) (arg1@@49 T@T) (arg2@@12 T@T) ) (! (= (MapType2TypeInv1 (MapType2Type arg0@@113 arg1@@49 arg2@@12)) arg1@@49) :qid |typeInv:MapType2TypeInv1| :pattern ( (MapType2Type arg0@@113 arg1@@49 arg2@@12)) ))) (forall ((arg0@@114 T@T) (arg1@@50 T@T) (arg2@@13 T@T) ) (! (= (MapType2TypeInv2 (MapType2Type arg0@@114 arg1@@50 arg2@@13)) arg2@@13) :qid |typeInv:MapType2TypeInv2| :pattern ( (MapType2Type arg0@@114 arg1@@50 arg2@@13)) ))) (forall ((arg0@@115 T@U) (arg1@@51 T@U) (arg2@@14 T@U) ) (! (let ((aVar2 (MapType2TypeInv2 (type arg0@@115)))) (= (type (MapType2Select arg0@@115 arg1@@51 arg2@@14)) aVar2)) :qid |funType:MapType2Select| :pattern ( (MapType2Select arg0@@115 arg1@@51 arg2@@14)) ))) (forall ((arg0@@116 T@U) (arg1@@52 T@U) (arg2@@15 T@U) (arg3@@0 T@U) ) (! (let ((aVar2@@0 (type arg3@@0))) (let ((aVar1@@2 (type arg2@@15))) (let ((aVar0@@1 (type arg1@@52))) (= (type (MapType2Store arg0@@116 arg1@@52 arg2@@15 arg3@@0)) (MapType2Type aVar0@@1 aVar1@@2 aVar2@@0))))) :qid |funType:MapType2Store| :pattern ( (MapType2Store arg0@@116 arg1@@52 arg2@@15 arg3@@0)) ))) (forall ((m@@27 T@U) (x0@@6 T@U) (x1@@3 T@U) (val@@7 T@U) ) (! (let ((aVar2@@1 (MapType2TypeInv2 (type m@@27)))) (=> (= (type val@@7) aVar2@@1) (= (MapType2Select (MapType2Store m@@27 x0@@6 x1@@3 val@@7) x0@@6 x1@@3) val@@7))) :qid |mapAx0:MapType2Select| :weight 0 ))) (and (and (forall ((val@@8 T@U) (m@@28 T@U) (x0@@7 T@U) (x1@@4 T@U) (y0@@4 T@U) (y1@@2 T@U) ) (!  (or (= x0@@7 y0@@4) (= (MapType2Select (MapType2Store m@@28 x0@@7 x1@@4 val@@8) y0@@4 y1@@2) (MapType2Select m@@28 y0@@4 y1@@2))) :qid |mapAx1:MapType2Select:0| :weight 0 )) (forall ((val@@9 T@U) (m@@29 T@U) (x0@@8 T@U) (x1@@5 T@U) (y0@@5 T@U) (y1@@3 T@U) ) (!  (or (= x1@@5 y1@@3) (= (MapType2Select (MapType2Store m@@29 x0@@8 x1@@5 val@@9) y0@@5 y1@@3) (MapType2Select m@@29 y0@@5 y1@@3))) :qid |mapAx1:MapType2Select:1| :weight 0 ))) (forall ((val@@10 T@U) (m@@30 T@U) (x0@@9 T@U) (x1@@6 T@U) (y0@@6 T@U) (y1@@4 T@U) ) (!  (or true (= (MapType2Select (MapType2Store m@@30 x0@@9 x1@@6 val@@10) y0@@6 y1@@4) (MapType2Select m@@30 y0@@6 y1@@4))) :qid |mapAx2:MapType2Select| :weight 0 )))) (forall ((arg0@@117 T@U) (arg1@@53 T@U) (arg2@@16 T@U) (arg3@@1 T@U) (arg4 T@U) ) (! (= (type (Apply1 arg0@@117 arg1@@53 arg2@@16 arg3@@1 arg4)) BoxType) :qid |funType:Apply1| :pattern ( (Apply1 arg0@@117 arg1@@53 arg2@@16 arg3@@1 arg4)) ))) (forall ((arg0@@118 T@U) (arg1@@54 T@U) (arg2@@17 T@U) ) (! (= (type (Handle1 arg0@@118 arg1@@54 arg2@@17)) HandleTypeType) :qid |funType:Handle1| :pattern ( (Handle1 arg0@@118 arg1@@54 arg2@@17)) ))))
(assert (forall ((t0@@24 T@U) (t1@@3 T@U) (heap@@2 T@U) (h@@25 T@U) (r@@8 T@U) (rd@@2 T@U) (bx0 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@24) TyType) (= (type t1@@3) TyType)) (= (type heap@@2) (MapType1Type refType))) (= (type h@@25) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@8) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@2) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0) BoxType)) (= (Apply1 t0@@24 t1@@3 (Handle1 h@@25 r@@8 rd@@2) heap@@2 bx0) (MapType2Select h@@25 heap@@2 bx0))) :qid |unknown.0:0| :skolemid |643| :pattern ( (Apply1 t0@@24 t1@@3 (Handle1 h@@25 r@@8 rd@@2) heap@@2 bx0)) )))
(assert (forall ((t0@@25 T@U) (t1@@4 T@U) (heap@@3 T@U) (h@@26 T@U) (r@@9 T@U) (rd@@3 T@U) (bx0@@0 T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type t0@@25) TyType) (= (type t1@@4) TyType)) (= (type heap@@3) (MapType1Type refType))) (= (type h@@26) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@9) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@3) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@0) BoxType)) (U_2_bool (MapType2Select r@@9 heap@@3 bx0@@0))) (Requires1 t0@@25 t1@@4 (Handle1 h@@26 r@@9 rd@@3) heap@@3 bx0@@0)) :qid |unknown.0:0| :skolemid |644| :pattern ( (Requires1 t0@@25 t1@@4 (Handle1 h@@26 r@@9 rd@@3) heap@@3 bx0@@0)) )))
(assert (forall ((arg0@@119 T@U) (arg1@@55 T@U) (arg2@@18 T@U) (arg3@@2 T@U) (arg4@@0 T@U) ) (! (= (type (Reads1 arg0@@119 arg1@@55 arg2@@18 arg3@@2 arg4@@0)) (MapType0Type BoxType boolType)) :qid |funType:Reads1| :pattern ( (Reads1 arg0@@119 arg1@@55 arg2@@18 arg3@@2 arg4@@0)) )))
(assert (forall ((t0@@26 T@U) (t1@@5 T@U) (heap@@4 T@U) (h@@27 T@U) (r@@10 T@U) (rd@@4 T@U) (bx0@@1 T@U) (bx@@42 T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type t0@@26) TyType) (= (type t1@@5) TyType)) (= (type heap@@4) (MapType1Type refType))) (= (type h@@27) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@10) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@4) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@1) BoxType)) (= (type bx@@42) BoxType)) (and (=> (U_2_bool (MapType0Select (Reads1 t0@@26 t1@@5 (Handle1 h@@27 r@@10 rd@@4) heap@@4 bx0@@1) bx@@42)) (U_2_bool (MapType0Select (MapType2Select rd@@4 heap@@4 bx0@@1) bx@@42))) (=> (U_2_bool (MapType0Select (MapType2Select rd@@4 heap@@4 bx0@@1) bx@@42)) (U_2_bool (MapType0Select (Reads1 t0@@26 t1@@5 (Handle1 h@@27 r@@10 rd@@4) heap@@4 bx0@@1) bx@@42))))) :qid |unknown.0:0| :skolemid |645| :pattern ( (MapType0Select (Reads1 t0@@26 t1@@5 (Handle1 h@@27 r@@10 rd@@4) heap@@4 bx0@@1) bx@@42)) )))
(assert (forall ((t0@@27 T@U) (t1@@6 T@U) (h0@@6 T@U) (h1@@6 T@U) (f@@14 T@U) (bx0@@2 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@27) TyType) (= (type t1@@6) TyType)) (= (type h0@@6) (MapType1Type refType))) (= (type h1@@6) (MapType1Type refType))) (= (type f@@14) HandleTypeType)) (= (type bx0@@2) BoxType)) (and (and (and ($HeapSucc h0@@6 h1@@6) (and ($IsGoodHeap h0@@6) ($IsGoodHeap h1@@6))) (and ($IsBox bx0@@2 t0@@27) ($Is f@@14 (Tclass._System.___hFunc1 t0@@27 t1@@6)))) (forall ((o@@45 T@U) (fld@@5 T@U) ) (! (let ((a@@83 (FieldTypeInv0 (type fld@@5)))) (=> (and (and (= (type o@@45) refType) (= (type fld@@5) (FieldType a@@83))) (and (not (= o@@45 null)) (U_2_bool (MapType0Select (Reads1 t0@@27 t1@@6 f@@14 h0@@6 bx0@@2) ($Box o@@45))))) (= (MapType1Select h0@@6 o@@45 fld@@5) (MapType1Select h1@@6 o@@45 fld@@5)))) :qid |unknown.0:0| :skolemid |646| :no-pattern (type o@@45) :no-pattern (type fld@@5) :no-pattern (U_2_int o@@45) :no-pattern (U_2_bool o@@45) :no-pattern (U_2_int fld@@5) :no-pattern (U_2_bool fld@@5) )))) (= (Reads1 t0@@27 t1@@6 f@@14 h0@@6 bx0@@2) (Reads1 t0@@27 t1@@6 f@@14 h1@@6 bx0@@2))) :qid |unknown.0:0| :skolemid |647| :pattern ( ($HeapSucc h0@@6 h1@@6) (Reads1 t0@@27 t1@@6 f@@14 h1@@6 bx0@@2)) )))
(assert (forall ((t0@@28 T@U) (t1@@7 T@U) (h0@@7 T@U) (h1@@7 T@U) (f@@15 T@U) (bx0@@3 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@28) TyType) (= (type t1@@7) TyType)) (= (type h0@@7) (MapType1Type refType))) (= (type h1@@7) (MapType1Type refType))) (= (type f@@15) HandleTypeType)) (= (type bx0@@3) BoxType)) (and (and (and ($HeapSucc h0@@7 h1@@7) (and ($IsGoodHeap h0@@7) ($IsGoodHeap h1@@7))) (and ($IsBox bx0@@3 t0@@28) ($Is f@@15 (Tclass._System.___hFunc1 t0@@28 t1@@7)))) (forall ((o@@46 T@U) (fld@@6 T@U) ) (! (let ((a@@84 (FieldTypeInv0 (type fld@@6)))) (=> (and (and (= (type o@@46) refType) (= (type fld@@6) (FieldType a@@84))) (and (not (= o@@46 null)) (U_2_bool (MapType0Select (Reads1 t0@@28 t1@@7 f@@15 h1@@7 bx0@@3) ($Box o@@46))))) (= (MapType1Select h0@@7 o@@46 fld@@6) (MapType1Select h1@@7 o@@46 fld@@6)))) :qid |unknown.0:0| :skolemid |648| :no-pattern (type o@@46) :no-pattern (type fld@@6) :no-pattern (U_2_int o@@46) :no-pattern (U_2_bool o@@46) :no-pattern (U_2_int fld@@6) :no-pattern (U_2_bool fld@@6) )))) (= (Reads1 t0@@28 t1@@7 f@@15 h0@@7 bx0@@3) (Reads1 t0@@28 t1@@7 f@@15 h1@@7 bx0@@3))) :qid |unknown.0:0| :skolemid |649| :pattern ( ($HeapSucc h0@@7 h1@@7) (Reads1 t0@@28 t1@@7 f@@15 h1@@7 bx0@@3)) )))
(assert (forall ((t0@@29 T@U) (t1@@8 T@U) (h0@@8 T@U) (h1@@8 T@U) (f@@16 T@U) (bx0@@4 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@29) TyType) (= (type t1@@8) TyType)) (= (type h0@@8) (MapType1Type refType))) (= (type h1@@8) (MapType1Type refType))) (= (type f@@16) HandleTypeType)) (= (type bx0@@4) BoxType)) (and (and (and ($HeapSucc h0@@8 h1@@8) (and ($IsGoodHeap h0@@8) ($IsGoodHeap h1@@8))) (and ($IsBox bx0@@4 t0@@29) ($Is f@@16 (Tclass._System.___hFunc1 t0@@29 t1@@8)))) (forall ((o@@47 T@U) (fld@@7 T@U) ) (! (let ((a@@85 (FieldTypeInv0 (type fld@@7)))) (=> (and (and (= (type o@@47) refType) (= (type fld@@7) (FieldType a@@85))) (and (not (= o@@47 null)) (U_2_bool (MapType0Select (Reads1 t0@@29 t1@@8 f@@16 h0@@8 bx0@@4) ($Box o@@47))))) (= (MapType1Select h0@@8 o@@47 fld@@7) (MapType1Select h1@@8 o@@47 fld@@7)))) :qid |unknown.0:0| :skolemid |650| :no-pattern (type o@@47) :no-pattern (type fld@@7) :no-pattern (U_2_int o@@47) :no-pattern (U_2_bool o@@47) :no-pattern (U_2_int fld@@7) :no-pattern (U_2_bool fld@@7) )))) (and (=> (Requires1 t0@@29 t1@@8 f@@16 h0@@8 bx0@@4) (Requires1 t0@@29 t1@@8 f@@16 h1@@8 bx0@@4)) (=> (Requires1 t0@@29 t1@@8 f@@16 h1@@8 bx0@@4) (Requires1 t0@@29 t1@@8 f@@16 h0@@8 bx0@@4)))) :qid |unknown.0:0| :skolemid |651| :pattern ( ($HeapSucc h0@@8 h1@@8) (Requires1 t0@@29 t1@@8 f@@16 h1@@8 bx0@@4)) )))
(assert (forall ((t0@@30 T@U) (t1@@9 T@U) (h0@@9 T@U) (h1@@9 T@U) (f@@17 T@U) (bx0@@5 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@30) TyType) (= (type t1@@9) TyType)) (= (type h0@@9) (MapType1Type refType))) (= (type h1@@9) (MapType1Type refType))) (= (type f@@17) HandleTypeType)) (= (type bx0@@5) BoxType)) (and (and (and ($HeapSucc h0@@9 h1@@9) (and ($IsGoodHeap h0@@9) ($IsGoodHeap h1@@9))) (and ($IsBox bx0@@5 t0@@30) ($Is f@@17 (Tclass._System.___hFunc1 t0@@30 t1@@9)))) (forall ((o@@48 T@U) (fld@@8 T@U) ) (! (let ((a@@86 (FieldTypeInv0 (type fld@@8)))) (=> (and (and (= (type o@@48) refType) (= (type fld@@8) (FieldType a@@86))) (and (not (= o@@48 null)) (U_2_bool (MapType0Select (Reads1 t0@@30 t1@@9 f@@17 h1@@9 bx0@@5) ($Box o@@48))))) (= (MapType1Select h0@@9 o@@48 fld@@8) (MapType1Select h1@@9 o@@48 fld@@8)))) :qid |unknown.0:0| :skolemid |652| :no-pattern (type o@@48) :no-pattern (type fld@@8) :no-pattern (U_2_int o@@48) :no-pattern (U_2_bool o@@48) :no-pattern (U_2_int fld@@8) :no-pattern (U_2_bool fld@@8) )))) (and (=> (Requires1 t0@@30 t1@@9 f@@17 h0@@9 bx0@@5) (Requires1 t0@@30 t1@@9 f@@17 h1@@9 bx0@@5)) (=> (Requires1 t0@@30 t1@@9 f@@17 h1@@9 bx0@@5) (Requires1 t0@@30 t1@@9 f@@17 h0@@9 bx0@@5)))) :qid |unknown.0:0| :skolemid |653| :pattern ( ($HeapSucc h0@@9 h1@@9) (Requires1 t0@@30 t1@@9 f@@17 h1@@9 bx0@@5)) )))
(assert (forall ((t0@@31 T@U) (t1@@10 T@U) (h0@@10 T@U) (h1@@10 T@U) (f@@18 T@U) (bx0@@6 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@31) TyType) (= (type t1@@10) TyType)) (= (type h0@@10) (MapType1Type refType))) (= (type h1@@10) (MapType1Type refType))) (= (type f@@18) HandleTypeType)) (= (type bx0@@6) BoxType)) (and (and (and ($HeapSucc h0@@10 h1@@10) (and ($IsGoodHeap h0@@10) ($IsGoodHeap h1@@10))) (and ($IsBox bx0@@6 t0@@31) ($Is f@@18 (Tclass._System.___hFunc1 t0@@31 t1@@10)))) (forall ((o@@49 T@U) (fld@@9 T@U) ) (! (let ((a@@87 (FieldTypeInv0 (type fld@@9)))) (=> (and (and (= (type o@@49) refType) (= (type fld@@9) (FieldType a@@87))) (and (not (= o@@49 null)) (U_2_bool (MapType0Select (Reads1 t0@@31 t1@@10 f@@18 h0@@10 bx0@@6) ($Box o@@49))))) (= (MapType1Select h0@@10 o@@49 fld@@9) (MapType1Select h1@@10 o@@49 fld@@9)))) :qid |unknown.0:0| :skolemid |654| :no-pattern (type o@@49) :no-pattern (type fld@@9) :no-pattern (U_2_int o@@49) :no-pattern (U_2_bool o@@49) :no-pattern (U_2_int fld@@9) :no-pattern (U_2_bool fld@@9) )))) (= (Apply1 t0@@31 t1@@10 f@@18 h0@@10 bx0@@6) (Apply1 t0@@31 t1@@10 f@@18 h1@@10 bx0@@6))) :qid |unknown.0:0| :skolemid |655| :pattern ( ($HeapSucc h0@@10 h1@@10) (Apply1 t0@@31 t1@@10 f@@18 h1@@10 bx0@@6)) )))
(assert (forall ((t0@@32 T@U) (t1@@11 T@U) (h0@@11 T@U) (h1@@11 T@U) (f@@19 T@U) (bx0@@7 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@32) TyType) (= (type t1@@11) TyType)) (= (type h0@@11) (MapType1Type refType))) (= (type h1@@11) (MapType1Type refType))) (= (type f@@19) HandleTypeType)) (= (type bx0@@7) BoxType)) (and (and (and ($HeapSucc h0@@11 h1@@11) (and ($IsGoodHeap h0@@11) ($IsGoodHeap h1@@11))) (and ($IsBox bx0@@7 t0@@32) ($Is f@@19 (Tclass._System.___hFunc1 t0@@32 t1@@11)))) (forall ((o@@50 T@U) (fld@@10 T@U) ) (! (let ((a@@88 (FieldTypeInv0 (type fld@@10)))) (=> (and (and (= (type o@@50) refType) (= (type fld@@10) (FieldType a@@88))) (and (not (= o@@50 null)) (U_2_bool (MapType0Select (Reads1 t0@@32 t1@@11 f@@19 h1@@11 bx0@@7) ($Box o@@50))))) (= (MapType1Select h0@@11 o@@50 fld@@10) (MapType1Select h1@@11 o@@50 fld@@10)))) :qid |unknown.0:0| :skolemid |656| :no-pattern (type o@@50) :no-pattern (type fld@@10) :no-pattern (U_2_int o@@50) :no-pattern (U_2_bool o@@50) :no-pattern (U_2_int fld@@10) :no-pattern (U_2_bool fld@@10) )))) (= (Apply1 t0@@32 t1@@11 f@@19 h0@@11 bx0@@7) (Apply1 t0@@32 t1@@11 f@@19 h1@@11 bx0@@7))) :qid |unknown.0:0| :skolemid |657| :pattern ( ($HeapSucc h0@@11 h1@@11) (Apply1 t0@@32 t1@@11 f@@19 h1@@11 bx0@@7)) )))
(assert (forall ((f@@20 T@U) (t0@@33 T@U) (t1@@12 T@U) ) (!  (=> (and (and (= (type f@@20) HandleTypeType) (= (type t0@@33) TyType)) (= (type t1@@12) TyType)) (and (=> ($Is f@@20 (Tclass._System.___hFunc1 t0@@33 t1@@12)) (forall ((h@@28 T@U) (bx0@@8 T@U) ) (!  (=> (and (= (type h@@28) (MapType1Type refType)) (= (type bx0@@8) BoxType)) (=> (and (and ($IsGoodHeap h@@28) ($IsBox bx0@@8 t0@@33)) (Requires1 t0@@33 t1@@12 f@@20 h@@28 bx0@@8)) ($IsBox (Apply1 t0@@33 t1@@12 f@@20 h@@28 bx0@@8) t1@@12))) :qid |DafnyPre.405:12| :skolemid |658| :pattern ( (Apply1 t0@@33 t1@@12 f@@20 h@@28 bx0@@8)) ))) (=> (forall ((h@@29 T@U) (bx0@@9 T@U) ) (!  (=> (and (= (type h@@29) (MapType1Type refType)) (= (type bx0@@9) BoxType)) (=> (and (and ($IsGoodHeap h@@29) ($IsBox bx0@@9 t0@@33)) (Requires1 t0@@33 t1@@12 f@@20 h@@29 bx0@@9)) ($IsBox (Apply1 t0@@33 t1@@12 f@@20 h@@29 bx0@@9) t1@@12))) :qid |DafnyPre.405:12| :skolemid |658| :pattern ( (Apply1 t0@@33 t1@@12 f@@20 h@@29 bx0@@9)) )) ($Is f@@20 (Tclass._System.___hFunc1 t0@@33 t1@@12))))) :qid |unknown.0:0| :skolemid |659| :pattern ( ($Is f@@20 (Tclass._System.___hFunc1 t0@@33 t1@@12))) )))
(assert (forall ((f@@21 T@U) (t0@@34 T@U) (t1@@13 T@U) (u0@@0 T@U) (u1 T@U) ) (!  (=> (and (and (and (and (and (= (type f@@21) HandleTypeType) (= (type t0@@34) TyType)) (= (type t1@@13) TyType)) (= (type u0@@0) TyType)) (= (type u1) TyType)) (and (and ($Is f@@21 (Tclass._System.___hFunc1 t0@@34 t1@@13)) (forall ((bx@@43 T@U) ) (!  (=> (and (= (type bx@@43) BoxType) ($IsBox bx@@43 u0@@0)) ($IsBox bx@@43 t0@@34)) :qid |unknown.0:0| :skolemid |660| :pattern ( ($IsBox bx@@43 u0@@0)) :pattern ( ($IsBox bx@@43 t0@@34)) ))) (forall ((bx@@44 T@U) ) (!  (=> (and (= (type bx@@44) BoxType) ($IsBox bx@@44 t1@@13)) ($IsBox bx@@44 u1)) :qid |unknown.0:0| :skolemid |661| :pattern ( ($IsBox bx@@44 t1@@13)) :pattern ( ($IsBox bx@@44 u1)) )))) ($Is f@@21 (Tclass._System.___hFunc1 u0@@0 u1))) :qid |unknown.0:0| :skolemid |662| :pattern ( ($Is f@@21 (Tclass._System.___hFunc1 t0@@34 t1@@13)) ($Is f@@21 (Tclass._System.___hFunc1 u0@@0 u1))) )))
(assert (forall ((f@@22 T@U) (t0@@35 T@U) (t1@@14 T@U) (h@@30 T@U) ) (!  (=> (and (and (and (and (= (type f@@22) HandleTypeType) (= (type t0@@35) TyType)) (= (type t1@@14) TyType)) (= (type h@@30) (MapType1Type refType))) ($IsGoodHeap h@@30)) ($IsAlloc f@@22 (Tclass._System.___hFunc1 t0@@35 t1@@14) h@@30)) :qid |unknown.0:0| :skolemid |664| :pattern ( ($IsAlloc f@@22 (Tclass._System.___hFunc1 t0@@35 t1@@14) h@@30)) )))
(assert (= (type Tclass._module.__default) TyType))
(assert (= (Tag Tclass._module.__default) Tagclass._module.__default))
(assert (forall ((bx@@45 T@U) ) (!  (=> (and (= (type bx@@45) BoxType) ($IsBox bx@@45 Tclass._module.__default)) (and (= ($Box ($Unbox refType bx@@45)) bx@@45) ($Is ($Unbox refType bx@@45) Tclass._module.__default))) :qid |unknown.0:0| :skolemid |665| :pattern ( ($IsBox bx@@45 Tclass._module.__default)) )))
(assert (forall (($o@@5 T@U) ) (!  (=> (= (type $o@@5) refType) (and (=> ($Is $o@@5 Tclass._module.__default) (or (= $o@@5 null) (= (dtype $o@@5) Tclass._module.__default))) (=> (or (= $o@@5 null) (= (dtype $o@@5) Tclass._module.__default)) ($Is $o@@5 Tclass._module.__default)))) :qid |unknown.0:0| :skolemid |666| :pattern ( ($Is $o@@5 Tclass._module.__default)) )))
(assert (forall (($o@@6 T@U) ($h@@5 T@U) ) (!  (=> (and (= (type $o@@6) refType) (= (type $h@@5) (MapType1Type refType))) (and (=> ($IsAlloc $o@@6 Tclass._module.__default $h@@5) (or (= $o@@6 null) (U_2_bool (MapType1Select $h@@5 $o@@6 alloc)))) (=> (or (= $o@@6 null) (U_2_bool (MapType1Select $h@@5 $o@@6 alloc))) ($IsAlloc $o@@6 Tclass._module.__default $h@@5)))) :qid |unknown.0:0| :skolemid |667| :pattern ( ($IsAlloc $o@@6 Tclass._module.__default $h@@5)) )))
(assert  (and (and (and (and (and (and (and (forall ((arg0@@120 T@T) (arg1@@56 T@T) ) (! (= (Ctor (MapType3Type arg0@@120 arg1@@56)) 21) :qid |ctor:MapType3Type| )) (forall ((arg0@@121 T@T) (arg1@@57 T@T) ) (! (= (MapType3TypeInv0 (MapType3Type arg0@@121 arg1@@57)) arg0@@121) :qid |typeInv:MapType3TypeInv0| :pattern ( (MapType3Type arg0@@121 arg1@@57)) ))) (forall ((arg0@@122 T@T) (arg1@@58 T@T) ) (! (= (MapType3TypeInv1 (MapType3Type arg0@@122 arg1@@58)) arg1@@58) :qid |typeInv:MapType3TypeInv1| :pattern ( (MapType3Type arg0@@122 arg1@@58)) ))) (forall ((arg0@@123 T@U) (arg1@@59 T@U) (arg2@@19 T@U) ) (! (let ((aVar1@@3 (MapType3TypeInv1 (type arg0@@123)))) (= (type (MapType3Select arg0@@123 arg1@@59 arg2@@19)) aVar1@@3)) :qid |funType:MapType3Select| :pattern ( (MapType3Select arg0@@123 arg1@@59 arg2@@19)) ))) (forall ((arg0@@124 T@U) (arg1@@60 T@U) (arg2@@20 T@U) (arg3@@3 T@U) ) (! (let ((aVar1@@4 (type arg3@@3))) (let ((aVar0@@2 (type arg1@@60))) (= (type (MapType3Store arg0@@124 arg1@@60 arg2@@20 arg3@@3)) (MapType3Type aVar0@@2 aVar1@@4)))) :qid |funType:MapType3Store| :pattern ( (MapType3Store arg0@@124 arg1@@60 arg2@@20 arg3@@3)) ))) (forall ((m@@31 T@U) (x0@@10 T@U) (x1@@7 T@U) (val@@11 T@U) ) (! (let ((aVar1@@5 (MapType3TypeInv1 (type m@@31)))) (=> (= (type val@@11) aVar1@@5) (= (MapType3Select (MapType3Store m@@31 x0@@10 x1@@7 val@@11) x0@@10 x1@@7) val@@11))) :qid |mapAx0:MapType3Select| :weight 0 ))) (and (and (forall ((val@@12 T@U) (m@@32 T@U) (x0@@11 T@U) (x1@@8 T@U) (y0@@7 T@U) (y1@@5 T@U) ) (!  (or (= x0@@11 y0@@7) (= (MapType3Select (MapType3Store m@@32 x0@@11 x1@@8 val@@12) y0@@7 y1@@5) (MapType3Select m@@32 y0@@7 y1@@5))) :qid |mapAx1:MapType3Select:0| :weight 0 )) (forall ((val@@13 T@U) (m@@33 T@U) (x0@@12 T@U) (x1@@9 T@U) (y0@@8 T@U) (y1@@6 T@U) ) (!  (or (= x1@@9 y1@@6) (= (MapType3Select (MapType3Store m@@33 x0@@12 x1@@9 val@@13) y0@@8 y1@@6) (MapType3Select m@@33 y0@@8 y1@@6))) :qid |mapAx1:MapType3Select:1| :weight 0 ))) (forall ((val@@14 T@U) (m@@34 T@U) (x0@@13 T@U) (x1@@10 T@U) (y0@@9 T@U) (y1@@7 T@U) ) (!  (or true (= (MapType3Select (MapType3Store m@@34 x0@@13 x1@@10 val@@14) y0@@9 y1@@7) (MapType3Select m@@34 y0@@9 y1@@7))) :qid |mapAx2:MapType3Select| :weight 0 )))) (forall ((arg0@@125 T@U) (arg1@@61 T@U) (arg2@@21 T@U) ) (! (= (type (|lambda#0| arg0@@125 arg1@@61 arg2@@21)) (MapType3Type refType boolType)) :qid |funType:lambda#0| :pattern ( (|lambda#0| arg0@@125 arg1@@61 arg2@@21)) ))))
(assert (forall (($o@@7 T@U) ($f T@U) (alloc@@0 T@U) (null@@0 T@U) ($Heap T@U) ) (! (let ((alpha@@6 (FieldTypeInv0 (type $f)))) (=> (and (and (and (and (= (type $o@@7) refType) (= (type $f) (FieldType alpha@@6))) (= (type alloc@@0) (FieldType boolType))) (= (type null@@0) refType)) (= (type $Heap) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#0| alloc@@0 null@@0 $Heap) $o@@7 $f))  (=> (and (not (= $o@@7 null@@0)) (U_2_bool (MapType1Select $Heap $o@@7 alloc@@0))) false)))) :qid |bitvecto.1:7| :skolemid |668| :pattern ( (MapType3Select (|lambda#0| alloc@@0 null@@0 $Heap) $o@@7 $f)) )))
(assert (forall ((arg0@@126 T@U) (arg1@@62 T@U) (arg2@@22 T@U) ) (! (= (type (|lambda#1| arg0@@126 arg1@@62 arg2@@22)) (MapType3Type refType boolType)) :qid |funType:lambda#1| :pattern ( (|lambda#1| arg0@@126 arg1@@62 arg2@@22)) )))
(assert (forall (($o@@8 T@U) ($f@@0 T@U) (alloc@@1 T@U) (null@@1 T@U) ($Heap@@0 T@U) ) (! (let ((alpha@@7 (FieldTypeInv0 (type $f@@0)))) (=> (and (and (and (and (= (type $o@@8) refType) (= (type $f@@0) (FieldType alpha@@7))) (= (type alloc@@1) (FieldType boolType))) (= (type null@@1) refType)) (= (type $Heap@@0) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#1| alloc@@1 null@@1 $Heap@@0) $o@@8 $f@@0))  (=> (and (not (= $o@@8 null@@1)) (U_2_bool (MapType1Select $Heap@@0 $o@@8 alloc@@1))) false)))) :qid |bitvecto.1:7| :skolemid |669| :pattern ( (MapType3Select (|lambda#1| alloc@@1 null@@1 $Heap@@0) $o@@8 $f@@0)) )))
(assert (forall ((arg0@@127 T@U) (arg1@@63 T@U) (arg2@@23 T@U) ) (! (= (type (|lambda#2| arg0@@127 arg1@@63 arg2@@23)) (MapType3Type refType boolType)) :qid |funType:lambda#2| :pattern ( (|lambda#2| arg0@@127 arg1@@63 arg2@@23)) )))
(assert (forall (($o@@9 T@U) ($f@@1 T@U) (alloc@@2 T@U) (null@@2 T@U) ($Heap@@1 T@U) ) (! (let ((alpha@@8 (FieldTypeInv0 (type $f@@1)))) (=> (and (and (and (and (= (type $o@@9) refType) (= (type $f@@1) (FieldType alpha@@8))) (= (type alloc@@2) (FieldType boolType))) (= (type null@@2) refType)) (= (type $Heap@@1) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#2| alloc@@2 null@@2 $Heap@@1) $o@@9 $f@@1))  (=> (and (not (= $o@@9 null@@2)) (U_2_bool (MapType1Select $Heap@@1 $o@@9 alloc@@2))) false)))) :qid |bitvecto.6:7| :skolemid |670| :pattern ( (MapType3Select (|lambda#2| alloc@@2 null@@2 $Heap@@1) $o@@9 $f@@1)) )))
(assert (forall ((arg0@@128 T@U) (arg1@@64 T@U) (arg2@@24 T@U) ) (! (= (type (|lambda#3| arg0@@128 arg1@@64 arg2@@24)) (MapType3Type refType boolType)) :qid |funType:lambda#3| :pattern ( (|lambda#3| arg0@@128 arg1@@64 arg2@@24)) )))
(assert (forall (($o@@10 T@U) ($f@@2 T@U) (alloc@@3 T@U) (null@@3 T@U) ($Heap@@2 T@U) ) (! (let ((alpha@@9 (FieldTypeInv0 (type $f@@2)))) (=> (and (and (and (and (= (type $o@@10) refType) (= (type $f@@2) (FieldType alpha@@9))) (= (type alloc@@3) (FieldType boolType))) (= (type null@@3) refType)) (= (type $Heap@@2) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#3| alloc@@3 null@@3 $Heap@@2) $o@@10 $f@@2))  (=> (and (not (= $o@@10 null@@3)) (U_2_bool (MapType1Select $Heap@@2 $o@@10 alloc@@3))) false)))) :qid |bitvecto.6:7| :skolemid |671| :pattern ( (MapType3Select (|lambda#3| alloc@@3 null@@3 $Heap@@2) $o@@10 $f@@2)) )))
(declare-fun $_Frame@0 () T@U)
(declare-fun $Heap@@3 () T@U)
(declare-fun %lbl%+0 () Bool)
(declare-fun %lbl%@1 () Bool)
(declare-fun |x#0@@1| () (_ BitVec 32))
(declare-fun |a#0| () Int)
(declare-fun |b#0| () Int)
(declare-fun %lbl%+2 () Bool)
(declare-fun $IsHeapAnchor (T@U) Bool)
(declare-fun $FunctionContextHeight () Int)
(assert  (and (= (type $_Frame@0) (MapType3Type refType boolType)) (= (type $Heap@@3) (MapType1Type refType))))
(push 1)
(set-info :boogie-vc-id Impl$$_module.__default.lemma__ShiftsLeftSum)
(assert (not (let ((anon0_correct  (=> (! (and %lbl%+0 true) :lblpos +0) (=> (= $_Frame@0 (|lambda#1| alloc null $Heap@@3)) (! (or %lbl%@1 (= (bvshl |x#0@@1| ((_ int2bv 32) (INTERNAL_add_boogie |a#0| |b#0|))) (bvshl (bvshl |x#0@@1| ((_ int2bv 32) |a#0|)) ((_ int2bv 32) |b#0|)))) :lblneg @1))))) (let ((PreconditionGeneratedEntry_correct  (=> (! (and %lbl%+2 true) :lblpos +2) (=> (and ($IsGoodHeap $Heap@@3) ($IsHeapAnchor $Heap@@3)) (=> (and (and (INTERNAL_le_boogie 0 |a#0|) (INTERNAL_le_boogie 0 |b#0|)) (and (= 1 $FunctionContextHeight) (or (or (or (and (INTERNAL_le_boogie 0 (INTERNAL_add_boogie |a#0| |b#0|)) (INTERNAL_lt_boogie (INTERNAL_add_boogie |a#0| |b#0|) 8)) (and (INTERNAL_le_boogie 8 (INTERNAL_add_boogie |a#0| |b#0|)) (INTERNAL_lt_boogie (INTERNAL_add_boogie |a#0| |b#0|) 16))) (and (INTERNAL_le_boogie 16 (INTERNAL_add_boogie |a#0| |b#0|)) (INTERNAL_lt_boogie (INTERNAL_add_boogie |a#0| |b#0|) 24))) (and (INTERNAL_le_boogie 24 (INTERNAL_add_boogie |a#0| |b#0|)) (INTERNAL_lt_boogie (INTERNAL_add_boogie |a#0| |b#0|) 32))))) anon0_correct))))) PreconditionGeneratedEntry_correct)) ))
(check-sat)
